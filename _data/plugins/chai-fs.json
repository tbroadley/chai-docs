{"_id":"chai-fs","_rev":"14-bbfdfd8222cb2ead98c80bd79adf063c","name":"chai-fs","description":"Chai assertions for Node.js filesystem","dist-tags":{"latest":"2.0.0"},"versions":{"0.0.1":{"name":"chai-fs","version":"0.0.1","description":"Chai assertions for Node.js file system api","author":{"name":"Bart van der Schoor","url":"https://github.com/Bartvds"},"repository":{"type":"git","url":"https://github.com/Bartvds/chai-fs.git"},"licenses":[{"type":"MIT","url":"https://github.com/Bartvds/chai-fs/blob/master/LICENSE-MIT"}],"bugs":{"url":"https://github.com/Bartvds/chai-fs/issues"},"keywords":["chai","json","assertion","json-schema"],"main":"lib/index.js","engines":{"node":">= 0.6.0"},"scripts":{"test":"grunt test"},"devDependencies":{"chai":"~1.6.1","grunt":"~0.4.1","grunt-cli":"~0.1","grunt-mocha-test":"~0.5.0","grunt-contrib-jshint":"~0.6.0","mocha-unfunk-reporter":"~0.2","jshint-path-reporter":"~0.1","mkdirp":"~0.3.5","underscore":"~1.5.1","chai-json-schema":"~1.0.4"},"dependencies":{"bit-mask":"0.0.2-alpha"},"_id":"chai-fs@0.0.1","dist":{"shasum":"953a4fc11c8b4c5b00e2f238b6ac8076c129bee6","tarball":"https://registry.npmjs.org/chai-fs/-/chai-fs-0.0.1.tgz"},"_from":".","_npmVersion":"1.2.25","_npmUser":{"name":"bartvds","email":"bartvanderschoor@gmail.com"},"maintainers":[{"name":"bartvds","email":"bartvanderschoor@gmail.com"}],"directories":{}},"0.0.2":{"name":"chai-fs","version":"0.0.2","description":"Chai assertions for Node.js filesystem","author":{"name":"Bart van der Schoor","url":"https://github.com/Bartvds"},"repository":{"type":"git","url":"https://github.com/Bartvds/chai-fs.git"},"licenses":[{"type":"MIT","url":"https://github.com/Bartvds/chai-fs/blob/master/LICENSE-MIT"}],"bugs":{"url":"https://github.com/Bartvds/chai-fs/issues"},"keywords":["chai","test","assertion","assert","testing","file","path","filesystem"],"main":"lib/index.js","engines":{"node":">= 0.6.0"},"scripts":{"test":"grunt test"},"dependencies":{"bit-mask":"0.0.2-alpha"},"devDependencies":{"chai":"1.6.1","grunt":"0.4.1","grunt-cli":"0.1","grunt-mocha-test":"0.5.0","grunt-contrib-jshint":"0.6.0","grunt-contrib-clean":"0.5.0","mocha-unfunk-reporter":"~0.2","jshint-path-reporter":"~0.1","mkdirp":"0.3.5","underscore":"1.5.1","chai-json-schema":"1.0.4","grunt-bump":"0.0.11"},"peerDependencies":{"chai":">= 1.6.1 < 2"},"_id":"chai-fs@0.0.2","dist":{"shasum":"7d5a2dff65c1034aaa0485e224b5c373d3c2308f","tarball":"https://registry.npmjs.org/chai-fs/-/chai-fs-0.0.2.tgz"},"_from":".","_npmVersion":"1.2.25","_npmUser":{"name":"bartvds","email":"bartvanderschoor@gmail.com"},"maintainers":[{"name":"bartvds","email":"bartvanderschoor@gmail.com"}],"directories":{}},"0.0.3":{"name":"chai-fs","version":"0.0.3","description":"Chai assertions for Node.js filesystem","author":{"name":"Bart van der Schoor","url":"https://github.com/Bartvds"},"repository":{"type":"git","url":"https://github.com/Bartvds/chai-fs.git"},"licenses":[{"type":"MIT","url":"https://github.com/Bartvds/chai-fs/blob/master/LICENSE-MIT"}],"bugs":{"url":"https://github.com/Bartvds/chai-fs/issues"},"keywords":["chai","test","assertion","assert","testing","file","path","filesystem"],"main":"lib/index.js","engines":{"node":">= 0.6.0"},"scripts":{"test":"grunt test"},"dependencies":{"bit-mask":"0.0.2-alpha"},"devDependencies":{"chai":"1.6.1","grunt":"0.4.1","grunt-cli":"0.1","grunt-mocha-test":"0.5.0","grunt-contrib-jshint":"0.6.3","grunt-contrib-clean":"0.5.0","mocha-unfunk-reporter":"~0.2","jshint-path-reporter":"~0.1","mkdirp":"0.3.5","underscore":"1.5.1","chai-json-schema":"1.0.4","grunt-bump":"0.0.11"},"peerDependencies":{"chai":">= 1.6.1 < 2"},"_id":"chai-fs@0.0.3","dist":{"shasum":"1aae6edffd38db58ac31c09b922bc62a8ab3a188","tarball":"https://registry.npmjs.org/chai-fs/-/chai-fs-0.0.3.tgz"},"_from":".","_npmVersion":"1.2.25","_npmUser":{"name":"bartvds","email":"bartvanderschoor@gmail.com"},"maintainers":[{"name":"bartvds","email":"bartvanderschoor@gmail.com"}],"directories":{}},"0.1.0":{"name":"chai-fs","version":"0.1.0","description":"Chai assertions for Node.js filesystem","author":{"name":"Bart van der Schoor","url":"https://github.com/Bartvds"},"repository":{"type":"git","url":"https://github.com/Bartvds/chai-fs.git"},"licenses":[{"type":"MIT","url":"https://github.com/Bartvds/chai-fs/blob/master/LICENSE-MIT"}],"bugs":{"url":"https://github.com/Bartvds/chai-fs/issues"},"keywords":["chai","test","assertion","assert","testing","file","path","filesystem"],"main":"lib/index.js","engines":{"node":">= 0.10.0"},"scripts":{"test":"grunt test"},"dependencies":{"bit-mask":"0.0.2-alpha"},"devDependencies":{"chai":"^1.9.1","chai-json-schema":"1.0.4","grunt":"0.4.1","grunt-bump":"0.0.11","grunt-cli":"0.1","grunt-contrib-clean":"0.5.0","grunt-contrib-jshint":"^0.10.0","grunt-mocha-test":"^0.11.0","jshint-path-reporter":"~0.1","mkdirp":"^0.5.0","mocha-unfunk-reporter":"^0.4.0","underscore":"^1.6.0"},"peerDependencies":{"chai":">= 1.6.1 < 2"},"homepage":"https://github.com/Bartvds/chai-fs","_id":"chai-fs@0.1.0","_shasum":"ee38bb4a467549926f4882bf57f0c5ea345a0980","_from":".","_npmVersion":"1.4.9","_npmUser":{"name":"bartvds","email":"bartvanderschoor@gmail.com"},"maintainers":[{"name":"bartvds","email":"bartvanderschoor@gmail.com"}],"dist":{"shasum":"ee38bb4a467549926f4882bf57f0c5ea345a0980","tarball":"https://registry.npmjs.org/chai-fs/-/chai-fs-0.1.0.tgz"},"directories":{}},"1.0.0":{"name":"chai-fs","version":"1.0.0","description":"Chai assertions for Node.js filesystem","author":{"name":"Bart van der Schoor","url":"https://github.com/Bartvds"},"repository":{"type":"git","url":"git+https://github.com/chaijs/chai-fs.git"},"licenses":[{"type":"MIT","url":"https://github.com/chaijs/chai-fs/blob/master/LICENSE-MIT"}],"bugs":{"url":"https://github.com/chaijs/chai-fs/issues"},"keywords":["chai","chai-plugin","vendor","fs","test","assertion","assert","testing","file","path","filesystem"],"main":"lib/index.js","engines":{"node":">= 0.10.0"},"scripts":{"test":"grunt test"},"dependencies":{"bit-mask":"0.0.2-alpha","readdir-enhanced":"^1.4.0"},"devDependencies":{"chai":"^3.5.0","chai-json-schema":"^1.3.0","del":"^2.2.2","grunt":"^1.0.1","grunt-bump":"^0.8.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.0.0","grunt-contrib-jshint":"^1.0.0","grunt-mocha-test":"^0.13.2","jshint-path-reporter":"~0.1","mkdirp":"^0.5.0","mocha":"^3.0.2","mocha-unfunk-reporter":"^0.4.0","touch":"^1.0.0","underscore":"^1.8.3"},"peerDependencies":{"chai":">= 1.6.1 < 5"},"gitHead":"40db3d9b8bfd7678a32132fee0e54d02c84b3c3c","homepage":"https://github.com/chaijs/chai-fs#readme","_id":"chai-fs@1.0.0","_shasum":"8b242852748a54f1df91f1ea430bb39748cf7421","_from":".","_npmVersion":"3.10.8","_nodeVersion":"7.0.0","_npmUser":{"name":"chaijs","email":"chaijs@keithcirkel.co.uk"},"dist":{"shasum":"8b242852748a54f1df91f1ea430bb39748cf7421","tarball":"https://registry.npmjs.org/chai-fs/-/chai-fs-1.0.0.tgz"},"maintainers":[{"name":"chaijs","email":"chaijs@keithcirkel.co.uk"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/chai-fs-1.0.0.tgz_1477577177662_0.868743194732815"},"directories":{}},"2.0.0":{"name":"chai-fs","version":"2.0.0","description":"Chai assertions for Node.js filesystem","author":{"name":"Bart van der Schoor","url":"https://github.com/Bartvds"},"repository":{"type":"git","url":"git+https://github.com/chaijs/chai-fs.git"},"licenses":[{"type":"MIT","url":"https://github.com/chaijs/chai-fs/blob/master/LICENSE-MIT"}],"bugs":{"url":"https://github.com/chaijs/chai-fs/issues"},"keywords":["chai","chai-plugin","vendor","fs","test","assertion","assert","testing","file","path","filesystem"],"main":"lib/index.js","engines":{"node":">=4"},"scripts":{"test":"grunt test"},"dependencies":{"bit-mask":"^1.0.1","readdir-enhanced":"^1.4.0"},"devDependencies":{"chai":"^4.1.2","chai-json-schema":"^1.3.0","del":"^3.0.0","grunt":"^1.0.1","grunt-bump":"^0.8.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.0.0","grunt-contrib-jshint":"^1.0.0","grunt-mocha-test":"^0.13.2","jshint-path-reporter":"~0.1","mkdirp":"^0.5.0","mocha":"^4.0.1","mocha-unfunk-reporter":"^0.4.0","touch":"^3.1.0","underscore":"^1.8.3"},"peerDependencies":{"chai":">= 1.6.1 < 5"},"gitHead":"6025bc2e8ad119d8bce6af9696577420af9665a8","homepage":"https://github.com/chaijs/chai-fs#readme","_id":"chai-fs@2.0.0","_shasum":"35ae039fbbb0710f5122aae17faba1e8f41107c6","_from":".","_npmVersion":"2.15.11","_nodeVersion":"4.8.5","_npmUser":{"name":"chaijs","email":"chaijs@keithcirkel.co.uk"},"dist":{"shasum":"35ae039fbbb0710f5122aae17faba1e8f41107c6","tarball":"https://registry.npmjs.org/chai-fs/-/chai-fs-2.0.0.tgz"},"maintainers":[{"name":"chaijs","email":"chaijs@keithcirkel.co.uk"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/chai-fs-2.0.0.tgz_1509979236256_0.0779384016059339"},"directories":{}}},"readme":"# chai-fs\n\n[![Build Status](https://secure.travis-ci.org/chaijs/chai-fs.png?branch=master)](http://travis-ci.org/chaijs/chai-fs) [![Dependency Status](https://david-dm.org/chaijs/chai-fs.svg)](https://david-dm.org/chaijs/chai-fs) [![devDependency Status](https://david-dm.org/chaijs/chai-fs/dev-status.svg)](https://david-dm.org/chaijs/chai-fs#info=devDependencies) [![NPM version](https://badge.fury.io/js/chai-fs.png)](http://badge.fury.io/js/chai-fs)\n\n[Chai](http://chaijs.com/) assertion [plugin](http://chaijs.com/plugins/chai-fs) for the Node.js filesystem API. Uses `path` and synchronous `fs` to assert files and directories.\n\nAll assertions are available in `expect`, `should` and `assert` style, and support the optional, message parameter.\n\n## Usage\n\n### server-side\n\nInstall from npm:\n\n    $ npm install chai-fs\n\nHave chai use the chai-fs module:\n\n    var chai = require('chai');\n    chai.use(require('chai-fs'));\n\n### browser-side\n\nNo file system.\n\n## Assertions\n\n### basename()\n\nAssert the return value of `path.basename(path)`\n\n\texpect(path).to.have.basename(name, ?msg);\n\texpect(path).to.not.have.basename(name, ?msg);\n\n\tpath.should.have.basename(name, ?msg);\n\tpath.should.not.have.basename(name, ?msg);\n\n\tassert.basename(path, name, ?msg);\n\tassert.notBasename(path, name, ?msg);\n\n\n### dirname()\n\nAssert the return value of `path.dirname(path)`\n\n\texpect(path).to.have.dirname(name, ?msg);\n\texpect(path).to.not.have.dirname(name, ?msg);\n\n\tpath.should.have.dirname(name, ?msg);\n\tpath.should.not.have.dirname(name, ?msg);\n\n\tassert.dirname(path, name, ?msg);\n\tassert.notDirname(path, name, ?msg);\n\n\n### extname()\n\nAssert the return value of `path.extname(path)`\n\n\texpect(path).to.have.extname(name, ?msg);\n\texpect(path).to.not.have.extname(name, ?msg);\n\n\tpath.should.have.extname(name, ?msg);\n\tpath.should.not.have.extname(name, ?msg);\n\n\tassert.extname(path, name, ?msg);\n\tassert.notExtname(path, name, ?msg);\n\n\n### path()\n\nAssert the path exists.\n\nUses `fs.existsSync()`.\n\n\texpect(path).to.be.a.path(?msg);\n\texpect(path).to.not.be.a.path(?msg);\n\n\tpath.should.be.a.path(?msg);\n\tpath.should.not.be.a.path(?msg);\n\n\tassert.pathExists(path, ?msg);\n\tassert.notPathExists(path, ?msg);\n\n\nUse of Chai's `exist`-chain would've been nice *but* has issues with negations and the message parameter. So don't do that.\n\n### directory()\n\nAssert the path exists and is a directory.\n\nUses `fs.statSync().isDirectory()`\n\n\texpect(path).to.be.a.directory(?msg);\n\texpect(path).to.not.be.a.directory(?msg);\n\n\tpath.should.be.a.directory(?msg);\n\tpath.should.not.be.a.directory(?msg);\n\n\tassert.isDirectory(path,  ?msg);\n\tassert.notIsDirectory(path, ?msg);\n\n### directory().and.empty\n\nAssert the path exists, is a directory and contains zero items.\n\n\texpect(path).to.be.a.directory(?msg).and.empty;\n\texpect(path).to.be.a.directory(?msg).and.not.empty;\n\n\tpath.should.be.a.directory(?msg).and.empty;\n\tpath.should.be.a.directory(?msg).and.not.empty;\n\n\tassert.isEmptyDirectory(path, ?msg);\n\tassert.notIsEmptyDirectory(path, ?msg);\n\n* Chains after `directory()`\n* Uses `fs.readdirSync().length === 0`.\n* To negate this using `expect/should` you chain the `.not`-negation ***after*** the regular `directory()`.\n\n### directory().with.contents([...])\n\nAssert the path exists, is a directory and has specific contents (files, sub-directories, symlinks, etc).\n\n\texpect(path).to.be.a.directory(?msg).with.contents(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.not.have.contents(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).with.deep.contents(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.not.have.deep.contents(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.include.contents(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.not.include.contents(array, ?msg);\n\n\tpath.should.be.a.directory(?msg).with.contents(array, ?msg);\n\tpath.should.be.a.directory(?msg).and.not.have.contents(array, ?msg);\n\tpath.should.be.a.directory(?msg).with.deep.contents(array, ?msg);\n\tpath.should.be.a.directory(?msg).and.not.have.deep.contents(array, ?msg);\n\tpath.should.be.a.directory(?msg).and.include.contents(array, ?msg);\n\tpath.should.be.a.directory(?msg).and.not.include.contents(array, ?msg);\n\n\tassert.directoryContent(path, array, ?msg);\n\tassert.notDirectoryContent(path, array, ?msg);\n\tassert.directoryDeepContent(path, array, ?msg);\n\tassert.notDirectoryDeepContent(path, array, ?msg);\n\tassert.directoryInclude(path, array, ?msg);\n\tassert.notDirectoryInclude(path, array, ?msg);\n\n* The paths of contents are relative to the directory\n* Only the top level contents are included, unless `.deep` is in the chain\n* If `.include` or `.contain` is in the chain, then the directory must contain _at least_ the specified contents, but may contain more\n* You can use `.content()` or `.contents()`. They're both the same.\n* To negate this using `expect/should` you chain the `.not`-negation ***after*** the regular `directory()`.\n\n### directory().with.files([...])\n\nAssert the path exists, is a directory and contains specific files.\n\n\texpect(path).to.be.a.directory(?msg).with.files(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.not.have.files(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).with.deep.files(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.not.have.deep.files(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.include.files(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.not.include.files(array, ?msg);\n\n\tpath.should.be.a.directory(?msg).with.files(array, ?msg);\n\tpath.should.be.a.directory(?msg).and.not.have.files(array, ?msg);\n\tpath.should.be.a.directory(?msg).with.deep.files(array, ?msg);\n\tpath.should.be.a.directory(?msg).and.not.have.deep.files(array, ?msg);\n\tpath.should.be.a.directory(?msg).and.include.files(array, ?msg);\n\tpath.should.be.a.directory(?msg).and.not.include.files(array, ?msg);\n\n\tassert.directoryFiles(path, array, ?msg);\n\tassert.notDirectoryFiles(path, array, ?msg);\n\tassert.directoryDeepFiles(path, array, ?msg);\n\tassert.notDirectoryDeepFiles(path, array, ?msg);\n\tassert.directoryIncludeFiles(path, array, ?msg);\n\tassert.notDirectoryIncludeFiles(path, array, ?msg);\n\n* The file paths are relative to the directory\n* Only the top level files are included, unless `.deep` is in the chain\n* If `.include` or `.contain` is in the chain, then the directory must contain _at least_ the specified files, but may contain more\n* To negate this using `expect/should` you chain the `.not`-negation ***after*** the regular `directory()`.\n\n### directory().with.subDirs([...])\n\nAssert the path exists, is a directory and contains specific sub-directories.\n\n\texpect(path).to.be.a.directory(?msg).with.subDirs(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.not.have.subDirs(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).with.deep.subDirs(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.not.have.deep.subDirs(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.include.subDirs(array, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.not.include.subDirs(array, ?msg);\n\n\tpath.should.be.a.directory(?msg).with.subDirs(array, ?msg);\n\tpath.should.be.a.directory(?msg).and.not.have.subDirs(array, ?msg);\n\tpath.should.be.a.directory(?msg).with.deep.subDirs(array, ?msg);\n\tpath.should.be.a.directory(?msg).and.not.have.deep.subDirs(array, ?msg);\n\tpath.should.be.a.directory(?msg).and.include.subDirs(array, ?msg);\n\tpath.should.be.a.directory(?msg).and.not.include.subDirs(array, ?msg);\n\n\tassert.directorySubDirs(path, array, ?msg);\n\tassert.notDirectorySubDirs(path, array, ?msg);\n\tassert.directoryDeepSubDirs(path, array, ?msg);\n\tassert.notDirectoryDeepSubDirs(path, array, ?msg);\n\tassert.directoryIncludeSubDirs(path, array, ?msg);\n\tassert.notDirectoryIncludeSubDirs(path, array, ?msg);\n\n* The paths of contents are relative to the starting directory\n* Only the top level sub-directories are included, unless `.deep` is in the chain\n* If `.include` or `.contain` is in the chain, then the directory must contain _at least_ the specified sub-directories, but may contain more\n* To negate this using `expect/should` you chain the `.not`-negation ***after*** the regular `directory()`.\n\n### directory().with.contents.that.satisfy(fn)\n\nYou can chain `.contents`, `.files`, and `.subDirs` with any Chai.js assertion that can operate on an array, including `.lengthOf()`, `.satisfy()`, `.members()`, etc.\n\n\texpect(path).to.be.a.directory().and.content.is.an('array');\n\n\texpect(path).to.be.a.directory().and.files.have.lengthOf(5);\n\n\tpath.should.be.a.directory().with.subDirs.that.include.members(['subDir1', 'subDir2']);\n\n\tpath.should.be.a.directory().with.files.that.satisfy(function(files) {\n\t  return files.every(function(file) {\n\t    return file.substr(-4) === '.txt';\n\t  });\n\t})\n\n* The paths of contents are relative to the directory\n* Only the top level contents are included, unless `.deep` is in the chain\n* You can use `.content()` or `.contents()`. They're both the same.\n* To negate this using `expect/should` you chain the `.not`-negation ***after*** the regular `directory()`.\n\n### directory().and.equal(otherPath)\n\nAssert that _both_ paths exist, are directories and contain the same contents (files, sub-directories, symlinks, etc).\n\n\texpect(path).to.be.a.directory(?msg).and.equal(otherPath, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.not.equal(otherPath, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.deep.equal(otherPath, ?msg);\n\texpect(path).to.be.a.directory(?msg).and.not.deep.equal(otherPath, ?msg);\n\n\tpath.should.be.a.directory(?msg).and.equal(otherPath, ?msg);\n\tpath.should.be.a.directory(?msg).and.not.equal(otherPath, ?msg);\n\tpath.should.be.a.directory(?msg).and.deep.equal(otherPath, ?msg);\n\tpath.should.be.a.directory(?msg).and.not.deep.equal(otherPath, ?msg);\n\n\tassert.directoryEqual(path, otherPath, ?msg);\n\tassert.notDirectoryEqual(path, otherPath, ?msg);\n\tassert.directoryDeepEqual(path, otherPath, ?msg);\n\tassert.notDirectoryDeepEqual(path, otherPath, ?msg);\n\n* Only the top level contents are compared, unless `.deep` is in the chain\n* To negate this using `expect/should` you chain the `.not`-negation ***after*** the regular `directory()`.\n\n### file()\n\nAssert the path exists and is a file.\n\nUses `fs.statSync().isFile()`\n\n\texpect(path).to.be.a.file(?msg);\n\texpect(path).to.not.be.a.file(?msg);\n\n\tpath.should.be.a.file(?msg);\n\tpath.should.not.be.a.file(?msg);\n\n\tassert.isFile(path, ?msg);\n\tassert.notIsFile(path, ?msg);\n\n### file().and.empty\n\nAssert the path exists, is a file and has zero size.\n\n\texpect(path).to.be.a.file(?msg).and.empty;\n\texpect(path).to.be.a.file(?msg).and.not.empty;\n\n\tpath.should.be.a.file(?msg).and.empty;\n\tpath.should.be.a.file(?msg).and.not.empty;\n\n\tassert.isEmptyFile(path, ?msg);\n\tassert.notIsEmptyFile(path, ?msg);\n\n* Chains after `file()`\n* Uses `fs.statSync().size === 0`.\n* To negate this using `expect/should` you chain the `.not`-negation ***after*** the regular `file()`.\n\n### file().with.content(str)\n\nAssert the path exists, is a file and has specific content.\n\n\texpect(path).to.be.a.file(?msg).with.content(data, ?msg);\n\texpect(path).to.be.a.file(?msg).and.not.have.content(data, ?msg);\n\n\tpath.should.be.a.file(?msg).with.content(data, ?msg);\n\tpath.should.be.a.file(?msg).and.not.have.content(data, ?msg);\n\n\tassert.fileContent(path, data, ?msg);\n\tassert.notFileContent(path, data, ?msg);\n\n* Reads file as utf8 text (could update to support base64, binary Buffer etc).\n* You can use `.content()` or `.contents()`. They're both the same.\n* To negate this using `expect/should` you chain the `.not`-negation ***after*** the regular `file()`.\n\n### file().with.contents.that.match(/xyz/)\n\nAssert the path exists, is a file and has contents that match the regular expression.\n\n\texpect(path).to.be.a.file(?msg).with.contents.that.match(/xyz/, ?msg);\n\texpect(path).to.be.a.file(?msg).and.not.have.contents.that.match(/xyz/, ?msg);\n\n\tpath.should.be.a.file(?msg).with.contents.that.match(/xyz/, ?msg);\n\tpath.should.be.a.file(?msg).and.not.have.contents.that.match(/xyz/, ?msg);\n\n\tassert.fileContentMatch(path, /xyz/, ?msg);\n\tassert.notFileContentMatch(path, /xyz/, ?msg);\n\n* Reads file as utf8 text (could update to support base64, binary Buffer etc).\n* You can use `.content` or `.contents`. They're both the same.\n* To negate this using `expect/should` you chain the `.not`-negation ***after*** the regular `file()`.\n\n### file().and.equal(otherPath)\n\nAssert that _both_ paths exist, are files and contain the same content\n\n\texpect(path).to.be.a.file(?msg).and.equal(otherPath, ?msg);\n\texpect(path).to.be.a.file(?msg).and.not.equal(otherPath, ?msg);\n\n\tpath.should.be.a.file(?msg).and.equal(otherPath, ?msg);\n\tpath.should.be.a.file(?msg).and.not.equal(otherPath, ?msg);\n\n\tassert.fileEqual(path, otherPath, ?msg);\n\tassert.notFileEqual(path, otherPath, ?msg);\n\n* Reads both files as utf8 text (could update to support base64, binary Buffer etc).\n* To negate this using `expect/should` you chain the `.not`-negation ***after*** the regular `file()`.\n\n### file().and.deep.equal(otherPath)\n\nAssert that _both_ paths exist, are files, contain the same content, and have the same attributes, including:\n\n * owner (`stats.uid`)\n * group (`stats.gid`)\n * creation time (`stats.birthtime`)\n * last-modified time (`stats.mtime`)\n * last-changed time (`stats.ctime`)\n\n\n\texpect(path).to.be.a.file(?msg).and.deep.equal(otherPath, ?msg);\n\texpect(path).to.be.a.file(?msg).and.not.deep.equal(otherPath, ?msg);\n\n\tpath.should.be.a.file(?msg).and.deep.equal(otherPath, ?msg);\n\tpath.should.be.a.file(?msg).and.not.deep.equal(otherPath, ?msg);\n\n\tassert.fileDeepEqual(path, otherPath, ?msg);\n\tassert.notFileDeepEqual(path, otherPath, ?msg);\n\n* Reads both files as utf8 text (could update to support base64, binary Buffer etc).\n* To negate this using `expect/should` you chain the `.not`-negation ***after*** the regular `file()`.\n* last-access time (`stats.atime`) is _not_ included in the comparison, since just reading this value (via `fs.stat()`) causes it to change on some operating systems, which could result in unstable tests\n\n### file().with.json\n\nAssert the path exists, is a file and contains json parsable text.\n\n\texpect(path).to.be.a.file(?msg).with.json;\n\texpect(path).to.be.a.file(?msg).with.not.json;\n\n\tpath.should.be.a.file(?msg).with.json;\n\tpath.should.be.a.file(?msg).with.not.json;\n\n\tassert.jsonFile(path, ?msg);\n\tassert.notJsonFile(path, ?msg);\n\n* Chains after `file()`\n* To negate this using `expect/should` you chain the `.not`-negation ***after*** the regular `file()`.\n* The `with` chain is just syntax sugar.\n\n### file().using.json.schema(obj)\n\nAssert the path exists, is a file, contains json parsable text conforming to given JSON-Schema.\n\n\texpect(path).to.be.a.file(?msg).with.json.using.schema(obj);\n\texpect(path).to.be.a.file(?msg).with.json.not.using.schema(obj);\n\n\tpath.should.be.a.file(?msg).with.json.using.schema(obj);\n\tpath.should.be.a.file(?msg).with.json.not.using.schema(obj);\n\n\tassert.jsonSchemaFile(path, schema,?msg);\n\tassert.notJsonSchemaFile(path, schema, ?msg);\n\n* Chains after `file().with.json`\n* The schema parameter must be a valid JSON-Schema v4.\n* Depends on the [chai-json-schema](https://github.com/chaijs/chai-json-schema) plugin to be separately activated with `chai.use()`.\n* To negate this using `expect/should` you chain the `.not`-negation ***after*** the regular `json`.\n* The `with` and `using` chains are just syntax sugar.\n\n###  Planned assertions\n\nThere are some ideas for future assertions saved [in this document](https://github.com/chaijs/chai-fs/tree/master/docs/planned.md).\n\n## History\n\n* 0.1.0 - Added content.match feature (thanks @legendary-mich)\n* 0.0.2 - Plugin release\n* 0.0.1 - Alpha release\n\n## Contributing\n\nContributions are welcome. Please follow the code, test and style patterns and keep JSHint happy. Please make sure things work on all platforms, or at least Widows/Mac/Linux.\n\n## Build & test\n\nInstall development dependencies in your git checkout:\n\n    $ npm install\n\nYou need the global [grunt](http://gruntjs.com) command:\n\n    $ npm install grunt-cli -g\n\nBuild and run tests:\n\n    $ grunt\n\nSee the `Gruntfile` for additional commands.\n\n### :wrench: Test generator\n\nThis plugin uses a prototype of an \"assertion plugin test generator\" to generates tests for all aspects of the assertions while keeping the specs DRY.\n\nThe pattern splits the test into a style declaration tree and a set of variation on 3 types of test scenarios. The generator then combines ('multiplies') every scenario variation with the style tree data to get good coverage of all cases.\n\nThe style tree defines ways to use an assertion: first level is the style: expect/should and assert. Then it defines both the normal use and the negation, then divides those into different invocations patterns for each style. So you can test with/without message, or as a chained method or property etc.\n\nThe tests are ways to specify assertions and the test expectations.\n\n* `valid`  - test expected to pass (but fail the negation)\n* `invalid` - test expected to fail (but pass the negation).\n* `error` - test expected to always fail (even when negated), because the data is invalid (eg: bad data type, missing parameters etc).\n\nThe report field is used the verify the error message if the test fails. It supports a simple template format using the assertion data object.\n\n#### Why?\n\nThis looks a bit complex and cumbersome but it does allow to quickly add large amount of detailed tests for all assertions. So far it seems to work empowering so I might extract this to a separate npm module later.\n\nNote it will generate a large amount of case variations so a small error in the code or your test setup can explode the suite wit a many failing assertions. Look closely at which tests are failing to see what is causing what.\n\n## License\n\nCopyright (c) 2013 Bart van der Schoor\n\nLicensed under the MIT license.\n","maintainers":[{"name":"chaijs","email":"chaijs@keithcirkel.co.uk"}],"time":{"modified":"2017-11-06T14:40:37.446Z","created":"2013-08-10T13:32:27.262Z","0.0.1":"2013-08-10T13:32:31.678Z","0.0.2":"2013-08-28T14:19:08.153Z","0.0.3":"2013-08-28T14:27:29.801Z","0.1.0":"2014-07-22T18:26:36.252Z","1.0.0":"2016-10-27T14:06:19.615Z","2.0.0":"2017-11-06T14:40:37.446Z"},"author":{"name":"Bart van der Schoor","url":"https://github.com/Bartvds"},"repository":{"type":"git","url":"git+https://github.com/chaijs/chai-fs.git"},"homepage":"https://github.com/chaijs/chai-fs#readme","keywords":["chai","chai-plugin","vendor","fs","test","assertion","assert","testing","file","path","filesystem"],"bugs":{"url":"https://github.com/chaijs/chai-fs/issues"},"readmeFilename":"README.md","users":{"prometheas":true},"_attachments":{}}