[
  {
    "tags": [],
    "description": {
      "full": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 5,
    "codeStart": 11,
    "code": "var used = [];",
    "ctx": {
      "type": "declaration",
      "name": "used",
      "value": "[]",
      "string": "used"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai version",
      "summary": "Chai version",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 13,
    "codeStart": 17,
    "code": "exports.version = '4.1.2';",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "version",
      "value": "'4.1.2'",
      "string": "exports.version"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Assertion Error",
      "summary": "Assertion Error",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 19,
    "codeStart": 23,
    "code": "exports.AssertionError = require('assertion-error');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "AssertionError",
      "value": "require('assertion-error')",
      "string": "exports.AssertionError"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Utils for plugins (not exported)",
      "summary": "Utils for plugins (not exported)",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 25,
    "codeStart": 29,
    "code": "var util = require('./chai/utils');",
    "ctx": {
      "type": "declaration",
      "name": "util",
      "value": "require('./chai/utils')",
      "string": "util"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Function}",
        "name": "",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{this} for chaining",
        "types": [
          "this"
        ],
        "typesDescription": "<a href=\"this.html\">this</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "for chaining"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "# .use(function)\n\nProvides a way to extend the internals of Chai.",
      "summary": "# .use(function)",
      "body": "Provides a way to extend the internals of Chai."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 31,
    "codeStart": 41,
    "code": "exports.use = function (fn) {\n  if (!~used.indexOf(fn)) {\n    fn(exports, util);\n    used.push(fn);\n  }\n\n  return exports;\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "use",
      "string": "exports.use()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Utility Functions",
      "summary": "Utility Functions",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 50,
    "codeStart": 54,
    "code": "exports.util = util;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "util",
      "value": "util",
      "string": "exports.util"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Configuration",
      "summary": "Configuration",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 56,
    "codeStart": 60,
    "code": "var config = require('./chai/config');\nexports.config = config;",
    "ctx": {
      "type": "declaration",
      "name": "config",
      "value": "require('./chai/config')",
      "string": "config"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Primary `Assertion` prototype",
      "summary": "Primary `Assertion` prototype",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 63,
    "codeStart": 67,
    "code": "var assertion = require('./chai/assertion');\nexports.use(assertion);",
    "ctx": {
      "type": "declaration",
      "name": "assertion",
      "value": "require('./chai/assertion')",
      "string": "assertion"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Core Assertions",
      "summary": "Core Assertions",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 70,
    "codeStart": 74,
    "code": "var core = require('./chai/core/assertions');\nexports.use(core);",
    "ctx": {
      "type": "declaration",
      "name": "core",
      "value": "require('./chai/core/assertions')",
      "string": "core"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Expect interface",
      "summary": "Expect interface",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 77,
    "codeStart": 81,
    "code": "var expect = require('./chai/interface/expect');\nexports.use(expect);",
    "ctx": {
      "type": "declaration",
      "name": "expect",
      "value": "require('./chai/interface/expect')",
      "string": "expect"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Should interface",
      "summary": "Should interface",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 84,
    "codeStart": 88,
    "code": "var should = require('./chai/interface/should');\nexports.use(should);",
    "ctx": {
      "type": "declaration",
      "name": "should",
      "value": "require('./chai/interface/should')",
      "string": "should"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Assert interface",
      "summary": "Assert interface",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 91,
    "codeStart": 95,
    "code": "var assert = require('./chai/interface/assert');\nexports.use(assert);\n\n},{\"./chai/assertion\":3,\"./chai/config\":4,\"./chai/core/assertions\":5,\"./chai/interface/assert\":6,\"./chai/interface/expect\":7,\"./chai/interface/should\":8,\"./chai/utils\":22,\"assertion-error\":33}],3:[function(require,module,exports){",
    "ctx": {
      "type": "declaration",
      "name": "assert",
      "value": "require('./chai/interface/assert')",
      "string": "assert"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "chai\nhttp://chaijs.com\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "chai\nhttp://chaijs.com\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 99,
    "codeStart": 106,
    "code": "var config = require('./config');\n\nmodule.exports = function (_chai, util) {",
    "ctx": {
      "type": "declaration",
      "name": "config",
      "value": "require('./config')",
      "string": "config"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Module dependencies.",
      "summary": "Module dependencies.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 109,
    "codeStart": 113,
    "code": "var AssertionError = _chai.AssertionError\n  , flag = util.flag;",
    "ctx": {
      "type": "declaration",
      "name": "AssertionError",
      "value": "_chai.AssertionError",
      "string": "AssertionError"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Module export.",
      "summary": "Module export.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 116,
    "codeStart": 120,
    "code": "_chai.Assertion = Assertion;",
    "ctx": {
      "type": "property",
      "receiver": "_chai",
      "name": "Assertion",
      "value": "Assertion",
      "string": "_chai.Assertion"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} obj target of the assertion",
        "name": "obj",
        "description": "target of the assertion",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg (optional) custom error message",
        "name": "msg",
        "description": "(optional) custom error message",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} ssfi (optional) starting point for removing stack frames",
        "name": "ssfi",
        "description": "(optional) starting point for removing stack frames",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Boolean} lockSsfi (optional) whether or not the ssfi flag is locked",
        "name": "lockSsfi",
        "description": "(optional) whether or not the ssfi flag is locked",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "Assertion Constructor\n\nCreates object for chaining.\n\n`Assertion` objects contain metadata in the form of flags. Three flags can\nbe assigned during instantiation by passing arguments to this constructor:\n\n- `object`: This flag contains the target of the assertion. For example, in\n  the assertion `expect(numKittens).to.equal(7);`, the `object` flag will\n  contain `numKittens` so that the `equal` assertion can reference it when\n  needed.\n\n- `message`: This flag contains an optional custom error message to be\n  prepended to the error message that's generated by the assertion when it\n  fails.\n\n- `ssfi`: This flag stands for \"start stack function indicator\". It\n  contains a function reference that serves as the starting point for\n  removing frames from the stack trace of the error that's created by the\n  assertion when it fails. The goal is to provide a cleaner stack trace to\n  end users by removing Chai's internal functions. Note that it only works\n  in environments that support `Error.captureStackTrace`, and only when\n  `Chai.config.includeStack` hasn't been set to `false`.\n\n- `lockSsfi`: This flag controls whether or not the given `ssfi` flag\n  should retain its current value, even as assertions are chained off of\n  this object. This is usually set to `true` when creating a new assertion\n  from within another assertion. It's also temporarily set to `true` before\n  an overwritten assertion gets called by the overwriting assertion.",
      "summary": "Assertion Constructor",
      "body": "Creates object for chaining.\n\n`Assertion` objects contain metadata in the form of flags. Three flags can\nbe assigned during instantiation by passing arguments to this constructor:\n\n- `object`: This flag contains the target of the assertion. For example, in\n  the assertion `expect(numKittens).to.equal(7);`, the `object` flag will\n  contain `numKittens` so that the `equal` assertion can reference it when\n  needed.\n\n- `message`: This flag contains an optional custom error message to be\n  prepended to the error message that's generated by the assertion when it\n  fails.\n\n- `ssfi`: This flag stands for \"start stack function indicator\". It\n  contains a function reference that serves as the starting point for\n  removing frames from the stack trace of the error that's created by the\n  assertion when it fails. The goal is to provide a cleaner stack trace to\n  end users by removing Chai's internal functions. Note that it only works\n  in environments that support `Error.captureStackTrace`, and only when\n  `Chai.config.includeStack` hasn't been set to `false`.\n\n- `lockSsfi`: This flag controls whether or not the given `ssfi` flag\n  should retain its current value, even as assertions are chained off of\n  this object. This is usually set to `true` when creating a new assertion\n  from within another assertion. It's also temporarily set to `true` before\n  an overwritten assertion gets called by the overwriting assertion."
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 122,
    "codeStart": 160,
    "code": "function Assertion (obj, msg, ssfi, lockSsfi) {\n  flag(this, 'ssfi', ssfi || Assertion);\n  flag(this, 'lockSsfi', lockSsfi);\n  flag(this, 'object', obj);\n  flag(this, 'message', msg);\n\n  return util.proxify(this);\n}\n\nObject.defineProperty(Assertion, 'includeStack', {\n  get: function() {\n    console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n    return config.includeStack;\n  },\n  set: function(value) {\n    console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n    config.includeStack = value;\n  }\n});\n\nObject.defineProperty(Assertion, 'showDiff', {\n  get: function() {\n    console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n    return config.showDiff;\n  },\n  set: function(value) {\n    console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n    config.showDiff = value;\n  }\n});\n\nAssertion.addProperty = function (name, fn) {\n  util.addProperty(this.prototype, name, fn);\n};\n\nAssertion.addMethod = function (name, fn) {\n  util.addMethod(this.prototype, name, fn);\n};\n\nAssertion.addChainableMethod = function (name, fn, chainingBehavior) {\n  util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\n};\n\nAssertion.overwriteProperty = function (name, fn) {\n  util.overwriteProperty(this.prototype, name, fn);\n};\n\nAssertion.overwriteMethod = function (name, fn) {\n  util.overwriteMethod(this.prototype, name, fn);\n};\n\nAssertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {\n  util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);\n};",
    "ctx": {
      "type": "function",
      "name": "Assertion",
      "string": "Assertion()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "assert"
      },
      {
        "type": "param",
        "string": "{Philosophical} expression to be tested",
        "name": "expression",
        "description": "to be tested",
        "types": [
          "Philosophical"
        ],
        "typesDescription": "<a href=\"Philosophical.html\">Philosophical</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String|Function} message or function that returns message to display if expression fails",
        "name": "message",
        "description": "or function that returns message to display if expression fails",
        "types": [
          "String",
          "Function"
        ],
        "typesDescription": "<code>String</code>|<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails",
        "name": "negatedMessage",
        "description": "or function that returns negatedMessage to display if negated expression fails",
        "types": [
          "String",
          "Function"
        ],
        "typesDescription": "<code>String</code>|<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected value (remember to check for negation)",
        "name": "expected",
        "description": "value (remember to check for negation)",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} actual (optional) will default to `this.obj`",
        "name": "actual",
        "description": "(optional) will default to `this.obj`",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails",
        "name": "showDiff",
        "description": "(optional) when set to `true`, assert will display a diff in addition to the message if expression fails",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "### .assert(expression, message, negateMessage, expected, actual, showDiff)\n\nExecutes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.",
      "summary": "### .assert(expression, message, negateMessage, expected, actual, showDiff)",
      "body": "Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass."
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 215,
    "codeStart": 230,
    "code": "Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\n  var ok = util.test(this, arguments);\n  if (false !== showDiff) showDiff = true;\n  if (undefined === expected && undefined === _actual) showDiff = false;\n  if (true !== config.showDiff) showDiff = false;\n\n  if (!ok) {\n    msg = util.getMessage(this, arguments);\n    var actual = util.getActual(this, arguments);\n    throw new AssertionError(msg, {\n        actual: actual\n      , expected: expected\n      , showDiff: showDiff\n    }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Assertion",
      "cons": "Assertion",
      "name": "assert",
      "string": "Assertion.prototype.assert()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "### ._obj\n\nQuick reference to stored `actual` value for plugin developers.",
      "summary": "### ._obj",
      "body": "Quick reference to stored `actual` value for plugin developers."
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 247,
    "codeStart": 255,
    "code": "Object.defineProperty(Assertion.prototype, '_obj',\n  { get: function () {\n      return flag(this, 'object');\n    }\n  , set: function (val) {\n      flag(this, 'object', val);\n    }\n});\n};\n\n},{\"./config\":4}],4:[function(require,module,exports){\nmodule.exports = {",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Boolean}",
        "name": "",
        "description": "",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### config.includeStack\n\nUser configurable property, influences whether stack trace\nis included in Assertion error message. Default of false\nsuppresses stack trace in the error message.\n\n    chai.config.includeStack = true;  // enable stack on error",
      "summary": "### config.includeStack",
      "body": "User configurable property, influences whether stack trace\nis included in Assertion error message. Default of false\nsuppresses stack trace in the error message.\n\n    chai.config.includeStack = true;  // enable stack on error"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 268,
    "codeStart": 281,
    "code": "includeStack: false,",
    "ctx": {
      "type": "property",
      "name": "includeStack",
      "value": "false,",
      "string": "includeStack"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Boolean}",
        "name": "",
        "description": "",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### config.showDiff\n\nUser configurable property, influences whether or not\nthe `showDiff` flag should be included in the thrown\nAssertionErrors. `false` will always be `false`; `true`\nwill be true when the assertion has requested a diff\nbe shown.",
      "summary": "### config.showDiff",
      "body": "User configurable property, influences whether or not\nthe `showDiff` flag should be included in the thrown\nAssertionErrors. `false` will always be `false`; `true`\nwill be true when the assertion has requested a diff\nbe shown."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 283,
    "codeStart": 296,
    "code": "showDiff: true,",
    "ctx": {
      "type": "property",
      "name": "showDiff",
      "value": "true,",
      "string": "showDiff"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Number}",
        "name": "",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### config.truncateThreshold\n\nUser configurable property, sets length threshold for actual and\nexpected values in assertion errors. If this threshold is exceeded, for\nexample for large data structures, the value is replaced with something\nlike `[ Array(3) ]` or `{ Object (prop1, prop2) }`.\n\nSet it to zero if you want to disable truncating altogether.\n\nThis is especially userful when doing assertions on arrays: having this\nset to a reasonable large value makes the failure messages readily\ninspectable.\n\n    chai.config.truncateThreshold = 0;  // disable truncating",
      "summary": "### config.truncateThreshold",
      "body": "User configurable property, sets length threshold for actual and\nexpected values in assertion errors. If this threshold is exceeded, for\nexample for large data structures, the value is replaced with something\nlike `[ Array(3) ]` or `{ Object (prop1, prop2) }`.\n\nSet it to zero if you want to disable truncating altogether.\n\nThis is especially userful when doing assertions on arrays: having this\nset to a reasonable large value makes the failure messages readily\ninspectable.\n\n    chai.config.truncateThreshold = 0;  // disable truncating"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 298,
    "codeStart": 318,
    "code": "truncateThreshold: 40,",
    "ctx": {
      "type": "property",
      "name": "truncateThreshold",
      "value": "40,",
      "string": "truncateThreshold"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Boolean}",
        "name": "",
        "description": "",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### config.useProxy\n\nUser configurable property, defines if chai will use a Proxy to throw\nan error when a non-existent property is read, which protects users\nfrom typos when using property-based assertions.\n\nSet it to false if you want to disable this feature.\n\n    chai.config.useProxy = false;  // disable use of Proxy\n\nThis feature is automatically disabled regardless of this config value\nin environments that don't support proxies.",
      "summary": "### config.useProxy",
      "body": "User configurable property, defines if chai will use a Proxy to throw\nan error when a non-existent property is read, which protects users\nfrom typos when using property-based assertions.\n\nSet it to false if you want to disable this feature.\n\n    chai.config.useProxy = false;  // disable use of Proxy\n\nThis feature is automatically disabled regardless of this config value\nin environments that don't support proxies."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 320,
    "codeStart": 338,
    "code": "useProxy: true,",
    "ctx": {
      "type": "property",
      "name": "useProxy",
      "value": "true,",
      "string": "useProxy"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Array}",
        "name": "",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### config.proxyExcludedKeys\n\nUser configurable property, defines which properties should be ignored\ninstead of throwing an error if they do not exist on the assertion.\nThis is only applied if the environment Chai is running in supports proxies and\nif the `useProxy` configuration setting is enabled.\nBy default, `then` and `inspect` will not throw an error if they do not exist on the\nassertion object because the `.inspect` property is read by `util.inspect` (for example, when\nusing `console.log` on the assertion object) and `.then` is necessary for promise type-checking.\n\n    // By default these keys will not throw an error if they do not exist on the assertion object\n    chai.config.proxyExcludedKeys = ['then', 'inspect'];",
      "summary": "### config.proxyExcludedKeys",
      "body": "User configurable property, defines which properties should be ignored\ninstead of throwing an error if they do not exist on the assertion.\nThis is only applied if the environment Chai is running in supports proxies and\nif the `useProxy` configuration setting is enabled.\nBy default, `then` and `inspect` will not throw an error if they do not exist on the\nassertion object because the `.inspect` property is read by `util.inspect` (for example, when\nusing `console.log` on the assertion object) and `.then` is necessary for promise type-checking.\n\n    // By default these keys will not throw an error if they do not exist on the assertion object\n    chai.config.proxyExcludedKeys = ['then', 'inspect'];"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 340,
    "codeStart": 358,
    "code": "proxyExcludedKeys: ['then', 'inspect', 'toJSON']\n};\n\n},{}],5:[function(require,module,exports){",
    "ctx": {
      "type": "property",
      "name": "proxyExcludedKeys",
      "value": "['then', 'inspect', 'toJSON']",
      "string": "proxyExcludedKeys"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "chai\nhttp://chaijs.com\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "chai\nhttp://chaijs.com\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 362,
    "codeStart": 369,
    "code": "module.exports = function (chai, _) {\n  var Assertion = chai.Assertion\n    , AssertionError = chai.AssertionError\n    , flag = _.flag;",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "language chains"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### Language Chains\n\nThe following are provided as chainable getters to improve the readability\nof your assertions.\n\n**Chains**\n\n- to\n- be\n- been\n- is\n- that\n- which\n- and\n- has\n- have\n- with\n- at\n- of\n- same\n- but\n- does",
      "summary": "### Language Chains",
      "body": "The following are provided as chainable getters to improve the readability\nof your assertions.\n\n**Chains**\n\n- to\n- be\n- been\n- is\n- that\n- which\n- and\n- has\n- have\n- with\n- at\n- of\n- same\n- but\n- does"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 374,
    "codeStart": 403,
    "code": "[ 'to', 'be', 'been'\n, 'is', 'and', 'has', 'have'\n, 'with', 'that', 'which', 'at'\n, 'of', 'same', 'but', 'does' ].forEach(function (chain) {\n  Assertion.addProperty(chain);\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "not"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .not\n\nNegates all assertions that follow in the chain.\n\n    expect(function () {}).to.not.throw();\n    expect({a: 1}).to.not.have.property('b');\n    expect([1, 2]).to.be.an('array').that.does.not.include(3);\n\nJust because you can negate any assertion with `.not` doesn't mean you\nshould. With great power comes great responsibility. It's often best to\nassert that the one expected output was produced, rather than asserting\nthat one of countless unexpected outputs wasn't produced. See individual\nassertions for specific guidance.\n\n    expect(2).to.equal(2); // Recommended\n    expect(2).to.not.equal(1); // Not recommended",
      "summary": "### .not",
      "body": "Negates all assertions that follow in the chain.\n\n    expect(function () {}).to.not.throw();\n    expect({a: 1}).to.not.have.property('b');\n    expect([1, 2]).to.be.an('array').that.does.not.include(3);\n\nJust because you can negate any assertion with `.not` doesn't mean you\nshould. With great power comes great responsibility. It's often best to\nassert that the one expected output was produced, rather than asserting\nthat one of countless unexpected outputs wasn't produced. See individual\nassertions for specific guidance.\n\n    expect(2).to.equal(2); // Recommended\n    expect(2).to.not.equal(1); // Not recommended"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 410,
    "codeStart": 433,
    "code": "Assertion.addProperty('not', function () {\n  flag(this, 'negate', true);\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "deep"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .deep\n\nCauses all `.equal`, `.include`, `.members`, `.keys`, and `.property`\nassertions that follow in the chain to use deep equality instead of strict\n(`===`) equality. See the `deep-eql` project page for info on the deep\nequality algorithm: https://github.com/chaijs/deep-eql.\n\n    // Target object deeply (but not strictly) equals `{a: 1}`\n    expect({a: 1}).to.deep.equal({a: 1});\n    expect({a: 1}).to.not.equal({a: 1});\n\n    // Target array deeply (but not strictly) includes `{a: 1}`\n    expect([{a: 1}]).to.deep.include({a: 1});\n    expect([{a: 1}]).to.not.include({a: 1});\n\n    // Target object deeply (but not strictly) includes `x: {a: 1}`\n    expect({x: {a: 1}}).to.deep.include({x: {a: 1}});\n    expect({x: {a: 1}}).to.not.include({x: {a: 1}});\n\n    // Target array deeply (but not strictly) has member `{a: 1}`\n    expect([{a: 1}]).to.have.deep.members([{a: 1}]);\n    expect([{a: 1}]).to.not.have.members([{a: 1}]);\n\n    // Target set deeply (but not strictly) has key `{a: 1}`\n    expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);\n    expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);\n\n    // Target object deeply (but not strictly) has property `x: {a: 1}`\n    expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});\n    expect({x: {a: 1}}).to.not.have.property('x', {a: 1});",
      "summary": "### .deep",
      "body": "Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`\nassertions that follow in the chain to use deep equality instead of strict\n(`===`) equality. See the `deep-eql` project page for info on the deep\nequality algorithm: https://github.com/chaijs/deep-eql.\n\n    // Target object deeply (but not strictly) equals `{a: 1}`\n    expect({a: 1}).to.deep.equal({a: 1});\n    expect({a: 1}).to.not.equal({a: 1});\n\n    // Target array deeply (but not strictly) includes `{a: 1}`\n    expect([{a: 1}]).to.deep.include({a: 1});\n    expect([{a: 1}]).to.not.include({a: 1});\n\n    // Target object deeply (but not strictly) includes `x: {a: 1}`\n    expect({x: {a: 1}}).to.deep.include({x: {a: 1}});\n    expect({x: {a: 1}}).to.not.include({x: {a: 1}});\n\n    // Target array deeply (but not strictly) has member `{a: 1}`\n    expect([{a: 1}]).to.have.deep.members([{a: 1}]);\n    expect([{a: 1}]).to.not.have.members([{a: 1}]);\n\n    // Target set deeply (but not strictly) has key `{a: 1}`\n    expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);\n    expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);\n\n    // Target object deeply (but not strictly) has property `x: {a: 1}`\n    expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});\n    expect({x: {a: 1}}).to.not.have.property('x', {a: 1});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 437,
    "codeStart": 474,
    "code": "Assertion.addProperty('deep', function () {\n  flag(this, 'deep', true);\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "nested"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .nested\n\nEnables dot- and bracket-notation in all `.property` and `.include`\nassertions that follow in the chain.\n\n    expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');\n    expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});\n\nIf `.` or `[]` are part of an actual property name, they can be escaped by\nadding two backslashes before them.\n\n    expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');\n    expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 'x'});\n\n`.nested` cannot be combined with `.own`.",
      "summary": "### .nested",
      "body": "Enables dot- and bracket-notation in all `.property` and `.include`\nassertions that follow in the chain.\n\n    expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');\n    expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});\n\nIf `.` or `[]` are part of an actual property name, they can be escaped by\nadding two backslashes before them.\n\n    expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');\n    expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 'x'});\n\n`.nested` cannot be combined with `.own`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 478,
    "codeStart": 500,
    "code": "Assertion.addProperty('nested', function () {\n  flag(this, 'nested', true);\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "own"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .own\n\nCauses all `.property` and `.include` assertions that follow in the chain\nto ignore inherited properties.\n\n    Object.prototype.b = 2;\n\n    expect({a: 1}).to.have.own.property('a');\n    expect({a: 1}).to.have.property('b').but.not.own.property('b'); \n\n    expect({a: 1}).to.own.include({a: 1});\n    expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});\n\n`.own` cannot be combined with `.nested`.",
      "summary": "### .own",
      "body": "Causes all `.property` and `.include` assertions that follow in the chain\nto ignore inherited properties.\n\n    Object.prototype.b = 2;\n\n    expect({a: 1}).to.have.own.property('a');\n    expect({a: 1}).to.have.property('b').but.not.own.property('b'); \n\n    expect({a: 1}).to.own.include({a: 1});\n    expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});\n\n`.own` cannot be combined with `.nested`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 504,
    "codeStart": 525,
    "code": "Assertion.addProperty('own', function () {\n  flag(this, 'own', true);\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "ordered"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .ordered\n\nCauses all `.members` assertions that follow in the chain to require that\nmembers be in the same order.\n\n    expect([1, 2]).to.have.ordered.members([1, 2])\n      .but.not.have.ordered.members([2, 1]);\n\nWhen `.include` and `.ordered` are combined, the ordering begins at the\nstart of both arrays.\n\n    expect([1, 2, 3]).to.include.ordered.members([1, 2])\n      .but.not.include.ordered.members([2, 3]);",
      "summary": "### .ordered",
      "body": "Causes all `.members` assertions that follow in the chain to require that\nmembers be in the same order.\n\n    expect([1, 2]).to.have.ordered.members([1, 2])\n      .but.not.have.ordered.members([2, 1]);\n\nWhen `.include` and `.ordered` are combined, the ordering begins at the\nstart of both arrays.\n\n    expect([1, 2, 3]).to.include.ordered.members([1, 2])\n      .but.not.include.ordered.members([2, 3]);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 529,
    "codeStart": 549,
    "code": "Assertion.addProperty('ordered', function () {\n  flag(this, 'ordered', true);\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "any"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .any\n\nCauses all `.keys` assertions that follow in the chain to only require that\nthe target have at least one of the given keys. This is the opposite of\n`.all`, which requires that the target have all of the given keys.\n\n    expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');\n\nSee the `.keys` doc for guidance on when to use `.any` or `.all`.",
      "summary": "### .any",
      "body": "Causes all `.keys` assertions that follow in the chain to only require that\nthe target have at least one of the given keys. This is the opposite of\n`.all`, which requires that the target have all of the given keys.\n\n    expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');\n\nSee the `.keys` doc for guidance on when to use `.any` or `.all`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 553,
    "codeStart": 569,
    "code": "Assertion.addProperty('any', function () {\n  flag(this, 'any', true);\n  flag(this, 'all', false);\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "all"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .all\n\nCauses all `.keys` assertions that follow in the chain to require that the\ntarget have all of the given keys. This is the opposite of `.any`, which\nonly requires that the target have at least one of the given keys.\n\n    expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n\nNote that `.all` is used by default when neither `.all` nor `.any` are\nadded earlier in the chain. However, it's often best to add `.all` anyway\nbecause it improves readability.\n\nSee the `.keys` doc for guidance on when to use `.any` or `.all`.",
      "summary": "### .all",
      "body": "Causes all `.keys` assertions that follow in the chain to require that the\ntarget have all of the given keys. This is the opposite of `.any`, which\nonly requires that the target have at least one of the given keys.\n\n    expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n\nNote that `.all` is used by default when neither `.all` nor `.any` are\nadded earlier in the chain. However, it's often best to add `.all` anyway\nbecause it improves readability.\n\nSee the `.keys` doc for guidance on when to use `.any` or `.all`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 575,
    "codeStart": 595,
    "code": "Assertion.addProperty('all', function () {\n  flag(this, 'all', true);\n  flag(this, 'any', false);\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "a"
      },
      {
        "type": "alias",
        "string": "an"
      },
      {
        "type": "param",
        "string": "{String} type",
        "name": "type",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .a(type[, msg])\n\nAsserts that the target's type is equal to the given string `type`. Types\nare case insensitive. See the `type-detect` project page for info on the\ntype detection algorithm: https://github.com/chaijs/type-detect.\n\n    expect('foo').to.be.a('string');\n    expect({a: 1}).to.be.an('object');\n    expect(null).to.be.a('null');\n    expect(undefined).to.be.an('undefined');\n    expect(new Error).to.be.an('error');\n    expect(Promise.resolve()).to.be.a('promise');\n    expect(new Float32Array).to.be.a('float32array');\n    expect(Symbol()).to.be.a('symbol');\n\n`.a` supports objects that have a custom type set via `Symbol.toStringTag`.\n\n    var myObj = {\n      [Symbol.toStringTag]: 'myCustomType'\n    };\n\n    expect(myObj).to.be.a('myCustomType').but.not.an('object');\n\nIt's often best to use `.a` to check a target's type before making more\nassertions on the same target. That way, you avoid unexpected behavior from\nany assertion that does different things based on the target's type.\n\n    expect([1, 2, 3]).to.be.an('array').that.includes(2);\n    expect([]).to.be.an('array').that.is.empty;\n\nAdd `.not` earlier in the chain to negate `.a`. However, it's often best to\nassert that the target is the expected type, rather than asserting that it\nisn't one of many unexpected types.\n\n    expect('foo').to.be.a('string'); // Recommended\n    expect('foo').to.not.be.an('array'); // Not recommended\n\n`.a` accepts an optional `msg` argument which is a custom error message to\nshow when the assertion fails. The message can also be given as the second\nargument to `expect`.\n\n    expect(1).to.be.a('string', 'nooo why fail??');\n    expect(1, 'nooo why fail??').to.be.a('string');\n\n`.a` can also be used as a language chain to improve the readability of\nyour assertions. \n\n    expect({b: 2}).to.have.a.property('b');\n\nThe alias `.an` can be used interchangeably with `.a`.",
      "summary": "### .a(type[, msg])",
      "body": "Asserts that the target's type is equal to the given string `type`. Types\nare case insensitive. See the `type-detect` project page for info on the\ntype detection algorithm: https://github.com/chaijs/type-detect.\n\n    expect('foo').to.be.a('string');\n    expect({a: 1}).to.be.an('object');\n    expect(null).to.be.a('null');\n    expect(undefined).to.be.an('undefined');\n    expect(new Error).to.be.an('error');\n    expect(Promise.resolve()).to.be.a('promise');\n    expect(new Float32Array).to.be.a('float32array');\n    expect(Symbol()).to.be.a('symbol');\n\n`.a` supports objects that have a custom type set via `Symbol.toStringTag`.\n\n    var myObj = {\n      [Symbol.toStringTag]: 'myCustomType'\n    };\n\n    expect(myObj).to.be.a('myCustomType').but.not.an('object');\n\nIt's often best to use `.a` to check a target's type before making more\nassertions on the same target. That way, you avoid unexpected behavior from\nany assertion that does different things based on the target's type.\n\n    expect([1, 2, 3]).to.be.an('array').that.includes(2);\n    expect([]).to.be.an('array').that.is.empty;\n\nAdd `.not` earlier in the chain to negate `.a`. However, it's often best to\nassert that the target is the expected type, rather than asserting that it\nisn't one of many unexpected types.\n\n    expect('foo').to.be.a('string'); // Recommended\n    expect('foo').to.not.be.an('array'); // Not recommended\n\n`.a` accepts an optional `msg` argument which is a custom error message to\nshow when the assertion fails. The message can also be given as the second\nargument to `expect`.\n\n    expect(1).to.be.a('string', 'nooo why fail??');\n    expect(1, 'nooo why fail??').to.be.a('string');\n\n`.a` can also be used as a language chain to improve the readability of\nyour assertions. \n\n    expect({b: 2}).to.have.a.property('b');\n\nThe alias `.an` can be used interchangeably with `.a`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 600,
    "codeStart": 660,
    "code": "function an (type, msg) {\n  if (msg) flag(this, 'message', msg);\n  type = type.toLowerCase();\n  var obj = flag(this, 'object')\n    , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';\n\n  this.assert(\n      type === _.type(obj).toLowerCase()\n    , 'expected #{this} to be ' + article + type\n    , 'expected #{this} not to be ' + article + type\n  );\n}\n\nAssertion.addChainableMethod('an', an);\nAssertion.addChainableMethod('a', an);",
    "ctx": {
      "type": "function",
      "name": "an",
      "string": "an()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "include"
      },
      {
        "type": "alias",
        "string": "contain"
      },
      {
        "type": "alias",
        "string": "includes"
      },
      {
        "type": "alias",
        "string": "contains"
      },
      {
        "type": "param",
        "string": "{Mixed} val",
        "name": "val",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .include(val[, msg])\n\nWhen the target is a string, `.include` asserts that the given string `val`\nis a substring of the target.\n\n    expect('foobar').to.include('foo');\n\nWhen the target is an array, `.include` asserts that the given `val` is a\nmember of the target.\n\n    expect([1, 2, 3]).to.include(2);\n\nWhen the target is an object, `.include` asserts that the given object\n`val`'s properties are a subset of the target's properties.\n\n    expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});\n\nWhen the target is a Set or WeakSet, `.include` asserts that the given `val` is a\nmember of the target. SameValueZero equality algorithm is used.\n\n    expect(new Set([1, 2])).to.include(2);\n\nWhen the target is a Map, `.include` asserts that the given `val` is one of\nthe values of the target. SameValueZero equality algorithm is used.\n\n    expect(new Map([['a', 1], ['b', 2]])).to.include(2);\n\nBecause `.include` does different things based on the target's type, it's\nimportant to check the target's type before using `.include`. See the `.a`\ndoc for info on testing a target's type.\n\n    expect([1, 2, 3]).to.be.an('array').that.includes(2);\n\nBy default, strict (`===`) equality is used to compare array members and\nobject properties. Add `.deep` earlier in the chain to use deep equality\ninstead (WeakSet targets are not supported). See the `deep-eql` project\npage for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n\n    // Target array deeply (but not strictly) includes `{a: 1}`\n    expect([{a: 1}]).to.deep.include({a: 1});\n    expect([{a: 1}]).to.not.include({a: 1});\n\n    // Target object deeply (but not strictly) includes `x: {a: 1}`\n    expect({x: {a: 1}}).to.deep.include({x: {a: 1}});\n    expect({x: {a: 1}}).to.not.include({x: {a: 1}});\n\nBy default, all of the target's properties are searched when working with\nobjects. This includes properties that are inherited and/or non-enumerable.\nAdd `.own` earlier in the chain to exclude the target's inherited\nproperties from the search.\n\n    Object.prototype.b = 2;\n\n    expect({a: 1}).to.own.include({a: 1});\n    expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});\n\nNote that a target object is always only searched for `val`'s own\nenumerable properties.\n\n`.deep` and `.own` can be combined.\n\n    expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});\n\nAdd `.nested` earlier in the chain to enable dot- and bracket-notation when\nreferencing nested properties.\n\n    expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});\n\nIf `.` or `[]` are part of an actual property name, they can be escaped by\nadding two backslashes before them.\n\n    expect({'.a': {'[b]': 2}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 2});\n\n`.deep` and `.nested` can be combined.\n\n    expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});\n\n`.own` and `.nested` cannot be combined.\n\nAdd `.not` earlier in the chain to negate `.include`.\n\n    expect('foobar').to.not.include('taco');\n    expect([1, 2, 3]).to.not.include(4);\n\nHowever, it's dangerous to negate `.include` when the target is an object.\nThe problem is that it creates uncertain expectations by asserting that the\ntarget object doesn't have all of `val`'s key/value pairs but may or may\nnot have some of them. It's often best to identify the exact output that's\nexpected, and then write an assertion that only accepts that exact output.\n\nWhen the target object isn't even expected to have `val`'s keys, it's\noften best to assert exactly that.\n\n    expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended\n    expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended\n\nWhen the target object is expected to have `val`'s keys, it's often best to\nassert that each of the properties has its expected value, rather than\nasserting that each property doesn't have one of many unexpected values.\n\n    expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended\n    expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended\n\n`.include` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect([1, 2, 3]).to.include(4, 'nooo why fail??');\n    expect([1, 2, 3], 'nooo why fail??').to.include(4);\n\n`.include` can also be used as a language chain, causing all `.members` and\n`.keys` assertions that follow in the chain to require the target to be a\nsuperset of the expected set, rather than an identical set. Note that\n`.members` ignores duplicates in the subset when `.include` is added.\n\n    // Target object's keys are a superset of ['a', 'b'] but not identical\n    expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');\n    expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');\n\n    // Target array is a superset of [1, 2] but not identical\n    expect([1, 2, 3]).to.include.members([1, 2]);\n    expect([1, 2, 3]).to.not.have.members([1, 2]);\n\n    // Duplicates in the subset are ignored\n    expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);\n\nNote that adding `.any` earlier in the chain causes the `.keys` assertion\nto ignore `.include`.\n\n    // Both assertions are identical\n    expect({a: 1}).to.include.any.keys('a', 'b');\n    expect({a: 1}).to.have.any.keys('a', 'b');\n\nThe aliases `.includes`, `.contain`, and `.contains` can be used\ninterchangeably with `.include`.",
      "summary": "### .include(val[, msg])",
      "body": "When the target is a string, `.include` asserts that the given string `val`\nis a substring of the target.\n\n    expect('foobar').to.include('foo');\n\nWhen the target is an array, `.include` asserts that the given `val` is a\nmember of the target.\n\n    expect([1, 2, 3]).to.include(2);\n\nWhen the target is an object, `.include` asserts that the given object\n`val`'s properties are a subset of the target's properties.\n\n    expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});\n\nWhen the target is a Set or WeakSet, `.include` asserts that the given `val` is a\nmember of the target. SameValueZero equality algorithm is used.\n\n    expect(new Set([1, 2])).to.include(2);\n\nWhen the target is a Map, `.include` asserts that the given `val` is one of\nthe values of the target. SameValueZero equality algorithm is used.\n\n    expect(new Map([['a', 1], ['b', 2]])).to.include(2);\n\nBecause `.include` does different things based on the target's type, it's\nimportant to check the target's type before using `.include`. See the `.a`\ndoc for info on testing a target's type.\n\n    expect([1, 2, 3]).to.be.an('array').that.includes(2);\n\nBy default, strict (`===`) equality is used to compare array members and\nobject properties. Add `.deep` earlier in the chain to use deep equality\ninstead (WeakSet targets are not supported). See the `deep-eql` project\npage for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n\n    // Target array deeply (but not strictly) includes `{a: 1}`\n    expect([{a: 1}]).to.deep.include({a: 1});\n    expect([{a: 1}]).to.not.include({a: 1});\n\n    // Target object deeply (but not strictly) includes `x: {a: 1}`\n    expect({x: {a: 1}}).to.deep.include({x: {a: 1}});\n    expect({x: {a: 1}}).to.not.include({x: {a: 1}});\n\nBy default, all of the target's properties are searched when working with\nobjects. This includes properties that are inherited and/or non-enumerable.\nAdd `.own` earlier in the chain to exclude the target's inherited\nproperties from the search.\n\n    Object.prototype.b = 2;\n\n    expect({a: 1}).to.own.include({a: 1});\n    expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});\n\nNote that a target object is always only searched for `val`'s own\nenumerable properties.\n\n`.deep` and `.own` can be combined.\n\n    expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});\n\nAdd `.nested` earlier in the chain to enable dot- and bracket-notation when\nreferencing nested properties.\n\n    expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});\n\nIf `.` or `[]` are part of an actual property name, they can be escaped by\nadding two backslashes before them.\n\n    expect({'.a': {'[b]': 2}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 2});\n\n`.deep` and `.nested` can be combined.\n\n    expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});\n\n`.own` and `.nested` cannot be combined.\n\nAdd `.not` earlier in the chain to negate `.include`.\n\n    expect('foobar').to.not.include('taco');\n    expect([1, 2, 3]).to.not.include(4);\n\nHowever, it's dangerous to negate `.include` when the target is an object.\nThe problem is that it creates uncertain expectations by asserting that the\ntarget object doesn't have all of `val`'s key/value pairs but may or may\nnot have some of them. It's often best to identify the exact output that's\nexpected, and then write an assertion that only accepts that exact output.\n\nWhen the target object isn't even expected to have `val`'s keys, it's\noften best to assert exactly that.\n\n    expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended\n    expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended\n\nWhen the target object is expected to have `val`'s keys, it's often best to\nassert that each of the properties has its expected value, rather than\nasserting that each property doesn't have one of many unexpected values.\n\n    expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended\n    expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended\n\n`.include` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect([1, 2, 3]).to.include(4, 'nooo why fail??');\n    expect([1, 2, 3], 'nooo why fail??').to.include(4);\n\n`.include` can also be used as a language chain, causing all `.members` and\n`.keys` assertions that follow in the chain to require the target to be a\nsuperset of the expected set, rather than an identical set. Note that\n`.members` ignores duplicates in the subset when `.include` is added.\n\n    // Target object's keys are a superset of ['a', 'b'] but not identical\n    expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');\n    expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');\n\n    // Target array is a superset of [1, 2] but not identical\n    expect([1, 2, 3]).to.include.members([1, 2]);\n    expect([1, 2, 3]).to.not.have.members([1, 2]);\n\n    // Duplicates in the subset are ignored\n    expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);\n\nNote that adding `.any` earlier in the chain causes the `.keys` assertion\nto ignore `.include`.\n\n    // Both assertions are identical\n    expect({a: 1}).to.include.any.keys('a', 'b');\n    expect({a: 1}).to.have.any.keys('a', 'b');\n\nThe aliases `.includes`, `.contain`, and `.contains` can be used\ninterchangeably with `.include`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 676,
    "codeStart": 823,
    "code": "function SameValueZero(a, b) {\n  return (_.isNaN(a) && _.isNaN(b)) || a === b;\n}\n\nfunction includeChainingBehavior () {\n  flag(this, 'contains', true);\n}\n\nfunction include (val, msg) {\n  if (msg) flag(this, 'message', msg);\n  \n  var obj = flag(this, 'object')\n    , objType = _.type(obj).toLowerCase()\n    , flagMsg = flag(this, 'message')\n    , negate = flag(this, 'negate')\n    , ssfi = flag(this, 'ssfi')\n    , isDeep = flag(this, 'deep')\n    , descriptor = isDeep ? 'deep ' : '';\n\n  flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n  var included = false;\n\n  switch (objType) {\n    case 'string':\n      included = obj.indexOf(val) !== -1;\n      break;\n\n    case 'weakset':\n      if (isDeep) {\n        throw new AssertionError(\n          flagMsg + 'unable to use .deep.include with WeakSet',\n          undefined,\n          ssfi\n        );\n      }\n\n      included = obj.has(val);\n      break;\n\n    case 'map':\n      var isEql = isDeep ? _.eql : SameValueZero;\n      obj.forEach(function (item) {\n        included = included || isEql(item, val);\n      });\n      break;\n\n    case 'set':\n      if (isDeep) {\n        obj.forEach(function (item) {\n          included = included || _.eql(item, val);\n        });\n      } else {\n        included = obj.has(val);\n      }\n      break;\n\n    case 'array':\n      if (isDeep) {\n        included = obj.some(function (item) {\n          return _.eql(item, val);\n        })\n      } else {\n        included = obj.indexOf(val) !== -1;\n      }\n      break;\n\n    default:\n      // This block is for asserting a subset of properties in an object.\n      // `_.expectTypes` isn't used here because `.include` should work with\n      // objects with a custom `@@toStringTag`.\n      if (val !== Object(val)) {\n        throw new AssertionError(\n          flagMsg + 'object tested must be an array, a map, an object,'\n            + ' a set, a string, or a weakset, but ' + objType + ' given',\n          undefined,\n          ssfi\n        );\n      }\n\n      var props = Object.keys(val)\n        , firstErr = null\n        , numErrs = 0;\n\n      props.forEach(function (prop) {\n        var propAssertion = new Assertion(obj);\n        _.transferFlags(this, propAssertion, true);\n        flag(propAssertion, 'lockSsfi', true);\n\n        if (!negate || props.length === 1) {\n          propAssertion.property(prop, val[prop]);\n          return;\n        }\n\n        try {\n          propAssertion.property(prop, val[prop]);\n        } catch (err) {\n          if (!_.checkError.compatibleConstructor(err, AssertionError)) {\n            throw err;\n          }\n          if (firstErr === null) firstErr = err;\n          numErrs++;\n        }\n      }, this);\n\n      // When validating .not.include with multiple properties, we only want\n      // to throw an assertion error if all of the properties are included,\n      // in which case we throw the first property assertion error that we\n      // encountered.\n      if (negate && props.length > 1 && numErrs === props.length) {\n        throw firstErr;\n      }\n      return;\n  }\n\n  // Assert inclusion in collection or substring in a string.\n  this.assert(\n    included\n    , 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val)\n    , 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));\n}\n\nAssertion.addChainableMethod('include', include, includeChainingBehavior);\nAssertion.addChainableMethod('contain', include, includeChainingBehavior);\nAssertion.addChainableMethod('contains', include, includeChainingBehavior);\nAssertion.addChainableMethod('includes', include, includeChainingBehavior);",
    "ctx": {
      "type": "function",
      "name": "SameValueZero",
      "string": "SameValueZero()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "ok"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .ok\n\nAsserts that the target is loosely (`==`) equal to `true`. However, it's\noften best to assert that the target is strictly (`===`) or deeply equal to\nits expected value.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.be.ok; // Not recommended\n\n    expect(true).to.be.true; // Recommended\n    expect(true).to.be.ok; // Not recommended\n\nAdd `.not` earlier in the chain to negate `.ok`.\n\n    expect(0).to.equal(0); // Recommended\n    expect(0).to.not.be.ok; // Not recommended\n\n    expect(false).to.be.false; // Recommended\n    expect(false).to.not.be.ok; // Not recommended\n\n    expect(null).to.be.null; // Recommended\n    expect(null).to.not.be.ok; // Not recommended\n\n    expect(undefined).to.be.undefined; // Recommended\n    expect(undefined).to.not.be.ok; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(false, 'nooo why fail??').to.be.ok;",
      "summary": "### .ok",
      "body": "Asserts that the target is loosely (`==`) equal to `true`. However, it's\noften best to assert that the target is strictly (`===`) or deeply equal to\nits expected value.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.be.ok; // Not recommended\n\n    expect(true).to.be.true; // Recommended\n    expect(true).to.be.ok; // Not recommended\n\nAdd `.not` earlier in the chain to negate `.ok`.\n\n    expect(0).to.equal(0); // Recommended\n    expect(0).to.not.be.ok; // Not recommended\n\n    expect(false).to.be.false; // Recommended\n    expect(false).to.not.be.ok; // Not recommended\n\n    expect(null).to.be.null; // Recommended\n    expect(null).to.not.be.ok; // Not recommended\n\n    expect(undefined).to.be.undefined; // Recommended\n    expect(undefined).to.not.be.ok; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(false, 'nooo why fail??').to.be.ok;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 950,
    "codeStart": 986,
    "code": "Assertion.addProperty('ok', function () {\n  this.assert(\n      flag(this, 'object')\n    , 'expected #{this} to be truthy'\n    , 'expected #{this} to be falsy');\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "true"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .true\n\nAsserts that the target is strictly (`===`) equal to `true`.\n\n    expect(true).to.be.true;\n\nAdd `.not` earlier in the chain to negate `.true`. However, it's often best\nto assert that the target is equal to its expected value, rather than not\nequal to `true`.\n\n    expect(false).to.be.false; // Recommended\n    expect(false).to.not.be.true; // Not recommended\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.be.true; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(false, 'nooo why fail??').to.be.true;",
      "summary": "### .true",
      "body": "Asserts that the target is strictly (`===`) equal to `true`.\n\n    expect(true).to.be.true;\n\nAdd `.not` earlier in the chain to negate `.true`. However, it's often best\nto assert that the target is equal to its expected value, rather than not\nequal to `true`.\n\n    expect(false).to.be.false; // Recommended\n    expect(false).to.not.be.true; // Not recommended\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.be.true; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(false, 'nooo why fail??').to.be.true;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 993,
    "codeStart": 1019,
    "code": "Assertion.addProperty('true', function () {\n  this.assert(\n      true === flag(this, 'object')\n    , 'expected #{this} to be true'\n    , 'expected #{this} to be false'\n    , flag(this, 'negate') ? false : true\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "false"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .false\n\nAsserts that the target is strictly (`===`) equal to `false`.\n\n    expect(false).to.be.false;\n\nAdd `.not` earlier in the chain to negate `.false`. However, it's often\nbest to assert that the target is equal to its expected value, rather than\nnot equal to `false`.\n\n    expect(true).to.be.true; // Recommended\n    expect(true).to.not.be.false; // Not recommended\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.be.false; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(true, 'nooo why fail??').to.be.false;",
      "summary": "### .false",
      "body": "Asserts that the target is strictly (`===`) equal to `false`.\n\n    expect(false).to.be.false;\n\nAdd `.not` earlier in the chain to negate `.false`. However, it's often\nbest to assert that the target is equal to its expected value, rather than\nnot equal to `false`.\n\n    expect(true).to.be.true; // Recommended\n    expect(true).to.not.be.false; // Not recommended\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.be.false; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(true, 'nooo why fail??').to.be.false;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1028,
    "codeStart": 1054,
    "code": "Assertion.addProperty('false', function () {\n  this.assert(\n      false === flag(this, 'object')\n    , 'expected #{this} to be false'\n    , 'expected #{this} to be true'\n    , flag(this, 'negate') ? true : false\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "null"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .null\n\nAsserts that the target is strictly (`===`) equal to `null`.\n\n    expect(null).to.be.null;\n\nAdd `.not` earlier in the chain to negate `.null`. However, it's often best\nto assert that the target is equal to its expected value, rather than not\nequal to `null`.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.be.null; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(42, 'nooo why fail??').to.be.null;",
      "summary": "### .null",
      "body": "Asserts that the target is strictly (`===`) equal to `null`.\n\n    expect(null).to.be.null;\n\nAdd `.not` earlier in the chain to negate `.null`. However, it's often best\nto assert that the target is equal to its expected value, rather than not\nequal to `null`.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.be.null; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(42, 'nooo why fail??').to.be.null;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1063,
    "codeStart": 1086,
    "code": "Assertion.addProperty('null', function () {\n  this.assert(\n      null === flag(this, 'object')\n    , 'expected #{this} to be null'\n    , 'expected #{this} not to be null'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "undefined"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .undefined\n\nAsserts that the target is strictly (`===`) equal to `undefined`.\n\n    expect(undefined).to.be.undefined;\n\nAdd `.not` earlier in the chain to negate `.undefined`. However, it's often\nbest to assert that the target is equal to its expected value, rather than\nnot equal to `undefined`.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.be.undefined; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(42, 'nooo why fail??').to.be.undefined;",
      "summary": "### .undefined",
      "body": "Asserts that the target is strictly (`===`) equal to `undefined`.\n\n    expect(undefined).to.be.undefined;\n\nAdd `.not` earlier in the chain to negate `.undefined`. However, it's often\nbest to assert that the target is equal to its expected value, rather than\nnot equal to `undefined`.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.be.undefined; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(42, 'nooo why fail??').to.be.undefined;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1094,
    "codeStart": 1117,
    "code": "Assertion.addProperty('undefined', function () {\n  this.assert(\n      undefined === flag(this, 'object')\n    , 'expected #{this} to be undefined'\n    , 'expected #{this} not to be undefined'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "NaN"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .NaN\n\nAsserts that the target is exactly `NaN`.\n\n    expect(NaN).to.be.NaN;\n\nAdd `.not` earlier in the chain to negate `.NaN`. However, it's often best\nto assert that the target is equal to its expected value, rather than not\nequal to `NaN`.\n\n    expect('foo').to.equal('foo'); // Recommended\n    expect('foo').to.not.be.NaN; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(42, 'nooo why fail??').to.be.NaN;",
      "summary": "### .NaN",
      "body": "Asserts that the target is exactly `NaN`.\n\n    expect(NaN).to.be.NaN;\n\nAdd `.not` earlier in the chain to negate `.NaN`. However, it's often best\nto assert that the target is equal to its expected value, rather than not\nequal to `NaN`.\n\n    expect('foo').to.equal('foo'); // Recommended\n    expect('foo').to.not.be.NaN; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(42, 'nooo why fail??').to.be.NaN;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1125,
    "codeStart": 1148,
    "code": "Assertion.addProperty('NaN', function () {\n  this.assert(\n      _.isNaN(flag(this, 'object'))\n      , 'expected #{this} to be NaN'\n      , 'expected #{this} not to be NaN'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "exist"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .exist\n\nAsserts that the target is not strictly (`===`) equal to either `null` or\n`undefined`. However, it's often best to assert that the target is equal to\nits expected value.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.exist; // Not recommended\n\n    expect(0).to.equal(0); // Recommended\n    expect(0).to.exist; // Not recommended\n\nAdd `.not` earlier in the chain to negate `.exist`.\n\n    expect(null).to.be.null; // Recommended\n    expect(null).to.not.exist; // Not recommended\n\n    expect(undefined).to.be.undefined; // Recommended\n    expect(undefined).to.not.exist; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(null, 'nooo why fail??').to.exist;",
      "summary": "### .exist",
      "body": "Asserts that the target is not strictly (`===`) equal to either `null` or\n`undefined`. However, it's often best to assert that the target is equal to\nits expected value.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.exist; // Not recommended\n\n    expect(0).to.equal(0); // Recommended\n    expect(0).to.exist; // Not recommended\n\nAdd `.not` earlier in the chain to negate `.exist`.\n\n    expect(null).to.be.null; // Recommended\n    expect(null).to.not.exist; // Not recommended\n\n    expect(undefined).to.be.undefined; // Recommended\n    expect(undefined).to.not.exist; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(null, 'nooo why fail??').to.exist;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1156,
    "codeStart": 1186,
    "code": "Assertion.addProperty('exist', function () {\n  var val = flag(this, 'object');\n  this.assert(\n      val !== null && val !== undefined\n    , 'expected #{this} to exist'\n    , 'expected #{this} to not exist'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "empty"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .empty\n\nWhen the target is a string or array, `.empty` asserts that the target's\n`length` property is strictly (`===`) equal to `0`.\n\n    expect([]).to.be.empty;\n    expect('').to.be.empty;\n\nWhen the target is a map or set, `.empty` asserts that the target's `size`\nproperty is strictly equal to `0`.\n\n    expect(new Set()).to.be.empty;\n    expect(new Map()).to.be.empty;\n\nWhen the target is a non-function object, `.empty` asserts that the target\ndoesn't have any own enumerable properties. Properties with Symbol-based\nkeys are excluded from the count.\n\n    expect({}).to.be.empty;\n\nBecause `.empty` does different things based on the target's type, it's\nimportant to check the target's type before using `.empty`. See the `.a`\ndoc for info on testing a target's type.\n\n    expect([]).to.be.an('array').that.is.empty;\n\nAdd `.not` earlier in the chain to negate `.empty`. However, it's often\nbest to assert that the target contains its expected number of values,\nrather than asserting that it's not empty.\n\n    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n    expect([1, 2, 3]).to.not.be.empty; // Not recommended\n\n    expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended\n    expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended\n\n    expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended\n    expect({a: 1}).to.not.be.empty; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect([1, 2, 3], 'nooo why fail??').to.be.empty;",
      "summary": "### .empty",
      "body": "When the target is a string or array, `.empty` asserts that the target's\n`length` property is strictly (`===`) equal to `0`.\n\n    expect([]).to.be.empty;\n    expect('').to.be.empty;\n\nWhen the target is a map or set, `.empty` asserts that the target's `size`\nproperty is strictly equal to `0`.\n\n    expect(new Set()).to.be.empty;\n    expect(new Map()).to.be.empty;\n\nWhen the target is a non-function object, `.empty` asserts that the target\ndoesn't have any own enumerable properties. Properties with Symbol-based\nkeys are excluded from the count.\n\n    expect({}).to.be.empty;\n\nBecause `.empty` does different things based on the target's type, it's\nimportant to check the target's type before using `.empty`. See the `.a`\ndoc for info on testing a target's type.\n\n    expect([]).to.be.an('array').that.is.empty;\n\nAdd `.not` earlier in the chain to negate `.empty`. However, it's often\nbest to assert that the target contains its expected number of values,\nrather than asserting that it's not empty.\n\n    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n    expect([1, 2, 3]).to.not.be.empty; // Not recommended\n\n    expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended\n    expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended\n\n    expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended\n    expect({a: 1}).to.not.be.empty; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect([1, 2, 3], 'nooo why fail??').to.be.empty;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1195,
    "codeStart": 1244,
    "code": "Assertion.addProperty('empty', function () {\n  var val = flag(this, 'object')\n    , ssfi = flag(this, 'ssfi')\n    , flagMsg = flag(this, 'message')\n    , itemsCount;\n\n  flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n  switch (_.type(val).toLowerCase()) {\n    case 'array':\n    case 'string':\n      itemsCount = val.length;\n      break;\n    case 'map':\n    case 'set':\n      itemsCount = val.size;\n      break;\n    case 'weakmap':\n    case 'weakset':\n      throw new AssertionError(\n        flagMsg + '.empty was passed a weak collection',\n        undefined,\n        ssfi\n      );\n    case 'function':\n      var msg = flagMsg + '.empty was passed a function ' + _.getName(val);\n      throw new AssertionError(msg.trim(), undefined, ssfi);\n    default:\n      if (val !== Object(val)) {\n        throw new AssertionError(\n          flagMsg + '.empty was passed non-string primitive ' + _.inspect(val),\n          undefined,\n          ssfi\n        );\n      }\n      itemsCount = Object.keys(val).length;\n  }\n\n  this.assert(\n      0 === itemsCount\n    , 'expected #{this} to be empty'\n    , 'expected #{this} not to be empty'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "arguments"
      },
      {
        "type": "alias",
        "string": "Arguments"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .arguments\n\nAsserts that the target is an `arguments` object.\n\n    function test () {\n      expect(arguments).to.be.arguments;\n    }\n\n    test();\n\nAdd `.not` earlier in the chain to negate `.arguments`. However, it's often\nbest to assert which type the target is expected to be, rather than\nasserting that its not an `arguments` object.\n\n    expect('foo').to.be.a('string'); // Recommended\n    expect('foo').to.not.be.arguments; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect({}, 'nooo why fail??').to.be.arguments;\n\nThe alias `.Arguments` can be used interchangeably with `.arguments`.",
      "summary": "### .arguments",
      "body": "Asserts that the target is an `arguments` object.\n\n    function test () {\n      expect(arguments).to.be.arguments;\n    }\n\n    test();\n\nAdd `.not` earlier in the chain to negate `.arguments`. However, it's often\nbest to assert which type the target is expected to be, rather than\nasserting that its not an `arguments` object.\n\n    expect('foo').to.be.a('string'); // Recommended\n    expect('foo').to.not.be.arguments; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect({}, 'nooo why fail??').to.be.arguments;\n\nThe alias `.Arguments` can be used interchangeably with `.arguments`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1289,
    "codeStart": 1319,
    "code": "function checkArguments () {\n  var obj = flag(this, 'object')\n    , type = _.type(obj);\n  this.assert(\n      'Arguments' === type\n    , 'expected #{this} to be arguments but got ' + type\n    , 'expected #{this} to not be arguments'\n  );\n}\n\nAssertion.addProperty('arguments', checkArguments);\nAssertion.addProperty('Arguments', checkArguments);",
    "ctx": {
      "type": "function",
      "name": "checkArguments",
      "string": "checkArguments()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "equal"
      },
      {
        "type": "alias",
        "string": "equals"
      },
      {
        "type": "alias",
        "string": "eq"
      },
      {
        "type": "param",
        "string": "{Mixed} val",
        "name": "val",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .equal(val[, msg])\n\nAsserts that the target is strictly (`===`) equal to the given `val`.\n\n    expect(1).to.equal(1);\n    expect('foo').to.equal('foo');\n\nAdd `.deep` earlier in the chain to use deep equality instead. See the\n`deep-eql` project page for info on the deep equality algorithm:\nhttps://github.com/chaijs/deep-eql.\n\n    // Target object deeply (but not strictly) equals `{a: 1}`\n    expect({a: 1}).to.deep.equal({a: 1});\n    expect({a: 1}).to.not.equal({a: 1});\n\n    // Target array deeply (but not strictly) equals `[1, 2]`\n    expect([1, 2]).to.deep.equal([1, 2]);\n    expect([1, 2]).to.not.equal([1, 2]);\n\nAdd `.not` earlier in the chain to negate `.equal`. However, it's often\nbest to assert that the target is equal to its expected value, rather than\nnot equal to one of countless unexpected values.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.equal(2); // Not recommended\n\n`.equal` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect(1).to.equal(2, 'nooo why fail??');\n    expect(1, 'nooo why fail??').to.equal(2);\n\nThe aliases `.equals` and `eq` can be used interchangeably with `.equal`.",
      "summary": "### .equal(val[, msg])",
      "body": "Asserts that the target is strictly (`===`) equal to the given `val`.\n\n    expect(1).to.equal(1);\n    expect('foo').to.equal('foo');\n\nAdd `.deep` earlier in the chain to use deep equality instead. See the\n`deep-eql` project page for info on the deep equality algorithm:\nhttps://github.com/chaijs/deep-eql.\n\n    // Target object deeply (but not strictly) equals `{a: 1}`\n    expect({a: 1}).to.deep.equal({a: 1});\n    expect({a: 1}).to.not.equal({a: 1});\n\n    // Target array deeply (but not strictly) equals `[1, 2]`\n    expect([1, 2]).to.deep.equal([1, 2]);\n    expect([1, 2]).to.not.equal([1, 2]);\n\nAdd `.not` earlier in the chain to negate `.equal`. However, it's often\nbest to assert that the target is equal to its expected value, rather than\nnot equal to one of countless unexpected values.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.equal(2); // Not recommended\n\n`.equal` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect(1).to.equal(2, 'nooo why fail??');\n    expect(1, 'nooo why fail??').to.equal(2);\n\nThe aliases `.equals` and `eq` can be used interchangeably with `.equal`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1332,
    "codeStart": 1377,
    "code": "function assertEqual (val, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  if (flag(this, 'deep')) {\n    return this.eql(val);\n  } else {\n    this.assert(\n        val === obj\n      , 'expected #{this} to equal #{exp}'\n      , 'expected #{this} to not equal #{exp}'\n      , val\n      , this._obj\n      , true\n    );\n  }\n}\n\nAssertion.addMethod('equal', assertEqual);\nAssertion.addMethod('equals', assertEqual);\nAssertion.addMethod('eq', assertEqual);",
    "ctx": {
      "type": "function",
      "name": "assertEqual",
      "string": "assertEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "eql"
      },
      {
        "type": "alias",
        "string": "eqls"
      },
      {
        "type": "param",
        "string": "{Mixed} obj",
        "name": "obj",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .eql(obj[, msg])\n\nAsserts that the target is deeply equal to the given `obj`. See the\n`deep-eql` project page for info on the deep equality algorithm:\nhttps://github.com/chaijs/deep-eql.\n\n    // Target object is deeply (but not strictly) equal to {a: 1}\n    expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});\n\n    // Target array is deeply (but not strictly) equal to [1, 2]\n    expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);\n\nAdd `.not` earlier in the chain to negate `.eql`. However, it's often best\nto assert that the target is deeply equal to its expected value, rather\nthan not deeply equal to one of countless unexpected values.\n\n    expect({a: 1}).to.eql({a: 1}); // Recommended\n    expect({a: 1}).to.not.eql({b: 2}); // Not recommended\n\n`.eql` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');\n    expect({a: 1}, 'nooo why fail??').to.eql({b: 2});\n\nThe alias `.eqls` can be used interchangeably with `.eql`.\n\nThe `.deep.equal` assertion is almost identical to `.eql` but with one\ndifference: `.deep.equal` causes deep equality comparisons to also be used\nfor any other assertions that follow in the chain.",
      "summary": "### .eql(obj[, msg])",
      "body": "Asserts that the target is deeply equal to the given `obj`. See the\n`deep-eql` project page for info on the deep equality algorithm:\nhttps://github.com/chaijs/deep-eql.\n\n    // Target object is deeply (but not strictly) equal to {a: 1}\n    expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});\n\n    // Target array is deeply (but not strictly) equal to [1, 2]\n    expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);\n\nAdd `.not` earlier in the chain to negate `.eql`. However, it's often best\nto assert that the target is deeply equal to its expected value, rather\nthan not deeply equal to one of countless unexpected values.\n\n    expect({a: 1}).to.eql({a: 1}); // Recommended\n    expect({a: 1}).to.not.eql({b: 2}); // Not recommended\n\n`.eql` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');\n    expect({a: 1}, 'nooo why fail??').to.eql({b: 2});\n\nThe alias `.eqls` can be used interchangeably with `.eql`.\n\nThe `.deep.equal` assertion is almost identical to `.eql` but with one\ndifference: `.deep.equal` causes deep equality comparisons to also be used\nfor any other assertions that follow in the chain."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1398,
    "codeStart": 1439,
    "code": "function assertEql(obj, msg) {\n  if (msg) flag(this, 'message', msg);\n  this.assert(\n      _.eql(obj, flag(this, 'object'))\n    , 'expected #{this} to deeply equal #{exp}'\n    , 'expected #{this} to not deeply equal #{exp}'\n    , obj\n    , this._obj\n    , true\n  );\n}\n\nAssertion.addMethod('eql', assertEql);\nAssertion.addMethod('eqls', assertEql);",
    "ctx": {
      "type": "function",
      "name": "assertEql",
      "string": "assertEql()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "above"
      },
      {
        "type": "alias",
        "string": "gt"
      },
      {
        "type": "alias",
        "string": "greaterThan"
      },
      {
        "type": "param",
        "string": "{Number} n",
        "name": "n",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .above(n[, msg])\n\nAsserts that the target is a number or a date greater than the given number or date `n` respectively.\nHowever, it's often best to assert that the target is equal to its expected\nvalue.\n\n    expect(2).to.equal(2); // Recommended\n    expect(2).to.be.above(1); // Not recommended\n\nAdd `.lengthOf` earlier in the chain to assert that the value of the\ntarget's `length` property is greater than the given number `n`.\n\n    expect('foo').to.have.lengthOf(3); // Recommended\n    expect('foo').to.have.lengthOf.above(2); // Not recommended\n\n    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n    expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.above`.\n\n    expect(2).to.equal(2); // Recommended\n    expect(1).to.not.be.above(2); // Not recommended\n\n`.above` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect(1).to.be.above(2, 'nooo why fail??');\n    expect(1, 'nooo why fail??').to.be.above(2);\n\nThe aliases `.gt` and `.greaterThan` can be used interchangeably with\n`.above`.",
      "summary": "### .above(n[, msg])",
      "body": "Asserts that the target is a number or a date greater than the given number or date `n` respectively.\nHowever, it's often best to assert that the target is equal to its expected\nvalue.\n\n    expect(2).to.equal(2); // Recommended\n    expect(2).to.be.above(1); // Not recommended\n\nAdd `.lengthOf` earlier in the chain to assert that the value of the\ntarget's `length` property is greater than the given number `n`.\n\n    expect('foo').to.have.lengthOf(3); // Recommended\n    expect('foo').to.have.lengthOf.above(2); // Not recommended\n\n    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n    expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.above`.\n\n    expect(2).to.equal(2); // Recommended\n    expect(1).to.not.be.above(2); // Not recommended\n\n`.above` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect(1).to.be.above(2, 'nooo why fail??');\n    expect(1, 'nooo why fail??').to.be.above(2);\n\nThe aliases `.gt` and `.greaterThan` can be used interchangeably with\n`.above`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1454,
    "codeStart": 1497,
    "code": "function assertAbove (n, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object')\n    , doLength = flag(this, 'doLength')\n    , flagMsg = flag(this, 'message')\n    , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n    , ssfi = flag(this, 'ssfi')\n    , objType = _.type(obj).toLowerCase()\n    , nType = _.type(n).toLowerCase()\n    , shouldThrow = true;\n\n  if (doLength) {\n    new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n  }\n  \n  if (!doLength && (objType === 'date' && nType !== 'date')) {\n    errorMessage = msgPrefix + 'the argument to above must be a date';\n  } else if (nType !== 'number' && (doLength || objType === 'number')) {\n    errorMessage = msgPrefix + 'the argument to above must be a number';\n  } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n    var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n    errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n  } else {\n    shouldThrow = false;\n  }\n\n  if (shouldThrow) {\n    throw new AssertionError(errorMessage, undefined, ssfi);\n  }\n\n  if (doLength) {\n    var len = obj.length;\n    this.assert(\n        len > n\n      , 'expected #{this} to have a length above #{exp} but got #{act}'\n      , 'expected #{this} to not have a length above #{exp}'\n      , n\n      , len\n    );\n  } else {\n    this.assert(\n        obj > n\n      , 'expected #{this} to be above #{exp}'\n      , 'expected #{this} to be at most #{exp}'\n      , n\n    );\n  }\n}\n\nAssertion.addMethod('above', assertAbove);\nAssertion.addMethod('gt', assertAbove);\nAssertion.addMethod('greaterThan', assertAbove);",
    "ctx": {
      "type": "function",
      "name": "assertAbove",
      "string": "assertAbove()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "least"
      },
      {
        "type": "alias",
        "string": "gte"
      },
      {
        "type": "param",
        "string": "{Number} n",
        "name": "n",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .least(n[, msg])\n\nAsserts that the target is a number or a date greater than or equal to the given\nnumber or date `n` respectively. However, it's often best to assert that the target is equal to\nits expected value.\n\n    expect(2).to.equal(2); // Recommended\n    expect(2).to.be.at.least(1); // Not recommended\n    expect(2).to.be.at.least(2); // Not recommended\n\nAdd `.lengthOf` earlier in the chain to assert that the value of the\ntarget's `length` property is greater than or equal to the given number\n`n`.\n\n    expect('foo').to.have.lengthOf(3); // Recommended\n    expect('foo').to.have.lengthOf.at.least(2); // Not recommended\n\n    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n    expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.least`.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.be.at.least(2); // Not recommended\n\n`.least` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect(1).to.be.at.least(2, 'nooo why fail??');\n    expect(1, 'nooo why fail??').to.be.at.least(2);\n\nThe alias `.gte` can be used interchangeably with `.least`.",
      "summary": "### .least(n[, msg])",
      "body": "Asserts that the target is a number or a date greater than or equal to the given\nnumber or date `n` respectively. However, it's often best to assert that the target is equal to\nits expected value.\n\n    expect(2).to.equal(2); // Recommended\n    expect(2).to.be.at.least(1); // Not recommended\n    expect(2).to.be.at.least(2); // Not recommended\n\nAdd `.lengthOf` earlier in the chain to assert that the value of the\ntarget's `length` property is greater than or equal to the given number\n`n`.\n\n    expect('foo').to.have.lengthOf(3); // Recommended\n    expect('foo').to.have.lengthOf.at.least(2); // Not recommended\n\n    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n    expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.least`.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.be.at.least(2); // Not recommended\n\n`.least` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect(1).to.be.at.least(2, 'nooo why fail??');\n    expect(1, 'nooo why fail??').to.be.at.least(2);\n\nThe alias `.gte` can be used interchangeably with `.least`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1550,
    "codeStart": 1593,
    "code": "function assertLeast (n, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object')\n    , doLength = flag(this, 'doLength')\n    , flagMsg = flag(this, 'message')\n    , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n    , ssfi = flag(this, 'ssfi')\n    , objType = _.type(obj).toLowerCase()\n    , nType = _.type(n).toLowerCase()\n    , shouldThrow = true;\n\n  if (doLength) {\n    new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n  }\n\n  if (!doLength && (objType === 'date' && nType !== 'date')) {\n    errorMessage = msgPrefix + 'the argument to least must be a date';\n  } else if (nType !== 'number' && (doLength || objType === 'number')) {\n    errorMessage = msgPrefix + 'the argument to least must be a number';\n  } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n    var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n    errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n  } else {\n    shouldThrow = false;\n  }\n\n  if (shouldThrow) {\n    throw new AssertionError(errorMessage, undefined, ssfi);\n  }\n\n  if (doLength) {\n    var len = obj.length;\n    this.assert(\n        len >= n\n      , 'expected #{this} to have a length at least #{exp} but got #{act}'\n      , 'expected #{this} to have a length below #{exp}'\n      , n\n      , len\n    );\n  } else {\n    this.assert(\n        obj >= n\n      , 'expected #{this} to be at least #{exp}'\n      , 'expected #{this} to be below #{exp}'\n      , n\n    );\n  }\n}\n\nAssertion.addMethod('least', assertLeast);\nAssertion.addMethod('gte', assertLeast);",
    "ctx": {
      "type": "function",
      "name": "assertLeast",
      "string": "assertLeast()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "below"
      },
      {
        "type": "alias",
        "string": "lt"
      },
      {
        "type": "alias",
        "string": "lessThan"
      },
      {
        "type": "param",
        "string": "{Number} n",
        "name": "n",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .below(n[, msg])\n\nAsserts that the target is a number or a date less than the given number or date `n` respectively.\nHowever, it's often best to assert that the target is equal to its expected\nvalue.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.be.below(2); // Not recommended\n\nAdd `.lengthOf` earlier in the chain to assert that the value of the\ntarget's `length` property is less than the given number `n`.\n\n    expect('foo').to.have.lengthOf(3); // Recommended\n    expect('foo').to.have.lengthOf.below(4); // Not recommended\n\n    expect([1, 2, 3]).to.have.length(3); // Recommended\n    expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.below`.\n\n    expect(2).to.equal(2); // Recommended\n    expect(2).to.not.be.below(1); // Not recommended\n\n`.below` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect(2).to.be.below(1, 'nooo why fail??');\n    expect(2, 'nooo why fail??').to.be.below(1);\n\nThe aliases `.lt` and `.lessThan` can be used interchangeably with\n`.below`.",
      "summary": "### .below(n[, msg])",
      "body": "Asserts that the target is a number or a date less than the given number or date `n` respectively.\nHowever, it's often best to assert that the target is equal to its expected\nvalue.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.be.below(2); // Not recommended\n\nAdd `.lengthOf` earlier in the chain to assert that the value of the\ntarget's `length` property is less than the given number `n`.\n\n    expect('foo').to.have.lengthOf(3); // Recommended\n    expect('foo').to.have.lengthOf.below(4); // Not recommended\n\n    expect([1, 2, 3]).to.have.length(3); // Recommended\n    expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.below`.\n\n    expect(2).to.equal(2); // Recommended\n    expect(2).to.not.be.below(1); // Not recommended\n\n`.below` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect(2).to.be.below(1, 'nooo why fail??');\n    expect(2, 'nooo why fail??').to.be.below(1);\n\nThe aliases `.lt` and `.lessThan` can be used interchangeably with\n`.below`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1645,
    "codeStart": 1688,
    "code": "function assertBelow (n, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object')\n    , doLength = flag(this, 'doLength')\n    , flagMsg = flag(this, 'message')\n    , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n    , ssfi = flag(this, 'ssfi')\n    , objType = _.type(obj).toLowerCase()\n    , nType = _.type(n).toLowerCase()\n    , shouldThrow = true;\n\n  if (doLength) {\n    new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n  }\n\n  if (!doLength && (objType === 'date' && nType !== 'date')) {\n    errorMessage = msgPrefix + 'the argument to below must be a date';\n  } else if (nType !== 'number' && (doLength || objType === 'number')) {\n    errorMessage = msgPrefix + 'the argument to below must be a number';\n  } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n    var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n    errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n  } else {\n    shouldThrow = false;\n  }\n\n  if (shouldThrow) {\n    throw new AssertionError(errorMessage, undefined, ssfi);\n  }\n\n  if (doLength) {\n    var len = obj.length;\n    this.assert(\n        len < n\n      , 'expected #{this} to have a length below #{exp} but got #{act}'\n      , 'expected #{this} to not have a length below #{exp}'\n      , n\n      , len\n    );\n  } else {\n    this.assert(\n        obj < n\n      , 'expected #{this} to be below #{exp}'\n      , 'expected #{this} to be at least #{exp}'\n      , n\n    );\n  }\n}\n\nAssertion.addMethod('below', assertBelow);\nAssertion.addMethod('lt', assertBelow);\nAssertion.addMethod('lessThan', assertBelow);",
    "ctx": {
      "type": "function",
      "name": "assertBelow",
      "string": "assertBelow()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "most"
      },
      {
        "type": "alias",
        "string": "lte"
      },
      {
        "type": "param",
        "string": "{Number} n",
        "name": "n",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .most(n[, msg])\n\nAsserts that the target is a number or a date less than or equal to the given number\nor date `n` respectively. However, it's often best to assert that the target is equal to its\nexpected value.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.be.at.most(2); // Not recommended\n    expect(1).to.be.at.most(1); // Not recommended\n\nAdd `.lengthOf` earlier in the chain to assert that the value of the\ntarget's `length` property is less than or equal to the given number `n`.\n\n    expect('foo').to.have.lengthOf(3); // Recommended\n    expect('foo').to.have.lengthOf.at.most(4); // Not recommended\n\n    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n    expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.most`.\n\n    expect(2).to.equal(2); // Recommended\n    expect(2).to.not.be.at.most(1); // Not recommended\n\n`.most` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect(2).to.be.at.most(1, 'nooo why fail??');\n    expect(2, 'nooo why fail??').to.be.at.most(1);\n\nThe alias `.lte` can be used interchangeably with `.most`.",
      "summary": "### .most(n[, msg])",
      "body": "Asserts that the target is a number or a date less than or equal to the given number\nor date `n` respectively. However, it's often best to assert that the target is equal to its\nexpected value.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.be.at.most(2); // Not recommended\n    expect(1).to.be.at.most(1); // Not recommended\n\nAdd `.lengthOf` earlier in the chain to assert that the value of the\ntarget's `length` property is less than or equal to the given number `n`.\n\n    expect('foo').to.have.lengthOf(3); // Recommended\n    expect('foo').to.have.lengthOf.at.most(4); // Not recommended\n\n    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n    expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.most`.\n\n    expect(2).to.equal(2); // Recommended\n    expect(2).to.not.be.at.most(1); // Not recommended\n\n`.most` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect(2).to.be.at.most(1, 'nooo why fail??');\n    expect(2, 'nooo why fail??').to.be.at.most(1);\n\nThe alias `.lte` can be used interchangeably with `.most`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1741,
    "codeStart": 1783,
    "code": "function assertMost (n, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object')\n    , doLength = flag(this, 'doLength')\n    , flagMsg = flag(this, 'message')\n    , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n    , ssfi = flag(this, 'ssfi')\n    , objType = _.type(obj).toLowerCase()\n    , nType = _.type(n).toLowerCase()\n    , shouldThrow = true;\n\n  if (doLength) {\n    new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n  }\n  \n  if (!doLength && (objType === 'date' && nType !== 'date')) {\n    errorMessage = msgPrefix + 'the argument to most must be a date';\n  } else if (nType !== 'number' && (doLength || objType === 'number')) {\n    errorMessage = msgPrefix + 'the argument to most must be a number';\n  } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n    var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n    errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n  } else {\n    shouldThrow = false;\n  }\n\n  if (shouldThrow) {\n    throw new AssertionError(errorMessage, undefined, ssfi);\n  }\n\n  if (doLength) {\n    var len = obj.length;\n    this.assert(\n        len <= n\n      , 'expected #{this} to have a length at most #{exp} but got #{act}'\n      , 'expected #{this} to have a length above #{exp}'\n      , n\n      , len\n    );\n  } else {\n    this.assert(\n        obj <= n\n      , 'expected #{this} to be at most #{exp}'\n      , 'expected #{this} to be above #{exp}'\n      , n\n    );\n  }\n}\n\nAssertion.addMethod('most', assertMost);\nAssertion.addMethod('lte', assertMost);",
    "ctx": {
      "type": "function",
      "name": "assertMost",
      "string": "assertMost()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "within"
      },
      {
        "type": "param",
        "string": "{Number} start lower bound inclusive",
        "name": "start",
        "description": "lower bound inclusive",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} finish upper bound inclusive",
        "name": "finish",
        "description": "upper bound inclusive",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .within(start, finish[, msg])\n\nAsserts that the target is a number or a date greater than or equal to the given\nnumber or date `start`, and less than or equal to the given number or date `finish` respectively.\nHowever, it's often best to assert that the target is equal to its expected\nvalue.\n\n    expect(2).to.equal(2); // Recommended\n    expect(2).to.be.within(1, 3); // Not recommended\n    expect(2).to.be.within(2, 3); // Not recommended\n    expect(2).to.be.within(1, 2); // Not recommended\n\nAdd `.lengthOf` earlier in the chain to assert that the value of the\ntarget's `length` property is greater than or equal to the given number\n`start`, and less than or equal to the given number `finish`.\n\n    expect('foo').to.have.lengthOf(3); // Recommended\n    expect('foo').to.have.lengthOf.within(2, 4); // Not recommended\n\n    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n    expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.within`.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.be.within(2, 4); // Not recommended\n\n`.within` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect(4).to.be.within(1, 3, 'nooo why fail??');\n    expect(4, 'nooo why fail??').to.be.within(1, 3);",
      "summary": "### .within(start, finish[, msg])",
      "body": "Asserts that the target is a number or a date greater than or equal to the given\nnumber or date `start`, and less than or equal to the given number or date `finish` respectively.\nHowever, it's often best to assert that the target is equal to its expected\nvalue.\n\n    expect(2).to.equal(2); // Recommended\n    expect(2).to.be.within(1, 3); // Not recommended\n    expect(2).to.be.within(2, 3); // Not recommended\n    expect(2).to.be.within(1, 2); // Not recommended\n\nAdd `.lengthOf` earlier in the chain to assert that the value of the\ntarget's `length` property is greater than or equal to the given number\n`start`, and less than or equal to the given number `finish`.\n\n    expect('foo').to.have.lengthOf(3); // Recommended\n    expect('foo').to.have.lengthOf.within(2, 4); // Not recommended\n\n    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n    expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.within`.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.be.within(2, 4); // Not recommended\n\n`.within` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect(4).to.be.within(1, 3, 'nooo why fail??');\n    expect(4, 'nooo why fail??').to.be.within(1, 3);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1835,
    "codeStart": 1878,
    "code": "Assertion.addMethod('within', function (start, finish, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object')\n    , doLength = flag(this, 'doLength')\n    , flagMsg = flag(this, 'message')\n    , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n    , ssfi = flag(this, 'ssfi')\n    , objType = _.type(obj).toLowerCase()\n    , startType = _.type(start).toLowerCase()\n    , finishType = _.type(finish).toLowerCase()\n    , shouldThrow = true\n    , range = (startType === 'date' && finishType === 'date')\n        ? start.toUTCString() + '..' + finish.toUTCString()\n        : start + '..' + finish;\n\n  if (doLength) {\n    new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n  }\n\n  if (!doLength && (objType === 'date' && (startType !== 'date' || finishType !== 'date'))) {\n    errorMessage = msgPrefix + 'the arguments to within must be dates';\n  } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {\n    errorMessage = msgPrefix + 'the arguments to within must be numbers';\n  } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n    var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n    errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n  } else {\n    shouldThrow = false;\n  }\n\n  if (shouldThrow) {\n    throw new AssertionError(errorMessage, undefined, ssfi);\n  }\n\n  if (doLength) {\n    var len = obj.length;\n    this.assert(\n        len >= start && len <= finish\n      , 'expected #{this} to have a length within ' + range\n      , 'expected #{this} to not have a length within ' + range\n    );\n  } else {\n    this.assert(\n        obj >= start && obj <= finish\n      , 'expected #{this} to be within ' + range\n      , 'expected #{this} to not be within ' + range\n    );\n  }\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "instanceof"
      },
      {
        "type": "param",
        "string": "{Constructor} constructor",
        "name": "constructor",
        "description": "",
        "types": [
          "Constructor"
        ],
        "typesDescription": "<a href=\"Constructor.html\">Constructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "alias",
        "string": "instanceOf"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .instanceof(constructor[, msg])\n\nAsserts that the target is an instance of the given `constructor`.\n\n    function Cat () { }\n\n    expect(new Cat()).to.be.an.instanceof(Cat);\n    expect([1, 2]).to.be.an.instanceof(Array);\n\nAdd `.not` earlier in the chain to negate `.instanceof`.\n\n    expect({a: 1}).to.not.be.an.instanceof(Array);\n\n`.instanceof` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect(1).to.be.an.instanceof(Array, 'nooo why fail??');\n    expect(1, 'nooo why fail??').to.be.an.instanceof(Array);\n\nDue to limitations in ES5, `.instanceof` may not always work as expected\nwhen using a transpiler such as Babel or TypeScript. In particular, it may\nproduce unexpected results when subclassing built-in object such as\n`Array`, `Error`, and `Map`. See your transpiler's docs for details:\n\n- ([Babel](https://babeljs.io/docs/usage/caveats/#classes))\n- ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))\n\nThe alias `.instanceOf` can be used interchangeably with `.instanceof`.",
      "summary": "### .instanceof(constructor[, msg])",
      "body": "Asserts that the target is an instance of the given `constructor`.\n\n    function Cat () { }\n\n    expect(new Cat()).to.be.an.instanceof(Cat);\n    expect([1, 2]).to.be.an.instanceof(Array);\n\nAdd `.not` earlier in the chain to negate `.instanceof`.\n\n    expect({a: 1}).to.not.be.an.instanceof(Array);\n\n`.instanceof` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect(1).to.be.an.instanceof(Array, 'nooo why fail??');\n    expect(1, 'nooo why fail??').to.be.an.instanceof(Array);\n\nDue to limitations in ES5, `.instanceof` may not always work as expected\nwhen using a transpiler such as Babel or TypeScript. In particular, it may\nproduce unexpected results when subclassing built-in object such as\n`Array`, `Error`, and `Map`. See your transpiler's docs for details:\n\n- ([Babel](https://babeljs.io/docs/usage/caveats/#classes))\n- ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))\n\nThe alias `.instanceOf` can be used interchangeably with `.instanceof`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 1928,
    "codeStart": 1967,
    "code": "function assertInstanceOf (constructor, msg) {\n  if (msg) flag(this, 'message', msg);\n\n  var target = flag(this, 'object')\n  var ssfi = flag(this, 'ssfi');\n  var flagMsg = flag(this, 'message');\n\n  try {\n    var isInstanceOf = target instanceof constructor;\n  } catch (err) {\n    if (err instanceof TypeError) {\n      flagMsg = flagMsg ? flagMsg + ': ' : '';\n      throw new AssertionError(\n        flagMsg + 'The instanceof assertion needs a constructor but '\n          + _.type(constructor) + ' was given.',\n        undefined,\n        ssfi\n      );\n    }\n    throw err;\n  }\n\n  var name = _.getName(constructor);\n  if (name === null) {\n    name = 'an unnamed constructor';\n  }\n\n  this.assert(\n      isInstanceOf\n    , 'expected #{this} to be an instance of ' + name\n    , 'expected #{this} to not be an instance of ' + name\n  );\n};\n\nAssertion.addMethod('instanceof', assertInstanceOf);\nAssertion.addMethod('instanceOf', assertInstanceOf);",
    "ctx": {
      "type": "function",
      "name": "assertInstanceOf",
      "string": "assertInstanceOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "property"
      },
      {
        "type": "param",
        "string": "{String} name",
        "name": "name",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} val (optional)",
        "name": "val",
        "description": "(optional)",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "value of property for chaining",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "value of property for chaining"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .property(name[, val[, msg]])\n\nAsserts that the target has a property with the given key `name`.\n\n    expect({a: 1}).to.have.property('a');\n\nWhen `val` is provided, `.property` also asserts that the property's value\nis equal to the given `val`.\n\n    expect({a: 1}).to.have.property('a', 1);\n\nBy default, strict (`===`) equality is used. Add `.deep` earlier in the\nchain to use deep equality instead. See the `deep-eql` project page for\ninfo on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n\n    // Target object deeply (but not strictly) has property `x: {a: 1}`\n    expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});\n    expect({x: {a: 1}}).to.not.have.property('x', {a: 1});\n\nThe target's enumerable and non-enumerable properties are always included\nin the search. By default, both own and inherited properties are included.\nAdd `.own` earlier in the chain to exclude inherited properties from the\nsearch.\n\n    Object.prototype.b = 2;\n\n    expect({a: 1}).to.have.own.property('a');\n    expect({a: 1}).to.have.own.property('a', 1);\n    expect({a: 1}).to.have.property('b').but.not.own.property('b'); \n\n`.deep` and `.own` can be combined.\n\n    expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});\n\nAdd `.nested` earlier in the chain to enable dot- and bracket-notation when\nreferencing nested properties.\n\n    expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');\n    expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');\n\nIf `.` or `[]` are part of an actual property name, they can be escaped by\nadding two backslashes before them.\n\n    expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');\n\n`.deep` and `.nested` can be combined.\n\n    expect({a: {b: [{c: 3}]}})\n      .to.have.deep.nested.property('a.b[0]', {c: 3});\n\n`.own` and `.nested` cannot be combined.\n\nAdd `.not` earlier in the chain to negate `.property`.\n\n    expect({a: 1}).to.not.have.property('b');\n\nHowever, it's dangerous to negate `.property` when providing `val`. The\nproblem is that it creates uncertain expectations by asserting that the\ntarget either doesn't have a property with the given key `name`, or that it\ndoes have a property with the given key `name` but its value isn't equal to\nthe given `val`. It's often best to identify the exact output that's\nexpected, and then write an assertion that only accepts that exact output.\n\nWhen the target isn't expected to have a property with the given key\n`name`, it's often best to assert exactly that.\n\n    expect({b: 2}).to.not.have.property('a'); // Recommended\n    expect({b: 2}).to.not.have.property('a', 1); // Not recommended\n\nWhen the target is expected to have a property with the given key `name`,\nit's often best to assert that the property has its expected value, rather\nthan asserting that it doesn't have one of many unexpected values.\n\n    expect({a: 3}).to.have.property('a', 3); // Recommended\n    expect({a: 3}).to.not.have.property('a', 1); // Not recommended\n\n`.property` changes the target of any assertions that follow in the chain\nto be the value of the property from the original target object.\n\n    expect({a: 1}).to.have.property('a').that.is.a('number');\n\n`.property` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`. When not providing `val`, only use the\nsecond form.\n\n    // Recommended\n    expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');\n    expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);\n    expect({a: 1}, 'nooo why fail??').to.have.property('b');\n\n    // Not recommended\n    expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');\n\nThe above assertion isn't the same thing as not providing `val`. Instead,\nit's asserting that the target object has a `b` property that's equal to\n`undefined`.\n\nThe assertions `.ownProperty` and `.haveOwnProperty` can be used\ninterchangeably with `.own.property`.",
      "summary": "### .property(name[, val[, msg]])",
      "body": "Asserts that the target has a property with the given key `name`.\n\n    expect({a: 1}).to.have.property('a');\n\nWhen `val` is provided, `.property` also asserts that the property's value\nis equal to the given `val`.\n\n    expect({a: 1}).to.have.property('a', 1);\n\nBy default, strict (`===`) equality is used. Add `.deep` earlier in the\nchain to use deep equality instead. See the `deep-eql` project page for\ninfo on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n\n    // Target object deeply (but not strictly) has property `x: {a: 1}`\n    expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});\n    expect({x: {a: 1}}).to.not.have.property('x', {a: 1});\n\nThe target's enumerable and non-enumerable properties are always included\nin the search. By default, both own and inherited properties are included.\nAdd `.own` earlier in the chain to exclude inherited properties from the\nsearch.\n\n    Object.prototype.b = 2;\n\n    expect({a: 1}).to.have.own.property('a');\n    expect({a: 1}).to.have.own.property('a', 1);\n    expect({a: 1}).to.have.property('b').but.not.own.property('b'); \n\n`.deep` and `.own` can be combined.\n\n    expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});\n\nAdd `.nested` earlier in the chain to enable dot- and bracket-notation when\nreferencing nested properties.\n\n    expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');\n    expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');\n\nIf `.` or `[]` are part of an actual property name, they can be escaped by\nadding two backslashes before them.\n\n    expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');\n\n`.deep` and `.nested` can be combined.\n\n    expect({a: {b: [{c: 3}]}})\n      .to.have.deep.nested.property('a.b[0]', {c: 3});\n\n`.own` and `.nested` cannot be combined.\n\nAdd `.not` earlier in the chain to negate `.property`.\n\n    expect({a: 1}).to.not.have.property('b');\n\nHowever, it's dangerous to negate `.property` when providing `val`. The\nproblem is that it creates uncertain expectations by asserting that the\ntarget either doesn't have a property with the given key `name`, or that it\ndoes have a property with the given key `name` but its value isn't equal to\nthe given `val`. It's often best to identify the exact output that's\nexpected, and then write an assertion that only accepts that exact output.\n\nWhen the target isn't expected to have a property with the given key\n`name`, it's often best to assert exactly that.\n\n    expect({b: 2}).to.not.have.property('a'); // Recommended\n    expect({b: 2}).to.not.have.property('a', 1); // Not recommended\n\nWhen the target is expected to have a property with the given key `name`,\nit's often best to assert that the property has its expected value, rather\nthan asserting that it doesn't have one of many unexpected values.\n\n    expect({a: 3}).to.have.property('a', 3); // Recommended\n    expect({a: 3}).to.not.have.property('a', 1); // Not recommended\n\n`.property` changes the target of any assertions that follow in the chain\nto be the value of the property from the original target object.\n\n    expect({a: 1}).to.have.property('a').that.is.a('number');\n\n`.property` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`. When not providing `val`, only use the\nsecond form.\n\n    // Recommended\n    expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');\n    expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);\n    expect({a: 1}, 'nooo why fail??').to.have.property('b');\n\n    // Not recommended\n    expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');\n\nThe above assertion isn't the same thing as not providing `val`. Instead,\nit's asserting that the target object has a `b` property that's equal to\n`undefined`.\n\nThe assertions `.ownProperty` and `.haveOwnProperty` can be used\ninterchangeably with `.own.property`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2004,
    "codeStart": 2115,
    "code": "function assertProperty (name, val, msg) {\n  if (msg) flag(this, 'message', msg);\n\n  var isNested = flag(this, 'nested')\n    , isOwn = flag(this, 'own')\n    , flagMsg = flag(this, 'message')\n    , obj = flag(this, 'object')\n    , ssfi = flag(this, 'ssfi');\n\n  if (isNested && isOwn) {\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n    throw new AssertionError(\n      flagMsg + 'The \"nested\" and \"own\" flags cannot be combined.',\n      undefined,\n      ssfi\n    );\n  }\n\n  if (obj === null || obj === undefined) {\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n    throw new AssertionError(\n      flagMsg + 'Target cannot be null or undefined.',\n      undefined,\n      ssfi\n    );\n  }\n\n  var isDeep = flag(this, 'deep')\n    , negate = flag(this, 'negate')\n    , pathInfo = isNested ? _.getPathInfo(obj, name) : null\n    , value = isNested ? pathInfo.value : obj[name];\n\n  var descriptor = '';\n  if (isDeep) descriptor += 'deep ';\n  if (isOwn) descriptor += 'own ';\n  if (isNested) descriptor += 'nested ';\n  descriptor += 'property ';\n\n  var hasProperty;\n  if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);\n  else if (isNested) hasProperty = pathInfo.exists;\n  else hasProperty = _.hasProperty(obj, name);\n\n  // When performing a negated assertion for both name and val, merely having\n  // a property with the given name isn't enough to cause the assertion to\n  // fail. It must both have a property with the given name, and the value of\n  // that property must equal the given val. Therefore, skip this assertion in\n  // favor of the next.\n  if (!negate || arguments.length === 1) {\n    this.assert(\n        hasProperty\n      , 'expected #{this} to have ' + descriptor + _.inspect(name)\n      , 'expected #{this} to not have ' + descriptor + _.inspect(name));\n  }\n\n  if (arguments.length > 1) {\n    this.assert(\n        hasProperty && (isDeep ? _.eql(val, value) : val === value)\n      , 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'\n      , 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}'\n      , val\n      , value\n    );\n  }\n\n  flag(this, 'object', value);\n}\n\nAssertion.addMethod('property', assertProperty);\n\nfunction assertOwnProperty (name, value, msg) {\n  flag(this, 'own', true);\n  assertProperty.apply(this, arguments);\n}\n\nAssertion.addMethod('ownProperty', assertOwnProperty);\nAssertion.addMethod('haveOwnProperty', assertOwnProperty);",
    "ctx": {
      "type": "function",
      "name": "assertProperty",
      "string": "assertProperty()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "ownPropertyDescriptor"
      },
      {
        "type": "alias",
        "string": "haveOwnPropertyDescriptor"
      },
      {
        "type": "param",
        "string": "{String} name",
        "name": "name",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} descriptor _optional_",
        "name": "descriptor",
        "description": "_optional_",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .ownPropertyDescriptor(name[, descriptor[, msg]])\n\nAsserts that the target has its own property descriptor with the given key\n`name`. Enumerable and non-enumerable properties are included in the\nsearch.\n\n    expect({a: 1}).to.have.ownPropertyDescriptor('a');\n\nWhen `descriptor` is provided, `.ownPropertyDescriptor` also asserts that\nthe property's descriptor is deeply equal to the given `descriptor`. See\nthe `deep-eql` project page for info on the deep equality algorithm:\nhttps://github.com/chaijs/deep-eql.\n\n    expect({a: 1}).to.have.ownPropertyDescriptor('a', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: 1,\n    });\n\nAdd `.not` earlier in the chain to negate `.ownPropertyDescriptor`.\n\n    expect({a: 1}).to.not.have.ownPropertyDescriptor('b');\n\nHowever, it's dangerous to negate `.ownPropertyDescriptor` when providing\na `descriptor`. The problem is that it creates uncertain expectations by\nasserting that the target either doesn't have a property descriptor with\nthe given key `name`, or that it does have a property descriptor with the\ngiven key `name` but its not deeply equal to the given `descriptor`. It's\noften best to identify the exact output that's expected, and then write an\nassertion that only accepts that exact output.\n\nWhen the target isn't expected to have a property descriptor with the given\nkey `name`, it's often best to assert exactly that.\n\n    // Recommended\n    expect({b: 2}).to.not.have.ownPropertyDescriptor('a');\n\n    // Not recommended\n    expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: 1,\n    });\n\nWhen the target is expected to have a property descriptor with the given\nkey `name`, it's often best to assert that the property has its expected\ndescriptor, rather than asserting that it doesn't have one of many\nunexpected descriptors.\n\n    // Recommended\n    expect({a: 3}).to.have.ownPropertyDescriptor('a', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: 3,\n    });\n\n    // Not recommended\n    expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: 1,\n    });\n\n`.ownPropertyDescriptor` changes the target of any assertions that follow\nin the chain to be the value of the property descriptor from the original\ntarget object.\n\n    expect({a: 1}).to.have.ownPropertyDescriptor('a')\n      .that.has.property('enumerable', true);\n\n`.ownPropertyDescriptor` accepts an optional `msg` argument which is a\ncustom error message to show when the assertion fails. The message can also\nbe given as the second argument to `expect`. When not providing\n`descriptor`, only use the second form.\n\n    // Recommended\n    expect({a: 1}).to.have.ownPropertyDescriptor('a', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: 2,\n    }, 'nooo why fail??');\n\n    // Recommended\n    expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: 2,\n    });\n\n    // Recommended\n    expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');\n\n    // Not recommended\n    expect({a: 1})\n      .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');\n\nThe above assertion isn't the same thing as not providing `descriptor`.\nInstead, it's asserting that the target object has a `b` property\ndescriptor that's deeply equal to `undefined`.\n\nThe alias `.haveOwnPropertyDescriptor` can be used interchangeably with\n`.ownPropertyDescriptor`.",
      "summary": "### .ownPropertyDescriptor(name[, descriptor[, msg]])",
      "body": "Asserts that the target has its own property descriptor with the given key\n`name`. Enumerable and non-enumerable properties are included in the\nsearch.\n\n    expect({a: 1}).to.have.ownPropertyDescriptor('a');\n\nWhen `descriptor` is provided, `.ownPropertyDescriptor` also asserts that\nthe property's descriptor is deeply equal to the given `descriptor`. See\nthe `deep-eql` project page for info on the deep equality algorithm:\nhttps://github.com/chaijs/deep-eql.\n\n    expect({a: 1}).to.have.ownPropertyDescriptor('a', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: 1,\n    });\n\nAdd `.not` earlier in the chain to negate `.ownPropertyDescriptor`.\n\n    expect({a: 1}).to.not.have.ownPropertyDescriptor('b');\n\nHowever, it's dangerous to negate `.ownPropertyDescriptor` when providing\na `descriptor`. The problem is that it creates uncertain expectations by\nasserting that the target either doesn't have a property descriptor with\nthe given key `name`, or that it does have a property descriptor with the\ngiven key `name` but its not deeply equal to the given `descriptor`. It's\noften best to identify the exact output that's expected, and then write an\nassertion that only accepts that exact output.\n\nWhen the target isn't expected to have a property descriptor with the given\nkey `name`, it's often best to assert exactly that.\n\n    // Recommended\n    expect({b: 2}).to.not.have.ownPropertyDescriptor('a');\n\n    // Not recommended\n    expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: 1,\n    });\n\nWhen the target is expected to have a property descriptor with the given\nkey `name`, it's often best to assert that the property has its expected\ndescriptor, rather than asserting that it doesn't have one of many\nunexpected descriptors.\n\n    // Recommended\n    expect({a: 3}).to.have.ownPropertyDescriptor('a', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: 3,\n    });\n\n    // Not recommended\n    expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: 1,\n    });\n\n`.ownPropertyDescriptor` changes the target of any assertions that follow\nin the chain to be the value of the property descriptor from the original\ntarget object.\n\n    expect({a: 1}).to.have.ownPropertyDescriptor('a')\n      .that.has.property('enumerable', true);\n\n`.ownPropertyDescriptor` accepts an optional `msg` argument which is a\ncustom error message to show when the assertion fails. The message can also\nbe given as the second argument to `expect`. When not providing\n`descriptor`, only use the second form.\n\n    // Recommended\n    expect({a: 1}).to.have.ownPropertyDescriptor('a', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: 2,\n    }, 'nooo why fail??');\n\n    // Recommended\n    expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: 2,\n    });\n\n    // Recommended\n    expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');\n\n    // Not recommended\n    expect({a: 1})\n      .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');\n\nThe above assertion isn't the same thing as not providing `descriptor`.\nInstead, it's asserting that the target object has a `b` property\ndescriptor that's deeply equal to `undefined`.\n\nThe alias `.haveOwnPropertyDescriptor` can be used interchangeably with\n`.ownPropertyDescriptor`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2193,
    "codeStart": 2312,
    "code": "function assertOwnPropertyDescriptor (name, descriptor, msg) {\n  if (typeof descriptor === 'string') {\n    msg = descriptor;\n    descriptor = null;\n  }\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);\n  if (actualDescriptor && descriptor) {\n    this.assert(\n        _.eql(descriptor, actualDescriptor)\n      , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)\n      , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)\n      , descriptor\n      , actualDescriptor\n      , true\n    );\n  } else {\n    this.assert(\n        actualDescriptor\n      , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)\n      , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)\n    );\n  }\n  flag(this, 'object', actualDescriptor);\n}\n\nAssertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);\nAssertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);",
    "ctx": {
      "type": "function",
      "name": "assertOwnPropertyDescriptor",
      "string": "assertOwnPropertyDescriptor()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "lengthOf"
      },
      {
        "type": "alias",
        "string": "length"
      },
      {
        "type": "param",
        "string": "{Number} n",
        "name": "n",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .lengthOf(n[, msg])\n\nAsserts that the target's `length` property is equal to the given number\n`n`.\n\n    expect([1, 2, 3]).to.have.lengthOf(3);\n    expect('foo').to.have.lengthOf(3);\n\nAdd `.not` earlier in the chain to negate `.lengthOf`. However, it's often\nbest to assert that the target's `length` property is equal to its expected\nvalue, rather than not equal to one of many unexpected values.\n\n    expect('foo').to.have.lengthOf(3); // Recommended\n    expect('foo').to.not.have.lengthOf(4); // Not recommended\n\n`.lengthOf` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');\n    expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);\n\n`.lengthOf` can also be used as a language chain, causing all `.above`,\n`.below`, `.least`, `.most`, and `.within` assertions that follow in the\nchain to use the target's `length` property as the target. However, it's\noften best to assert that the target's `length` property is equal to its\nexpected length, rather than asserting that its `length` property falls\nwithin some range of values.\n\n    // Recommended\n    expect([1, 2, 3]).to.have.lengthOf(3);\n\n    // Not recommended\n    expect([1, 2, 3]).to.have.lengthOf.above(2);\n    expect([1, 2, 3]).to.have.lengthOf.below(4);\n    expect([1, 2, 3]).to.have.lengthOf.at.least(3);\n    expect([1, 2, 3]).to.have.lengthOf.at.most(3);\n    expect([1, 2, 3]).to.have.lengthOf.within(2,4);\n\nDue to a compatibility issue, the alias `.length` can't be chained directly\noff of an uninvoked method such as `.a`. Therefore, `.length` can't be used\ninterchangeably with `.lengthOf` in every situation. It's recommended to\nalways use `.lengthOf` instead of `.length`.\n\n    expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error\n    expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected",
      "summary": "### .lengthOf(n[, msg])",
      "body": "Asserts that the target's `length` property is equal to the given number\n`n`.\n\n    expect([1, 2, 3]).to.have.lengthOf(3);\n    expect('foo').to.have.lengthOf(3);\n\nAdd `.not` earlier in the chain to negate `.lengthOf`. However, it's often\nbest to assert that the target's `length` property is equal to its expected\nvalue, rather than not equal to one of many unexpected values.\n\n    expect('foo').to.have.lengthOf(3); // Recommended\n    expect('foo').to.not.have.lengthOf(4); // Not recommended\n\n`.lengthOf` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');\n    expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);\n\n`.lengthOf` can also be used as a language chain, causing all `.above`,\n`.below`, `.least`, `.most`, and `.within` assertions that follow in the\nchain to use the target's `length` property as the target. However, it's\noften best to assert that the target's `length` property is equal to its\nexpected length, rather than asserting that its `length` property falls\nwithin some range of values.\n\n    // Recommended\n    expect([1, 2, 3]).to.have.lengthOf(3);\n\n    // Not recommended\n    expect([1, 2, 3]).to.have.lengthOf.above(2);\n    expect([1, 2, 3]).to.have.lengthOf.below(4);\n    expect([1, 2, 3]).to.have.lengthOf.at.least(3);\n    expect([1, 2, 3]).to.have.lengthOf.at.most(3);\n    expect([1, 2, 3]).to.have.lengthOf.within(2,4);\n\nDue to a compatibility issue, the alias `.length` can't be chained directly\noff of an uninvoked method such as `.a`. Therefore, `.length` can't be used\ninterchangeably with `.lengthOf` in every situation. It's recommended to\nalways use `.lengthOf` instead of `.length`.\n\n    expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error\n    expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2342,
    "codeStart": 2398,
    "code": "function assertLengthChain () {\n  flag(this, 'doLength', true);\n}\n\nfunction assertLength (n, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object')\n    , flagMsg = flag(this, 'message')\n    , ssfi = flag(this, 'ssfi');\n  new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n  var len = obj.length;\n\n  this.assert(\n      len == n\n    , 'expected #{this} to have a length of #{exp} but got #{act}'\n    , 'expected #{this} to not have a length of #{act}'\n    , n\n    , len\n  );\n}\n\nAssertion.addChainableMethod('length', assertLength, assertLengthChain);\nAssertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);",
    "ctx": {
      "type": "function",
      "name": "assertLengthChain",
      "string": "assertLengthChain()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "match"
      },
      {
        "type": "alias",
        "string": "matches"
      },
      {
        "type": "param",
        "string": "{RegExp} re",
        "name": "re",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .match(re[, msg])\n\nAsserts that the target matches the given regular expression `re`.\n\n    expect('foobar').to.match(/^foo/);\n\nAdd `.not` earlier in the chain to negate `.match`.\n\n    expect('foobar').to.not.match(/taco/);\n\n`.match` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect('foobar').to.match(/taco/, 'nooo why fail??');\n    expect('foobar', 'nooo why fail??').to.match(/taco/);\n\nThe alias `.matches` can be used interchangeably with `.match`.",
      "summary": "### .match(re[, msg])",
      "body": "Asserts that the target matches the given regular expression `re`.\n\n    expect('foobar').to.match(/^foo/);\n\nAdd `.not` earlier in the chain to negate `.match`.\n\n    expect('foobar').to.not.match(/taco/);\n\n`.match` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect('foobar').to.match(/taco/, 'nooo why fail??');\n    expect('foobar', 'nooo why fail??').to.match(/taco/);\n\nThe alias `.matches` can be used interchangeably with `.match`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2422,
    "codeStart": 2449,
    "code": "function assertMatch(re, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  this.assert(\n      re.exec(obj)\n    , 'expected #{this} to match ' + re\n    , 'expected #{this} not to match ' + re\n  );\n}\n\nAssertion.addMethod('match', assertMatch);\nAssertion.addMethod('matches', assertMatch);",
    "ctx": {
      "type": "function",
      "name": "assertMatch",
      "string": "assertMatch()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "string"
      },
      {
        "type": "param",
        "string": "{String} str",
        "name": "str",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .string(str[, msg])\n\nAsserts that the target string contains the given substring `str`.\n\n    expect('foobar').to.have.string('bar');\n\nAdd `.not` earlier in the chain to negate `.string`.\n\n    expect('foobar').to.not.have.string('taco');\n\n`.string` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect('foobar').to.have.string(/taco/, 'nooo why fail??');\n    expect('foobar', 'nooo why fail??').to.have.string(/taco/);",
      "summary": "### .string(str[, msg])",
      "body": "Asserts that the target string contains the given substring `str`.\n\n    expect('foobar').to.have.string('bar');\n\nAdd `.not` earlier in the chain to negate `.string`.\n\n    expect('foobar').to.not.have.string('taco');\n\n`.string` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect('foobar').to.have.string(/taco/, 'nooo why fail??');\n    expect('foobar', 'nooo why fail??').to.have.string(/taco/);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2462,
    "codeStart": 2487,
    "code": "Assertion.addMethod('string', function (str, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object')\n    , flagMsg = flag(this, 'message')\n    , ssfi = flag(this, 'ssfi');\n  new Assertion(obj, flagMsg, ssfi, true).is.a('string');\n\n  this.assert(\n      ~obj.indexOf(str)\n    , 'expected #{this} to contain ' + _.inspect(str)\n    , 'expected #{this} to not contain ' + _.inspect(str)\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "keys"
      },
      {
        "type": "alias",
        "string": "key"
      },
      {
        "type": "param",
        "string": "{...String|Array|Object} keys",
        "name": "keys",
        "description": "",
        "types": [
          "String",
          "Array",
          "Object"
        ],
        "typesDescription": "...<code>String</code>|<code>Array</code>|<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": true
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .keys(key1[, key2[, ...]])\n\nAsserts that the target object, array, map, or set has the given keys. Only\nthe target's own inherited properties are included in the search. \n\nWhen the target is an object or array, keys can be provided as one or more\nstring arguments, a single array argument, or a single object argument. In\nthe latter case, only the keys in the given object matter; the values are\nignored.\n\n    expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n    expect(['x', 'y']).to.have.all.keys(0, 1);\n\n    expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);\n    expect(['x', 'y']).to.have.all.keys([0, 1]);\n\n    expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5\n    expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5\n\nWhen the target is a map or set, each key must be provided as a separate\nargument.\n\n    expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');\n    expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');\n\nBecause `.keys` does different things based on the target's type, it's\nimportant to check the target's type before using `.keys`. See the `.a` doc\nfor info on testing a target's type.\n\n    expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');\n\nBy default, strict (`===`) equality is used to compare keys of maps and\nsets. Add `.deep` earlier in the chain to use deep equality instead. See\nthe `deep-eql` project page for info on the deep equality algorithm:\nhttps://github.com/chaijs/deep-eql.\n\n    // Target set deeply (but not strictly) has key `{a: 1}`\n    expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);\n    expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);\n\nBy default, the target must have all of the given keys and no more. Add\n`.any` earlier in the chain to only require that the target have at least\none of the given keys. Also, add `.not` earlier in the chain to negate\n`.keys`. It's often best to add `.any` when negating `.keys`, and to use\n`.all` when asserting `.keys` without negation.\n\nWhen negating `.keys`, `.any` is preferred because `.not.any.keys` asserts\nexactly what's expected of the output, whereas `.not.all.keys` creates\nuncertain expectations.\n\n    // Recommended; asserts that target doesn't have any of the given keys\n    expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');\n\n    // Not recommended; asserts that target doesn't have all of the given\n    // keys but may or may not have some of them\n    expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');\n\nWhen asserting `.keys` without negation, `.all` is preferred because\n`.all.keys` asserts exactly what's expected of the output, whereas\n`.any.keys` creates uncertain expectations.\n\n    // Recommended; asserts that target has all the given keys\n    expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n\n    // Not recommended; asserts that target has at least one of the given\n    // keys but may or may not have more of them\n    expect({a: 1, b: 2}).to.have.any.keys('a', 'b');\n\nNote that `.all` is used by default when neither `.all` nor `.any` appear\nearlier in the chain. However, it's often best to add `.all` anyway because\nit improves readability.\n\n    // Both assertions are identical\n    expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended\n    expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended\n\nAdd `.include` earlier in the chain to require that the target's keys be a\nsuperset of the expected keys, rather than identical sets.\n\n    // Target object's keys are a superset of ['a', 'b'] but not identical\n    expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');\n    expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');\n\nHowever, if `.any` and `.include` are combined, only the `.any` takes\neffect. The `.include` is ignored in this case.\n\n    // Both assertions are identical\n    expect({a: 1}).to.have.any.keys('a', 'b');\n    expect({a: 1}).to.include.any.keys('a', 'b');\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect({a: 1}, 'nooo why fail??').to.have.key('b');\n\nThe alias `.key` can be used interchangeably with `.keys`.",
      "summary": "### .keys(key1[, key2[, ...]])",
      "body": "Asserts that the target object, array, map, or set has the given keys. Only\nthe target's own inherited properties are included in the search. \n\nWhen the target is an object or array, keys can be provided as one or more\nstring arguments, a single array argument, or a single object argument. In\nthe latter case, only the keys in the given object matter; the values are\nignored.\n\n    expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n    expect(['x', 'y']).to.have.all.keys(0, 1);\n\n    expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);\n    expect(['x', 'y']).to.have.all.keys([0, 1]);\n\n    expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5\n    expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5\n\nWhen the target is a map or set, each key must be provided as a separate\nargument.\n\n    expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');\n    expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');\n\nBecause `.keys` does different things based on the target's type, it's\nimportant to check the target's type before using `.keys`. See the `.a` doc\nfor info on testing a target's type.\n\n    expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');\n\nBy default, strict (`===`) equality is used to compare keys of maps and\nsets. Add `.deep` earlier in the chain to use deep equality instead. See\nthe `deep-eql` project page for info on the deep equality algorithm:\nhttps://github.com/chaijs/deep-eql.\n\n    // Target set deeply (but not strictly) has key `{a: 1}`\n    expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);\n    expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);\n\nBy default, the target must have all of the given keys and no more. Add\n`.any` earlier in the chain to only require that the target have at least\none of the given keys. Also, add `.not` earlier in the chain to negate\n`.keys`. It's often best to add `.any` when negating `.keys`, and to use\n`.all` when asserting `.keys` without negation.\n\nWhen negating `.keys`, `.any` is preferred because `.not.any.keys` asserts\nexactly what's expected of the output, whereas `.not.all.keys` creates\nuncertain expectations.\n\n    // Recommended; asserts that target doesn't have any of the given keys\n    expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');\n\n    // Not recommended; asserts that target doesn't have all of the given\n    // keys but may or may not have some of them\n    expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');\n\nWhen asserting `.keys` without negation, `.all` is preferred because\n`.all.keys` asserts exactly what's expected of the output, whereas\n`.any.keys` creates uncertain expectations.\n\n    // Recommended; asserts that target has all the given keys\n    expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n\n    // Not recommended; asserts that target has at least one of the given\n    // keys but may or may not have more of them\n    expect({a: 1, b: 2}).to.have.any.keys('a', 'b');\n\nNote that `.all` is used by default when neither `.all` nor `.any` appear\nearlier in the chain. However, it's often best to add `.all` anyway because\nit improves readability.\n\n    // Both assertions are identical\n    expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended\n    expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended\n\nAdd `.include` earlier in the chain to require that the target's keys be a\nsuperset of the expected keys, rather than identical sets.\n\n    // Target object's keys are a superset of ['a', 'b'] but not identical\n    expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');\n    expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');\n\nHowever, if `.any` and `.include` are combined, only the `.any` takes\neffect. The `.include` is ignored in this case.\n\n    // Both assertions are identical\n    expect({a: 1}).to.have.any.keys('a', 'b');\n    expect({a: 1}).to.include.any.keys('a', 'b');\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect({a: 1}, 'nooo why fail??').to.have.key('b');\n\nThe alias `.key` can be used interchangeably with `.keys`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2501,
    "codeStart": 2605,
    "code": "function assertKeys (keys) {\n  var obj = flag(this, 'object')\n    , objType = _.type(obj)\n    , keysType = _.type(keys)\n    , ssfi = flag(this, 'ssfi')\n    , isDeep = flag(this, 'deep')\n    , str\n    , deepStr = ''\n    , ok = true\n    , flagMsg = flag(this, 'message');\n\n  flagMsg = flagMsg ? flagMsg + ': ' : '';\n  var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';\n\n  if (objType === 'Map' || objType === 'Set') {\n    deepStr = isDeep ? 'deeply ' : '';\n    actual = [];\n\n    // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.\n    obj.forEach(function (val, key) { actual.push(key) });\n\n    if (keysType !== 'Array') {\n      keys = Array.prototype.slice.call(arguments);\n    }\n\n  } else {\n    actual = _.getOwnEnumerableProperties(obj);\n\n    switch (keysType) {\n      case 'Array':\n        if (arguments.length > 1) {\n          throw new AssertionError(mixedArgsMsg, undefined, ssfi);\n        }\n        break;\n      case 'Object':\n        if (arguments.length > 1) {\n          throw new AssertionError(mixedArgsMsg, undefined, ssfi);\n        }\n        keys = Object.keys(keys);\n        break;\n      default:\n        keys = Array.prototype.slice.call(arguments);\n    }\n\n    // Only stringify non-Symbols because Symbols would become \"Symbol()\"\n    keys = keys.map(function (val) {\n      return typeof val === 'symbol' ? val : String(val);\n    });\n  }\n\n  if (!keys.length) {\n    throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);\n  }\n\n  var len = keys.length\n    , any = flag(this, 'any')\n    , all = flag(this, 'all')\n    , expected = keys\n    , actual;\n\n  if (!any && !all) {\n    all = true;\n  }\n\n  // Has any\n  if (any) {\n    ok = expected.some(function(expectedKey) {\n      return actual.some(function(actualKey) {\n        if (isDeep) {\n          return _.eql(expectedKey, actualKey);\n        } else {\n          return expectedKey === actualKey;\n        }\n      });\n    });\n  }\n\n  // Has all\n  if (all) {\n    ok = expected.every(function(expectedKey) {\n      return actual.some(function(actualKey) {\n        if (isDeep) {\n          return _.eql(expectedKey, actualKey);\n        } else {\n          return expectedKey === actualKey;\n        }\n      });\n    });\n\n    if (!flag(this, 'contains')) {\n      ok = ok && keys.length == actual.length;\n    }\n  }\n\n  // Key string\n  if (len > 1) {\n    keys = keys.map(function(key) {\n      return _.inspect(key);\n    });\n    var last = keys.pop();\n    if (all) {\n      str = keys.join(', ') + ', and ' + last;\n    }\n    if (any) {\n      str = keys.join(', ') + ', or ' + last;\n    }\n  } else {\n    str = _.inspect(keys[0]);\n  }\n\n  // Form\n  str = (len > 1 ? 'keys ' : 'key ') + str;\n\n  // Have / include\n  str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\n\n  // Assertion\n  this.assert(\n      ok\n    , 'expected #{this} to ' + deepStr + str\n    , 'expected #{this} to not ' + deepStr + str\n    , expected.slice(0).sort(_.compareByInspect)\n    , actual.sort(_.compareByInspect)\n    , true\n  );\n}\n\nAssertion.addMethod('keys', assertKeys);\nAssertion.addMethod('key', assertKeys);",
    "ctx": {
      "type": "function",
      "name": "assertKeys",
      "string": "assertKeys()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "throw"
      },
      {
        "type": "alias",
        "string": "throws"
      },
      {
        "type": "alias",
        "string": "Throw"
      },
      {
        "type": "param",
        "string": "{Error|ErrorConstructor} errorLike",
        "name": "errorLike",
        "description": "",
        "types": [
          "Error",
          "ErrorConstructor"
        ],
        "typesDescription": "<code>Error</code>|<a href=\"ErrorConstructor.html\">ErrorConstructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String|RegExp} errMsgMatcher error message",
        "name": "errMsgMatcher",
        "description": "error message",
        "types": [
          "String",
          "RegExp"
        ],
        "typesDescription": "<code>String</code>|<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "see",
        "string": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types",
        "title": "",
        "url": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types"
      },
      {
        "type": "returns",
        "string": "error for chaining (null if no error)",
        "types": [],
        "typesDescription": "",
        "variable": false,
        "nonNullable": false,
        "nullable": false,
        "optional": false,
        "description": "error for chaining (null if no error)"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .throw([errorLike], [errMsgMatcher], [msg])\n\nWhen no arguments are provided, `.throw` invokes the target function and\nasserts that an error is thrown.\n\n    var badFn = function () { throw new TypeError('Illegal salmon!'); };\n\n    expect(badFn).to.throw();\n\nWhen one argument is provided, and it's an error constructor, `.throw`\ninvokes the target function and asserts that an error is thrown that's an\ninstance of that error constructor.\n\n    var badFn = function () { throw new TypeError('Illegal salmon!'); };\n\n    expect(badFn).to.throw(TypeError);\n\nWhen one argument is provided, and it's an error instance, `.throw` invokes\nthe target function and asserts that an error is thrown that's strictly\n(`===`) equal to that error instance.\n\n    var err = new TypeError('Illegal salmon!');\n    var badFn = function () { throw err; };\n\n    expect(badFn).to.throw(err);\n\nWhen one argument is provided, and it's a string, `.throw` invokes the\ntarget function and asserts that an error is thrown with a message that\ncontains that string.\n\n    var badFn = function () { throw new TypeError('Illegal salmon!'); };\n\n    expect(badFn).to.throw('salmon');\n\nWhen one argument is provided, and it's a regular expression, `.throw`\ninvokes the target function and asserts that an error is thrown with a\nmessage that matches that regular expression.\n\n    var badFn = function () { throw new TypeError('Illegal salmon!'); };\n\n    expect(badFn).to.throw(/salmon/);\n\nWhen two arguments are provided, and the first is an error instance or\nconstructor, and the second is a string or regular expression, `.throw`\ninvokes the function and asserts that an error is thrown that fulfills both\nconditions as described above.\n\n    var err = new TypeError('Illegal salmon!');\n    var badFn = function () { throw err; };\n\n    expect(badFn).to.throw(TypeError, 'salmon');\n    expect(badFn).to.throw(TypeError, /salmon/);\n    expect(badFn).to.throw(err, 'salmon');\n    expect(badFn).to.throw(err, /salmon/);\n\nAdd `.not` earlier in the chain to negate `.throw`.\n    \n    var goodFn = function () {};\n\n    expect(goodFn).to.not.throw();\n\nHowever, it's dangerous to negate `.throw` when providing any arguments.\nThe problem is that it creates uncertain expectations by asserting that the\ntarget either doesn't throw an error, or that it throws an error but of a\ndifferent type than the given type, or that it throws an error of the given\ntype but with a message that doesn't include the given string. It's often\nbest to identify the exact output that's expected, and then write an\nassertion that only accepts that exact output.\n\nWhen the target isn't expected to throw an error, it's often best to assert\nexactly that.\n\n    var goodFn = function () {};\n\n    expect(goodFn).to.not.throw(); // Recommended\n    expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended\n\nWhen the target is expected to throw an error, it's often best to assert\nthat the error is of its expected type, and has a message that includes an\nexpected string, rather than asserting that it doesn't have one of many\nunexpected types, and doesn't have a message that includes some string.\n\n    var badFn = function () { throw new TypeError('Illegal salmon!'); };\n\n    expect(badFn).to.throw(TypeError, 'salmon'); // Recommended\n    expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended\n\n`.throw` changes the target of any assertions that follow in the chain to\nbe the error object that's thrown.\n\n    var err = new TypeError('Illegal salmon!');\n    err.code = 42;\n    var badFn = function () { throw err; };\n\n    expect(badFn).to.throw(TypeError).with.property('code', 42);\n\n`.throw` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`. When not providing two arguments, always use\nthe second form.\n\n    var goodFn = function () {};\n\n    expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');\n    expect(goodFn, 'nooo why fail??').to.throw();\n\nDue to limitations in ES5, `.throw` may not always work as expected when\nusing a transpiler such as Babel or TypeScript. In particular, it may\nproduce unexpected results when subclassing the built-in `Error` object and\nthen passing the subclassed constructor to `.throw`. See your transpiler's\ndocs for details:\n\n- ([Babel](https://babeljs.io/docs/usage/caveats/#classes))\n- ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))\n\nBeware of some common mistakes when using the `throw` assertion. One common\nmistake is to accidentally invoke the function yourself instead of letting\nthe `throw` assertion invoke the function for you. For example, when\ntesting if a function named `fn` throws, provide `fn` instead of `fn()` as\nthe target for the assertion.\n\n    expect(fn).to.throw();     // Good! Tests `fn` as desired\n    expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`\n\nIf you need to assert that your function `fn` throws when passed certain\narguments, then wrap a call to `fn` inside of another function.\n\n    expect(function () { fn(42); }).to.throw();  // Function expression\n    expect(() => fn(42)).to.throw();             // ES6 arrow function\n\nAnother common mistake is to provide an object method (or any stand-alone\nfunction that relies on `this`) as the target of the assertion. Doing so is\nproblematic because the `this` context will be lost when the function is\ninvoked by `.throw`; there's no way for it to know what `this` is supposed\nto be. There are two ways around this problem. One solution is to wrap the\nmethod or function call inside of another function. Another solution is to\nuse `bind`.\n\n    expect(function () { cat.meow(); }).to.throw();  // Function expression\n    expect(() => cat.meow()).to.throw();             // ES6 arrow function\n    expect(cat.meow.bind(cat)).to.throw();           // Bind\n\nFinally, it's worth mentioning that it's a best practice in JavaScript to\nonly throw `Error` and derivatives of `Error` such as `ReferenceError`,\n`TypeError`, and user-defined objects that extend `Error`. No other type of\nvalue will generate a stack trace when initialized. With that said, the\n`throw` assertion does technically support any type of value being thrown,\nnot just `Error` and its derivatives.\n\nThe aliases `.throws` and `.Throw` can be used interchangeably with\n`.throw`.",
      "summary": "### .throw([errorLike], [errMsgMatcher], [msg])",
      "body": "When no arguments are provided, `.throw` invokes the target function and\nasserts that an error is thrown.\n\n    var badFn = function () { throw new TypeError('Illegal salmon!'); };\n\n    expect(badFn).to.throw();\n\nWhen one argument is provided, and it's an error constructor, `.throw`\ninvokes the target function and asserts that an error is thrown that's an\ninstance of that error constructor.\n\n    var badFn = function () { throw new TypeError('Illegal salmon!'); };\n\n    expect(badFn).to.throw(TypeError);\n\nWhen one argument is provided, and it's an error instance, `.throw` invokes\nthe target function and asserts that an error is thrown that's strictly\n(`===`) equal to that error instance.\n\n    var err = new TypeError('Illegal salmon!');\n    var badFn = function () { throw err; };\n\n    expect(badFn).to.throw(err);\n\nWhen one argument is provided, and it's a string, `.throw` invokes the\ntarget function and asserts that an error is thrown with a message that\ncontains that string.\n\n    var badFn = function () { throw new TypeError('Illegal salmon!'); };\n\n    expect(badFn).to.throw('salmon');\n\nWhen one argument is provided, and it's a regular expression, `.throw`\ninvokes the target function and asserts that an error is thrown with a\nmessage that matches that regular expression.\n\n    var badFn = function () { throw new TypeError('Illegal salmon!'); };\n\n    expect(badFn).to.throw(/salmon/);\n\nWhen two arguments are provided, and the first is an error instance or\nconstructor, and the second is a string or regular expression, `.throw`\ninvokes the function and asserts that an error is thrown that fulfills both\nconditions as described above.\n\n    var err = new TypeError('Illegal salmon!');\n    var badFn = function () { throw err; };\n\n    expect(badFn).to.throw(TypeError, 'salmon');\n    expect(badFn).to.throw(TypeError, /salmon/);\n    expect(badFn).to.throw(err, 'salmon');\n    expect(badFn).to.throw(err, /salmon/);\n\nAdd `.not` earlier in the chain to negate `.throw`.\n    \n    var goodFn = function () {};\n\n    expect(goodFn).to.not.throw();\n\nHowever, it's dangerous to negate `.throw` when providing any arguments.\nThe problem is that it creates uncertain expectations by asserting that the\ntarget either doesn't throw an error, or that it throws an error but of a\ndifferent type than the given type, or that it throws an error of the given\ntype but with a message that doesn't include the given string. It's often\nbest to identify the exact output that's expected, and then write an\nassertion that only accepts that exact output.\n\nWhen the target isn't expected to throw an error, it's often best to assert\nexactly that.\n\n    var goodFn = function () {};\n\n    expect(goodFn).to.not.throw(); // Recommended\n    expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended\n\nWhen the target is expected to throw an error, it's often best to assert\nthat the error is of its expected type, and has a message that includes an\nexpected string, rather than asserting that it doesn't have one of many\nunexpected types, and doesn't have a message that includes some string.\n\n    var badFn = function () { throw new TypeError('Illegal salmon!'); };\n\n    expect(badFn).to.throw(TypeError, 'salmon'); // Recommended\n    expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended\n\n`.throw` changes the target of any assertions that follow in the chain to\nbe the error object that's thrown.\n\n    var err = new TypeError('Illegal salmon!');\n    err.code = 42;\n    var badFn = function () { throw err; };\n\n    expect(badFn).to.throw(TypeError).with.property('code', 42);\n\n`.throw` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`. When not providing two arguments, always use\nthe second form.\n\n    var goodFn = function () {};\n\n    expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');\n    expect(goodFn, 'nooo why fail??').to.throw();\n\nDue to limitations in ES5, `.throw` may not always work as expected when\nusing a transpiler such as Babel or TypeScript. In particular, it may\nproduce unexpected results when subclassing the built-in `Error` object and\nthen passing the subclassed constructor to `.throw`. See your transpiler's\ndocs for details:\n\n- ([Babel](https://babeljs.io/docs/usage/caveats/#classes))\n- ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))\n\nBeware of some common mistakes when using the `throw` assertion. One common\nmistake is to accidentally invoke the function yourself instead of letting\nthe `throw` assertion invoke the function for you. For example, when\ntesting if a function named `fn` throws, provide `fn` instead of `fn()` as\nthe target for the assertion.\n\n    expect(fn).to.throw();     // Good! Tests `fn` as desired\n    expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`\n\nIf you need to assert that your function `fn` throws when passed certain\narguments, then wrap a call to `fn` inside of another function.\n\n    expect(function () { fn(42); }).to.throw();  // Function expression\n    expect(() => fn(42)).to.throw();             // ES6 arrow function\n\nAnother common mistake is to provide an object method (or any stand-alone\nfunction that relies on `this`) as the target of the assertion. Doing so is\nproblematic because the `this` context will be lost when the function is\ninvoked by `.throw`; there's no way for it to know what `this` is supposed\nto be. There are two ways around this problem. One solution is to wrap the\nmethod or function call inside of another function. Another solution is to\nuse `bind`.\n\n    expect(function () { cat.meow(); }).to.throw();  // Function expression\n    expect(() => cat.meow()).to.throw();             // ES6 arrow function\n    expect(cat.meow.bind(cat)).to.throw();           // Bind\n\nFinally, it's worth mentioning that it's a best practice in JavaScript to\nonly throw `Error` and derivatives of `Error` such as `ReferenceError`,\n`TypeError`, and user-defined objects that extend `Error`. No other type of\nvalue will generate a stack trace when initialized. With that said, the\n`throw` assertion does technically support any type of value being thrown,\nnot just `Error` and its derivatives.\n\nThe aliases `.throws` and `.Throw` can be used interchangeably with\n`.throw`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 2735,
    "codeStart": 2900,
    "code": "function assertThrows (errorLike, errMsgMatcher, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object')\n    , ssfi = flag(this, 'ssfi')\n    , flagMsg = flag(this, 'message')\n    , negate = flag(this, 'negate') || false;\n  new Assertion(obj, flagMsg, ssfi, true).is.a('function');\n\n  if (errorLike instanceof RegExp || typeof errorLike === 'string') {\n    errMsgMatcher = errorLike;\n    errorLike = null;\n  }\n\n  var caughtErr;\n  try {\n    obj();\n  } catch (err) {\n    caughtErr = err;\n  }\n\n  // If we have the negate flag enabled and at least one valid argument it means we do expect an error\n  // but we want it to match a given set of criteria\n  var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined;\n\n  // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible\n  // See Issue #551 and PR #683@GitHub\n  var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);\n  var errorLikeFail = false;\n  var errMsgMatcherFail = false;\n\n  // Checking if error was thrown\n  if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {\n    // We need this to display results correctly according to their types\n    var errorLikeString = 'an error';\n    if (errorLike instanceof Error) {\n      errorLikeString = '#{exp}';\n    } else if (errorLike) {\n      errorLikeString = _.checkError.getConstructorName(errorLike);\n    }\n\n    this.assert(\n        caughtErr\n      , 'expected #{this} to throw ' + errorLikeString\n      , 'expected #{this} to not throw an error but #{act} was thrown'\n      , errorLike && errorLike.toString()\n      , (caughtErr instanceof Error ?\n          caughtErr.toString() : (typeof caughtErr === 'string' ? caughtErr : caughtErr &&\n                                  _.checkError.getConstructorName(caughtErr)))\n    );\n  }\n\n  if (errorLike && caughtErr) {\n    // We should compare instances only if `errorLike` is an instance of `Error`\n    if (errorLike instanceof Error) {\n      var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);\n\n      if (isCompatibleInstance === negate) {\n        // These checks were created to ensure we won't fail too soon when we've got both args and a negate\n        // See Issue #551 and PR #683@GitHub\n        if (everyArgIsDefined && negate) {\n          errorLikeFail = true;\n        } else {\n          this.assert(\n              negate\n            , 'expected #{this} to throw #{exp} but #{act} was thrown'\n            , 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : '')\n            , errorLike.toString()\n            , caughtErr.toString()\n          );\n        }\n      }\n    }\n\n    var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);\n    if (isCompatibleConstructor === negate) {\n      if (everyArgIsDefined && negate) {\n          errorLikeFail = true;\n      } else {\n        this.assert(\n            negate\n          , 'expected #{this} to throw #{exp} but #{act} was thrown'\n          , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')\n          , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))\n          , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))\n        );\n      }\n    }\n  }\n\n  if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {\n    // Here we check compatible messages\n    var placeholder = 'including';\n    if (errMsgMatcher instanceof RegExp) {\n      placeholder = 'matching'\n    }\n\n    var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);\n    if (isCompatibleMessage === negate) {\n      if (everyArgIsDefined && negate) {\n          errMsgMatcherFail = true;\n      } else {\n        this.assert(\n          negate\n          , 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}'\n          , 'expected #{this} to throw error not ' + placeholder + ' #{exp}'\n          ,  errMsgMatcher\n          ,  _.checkError.getMessage(caughtErr)\n        );\n      }\n    }\n  }\n\n  // If both assertions failed and both should've matched we throw an error\n  if (errorLikeFail && errMsgMatcherFail) {\n    this.assert(\n      negate\n      , 'expected #{this} to throw #{exp} but #{act} was thrown'\n      , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')\n      , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))\n      , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))\n    );\n  }\n\n  flag(this, 'object', caughtErr);\n};\n\nAssertion.addMethod('throw', assertThrows);\nAssertion.addMethod('throws', assertThrows);\nAssertion.addMethod('Throw', assertThrows);",
    "ctx": {
      "type": "function",
      "name": "assertThrows",
      "string": "assertThrows()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "respondTo"
      },
      {
        "type": "alias",
        "string": "respondsTo"
      },
      {
        "type": "param",
        "string": "{String} method",
        "name": "method",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .respondTo(method[, msg])\n\nWhen the target is a non-function object, `.respondTo` asserts that the\ntarget has a method with the given name `method`. The method can be own or\ninherited, and it can be enumerable or non-enumerable.\n\n    function Cat () {}\n    Cat.prototype.meow = function () {};\n\n    expect(new Cat()).to.respondTo('meow');\n\nWhen the target is a function, `.respondTo` asserts that the target's\n`prototype` property has a method with the given name `method`. Again, the\nmethod can be own or inherited, and it can be enumerable or non-enumerable.\n\n    function Cat () {}\n    Cat.prototype.meow = function () {};\n\n    expect(Cat).to.respondTo('meow');\n\nAdd `.itself` earlier in the chain to force `.respondTo` to treat the\ntarget as a non-function object, even if it's a function. Thus, it asserts\nthat the target has a method with the given name `method`, rather than\nasserting that the target's `prototype` property has a method with the\ngiven name `method`.\n\n    function Cat () {}\n    Cat.prototype.meow = function () {};\n    Cat.hiss = function () {};\n\n    expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');\n\nWhen not adding `.itself`, it's important to check the target's type before\nusing `.respondTo`. See the `.a` doc for info on checking a target's type.\n\n    function Cat () {}\n    Cat.prototype.meow = function () {};\n\n    expect(new Cat()).to.be.an('object').that.respondsTo('meow');\n\nAdd `.not` earlier in the chain to negate `.respondTo`.\n\n    function Dog () {}\n    Dog.prototype.bark = function () {};\n\n    expect(new Dog()).to.not.respondTo('meow');\n\n`.respondTo` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect({}).to.respondTo('meow', 'nooo why fail??');\n    expect({}, 'nooo why fail??').to.respondTo('meow');\n\nThe alias `.respondsTo` can be used interchangeably with `.respondTo`.",
      "summary": "### .respondTo(method[, msg])",
      "body": "When the target is a non-function object, `.respondTo` asserts that the\ntarget has a method with the given name `method`. The method can be own or\ninherited, and it can be enumerable or non-enumerable.\n\n    function Cat () {}\n    Cat.prototype.meow = function () {};\n\n    expect(new Cat()).to.respondTo('meow');\n\nWhen the target is a function, `.respondTo` asserts that the target's\n`prototype` property has a method with the given name `method`. Again, the\nmethod can be own or inherited, and it can be enumerable or non-enumerable.\n\n    function Cat () {}\n    Cat.prototype.meow = function () {};\n\n    expect(Cat).to.respondTo('meow');\n\nAdd `.itself` earlier in the chain to force `.respondTo` to treat the\ntarget as a non-function object, even if it's a function. Thus, it asserts\nthat the target has a method with the given name `method`, rather than\nasserting that the target's `prototype` property has a method with the\ngiven name `method`.\n\n    function Cat () {}\n    Cat.prototype.meow = function () {};\n    Cat.hiss = function () {};\n\n    expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');\n\nWhen not adding `.itself`, it's important to check the target's type before\nusing `.respondTo`. See the `.a` doc for info on checking a target's type.\n\n    function Cat () {}\n    Cat.prototype.meow = function () {};\n\n    expect(new Cat()).to.be.an('object').that.respondsTo('meow');\n\nAdd `.not` earlier in the chain to negate `.respondTo`.\n\n    function Dog () {}\n    Dog.prototype.bark = function () {};\n\n    expect(new Dog()).to.not.respondTo('meow');\n\n`.respondTo` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect({}).to.respondTo('meow', 'nooo why fail??');\n    expect({}, 'nooo why fail??').to.respondTo('meow');\n\nThe alias `.respondsTo` can be used interchangeably with `.respondTo`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3030,
    "codeStart": 3095,
    "code": "function respondTo (method, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object')\n    , itself = flag(this, 'itself')\n    , context = ('function' === typeof obj && !itself)\n      ? obj.prototype[method]\n      : obj[method];\n\n  this.assert(\n      'function' === typeof context\n    , 'expected #{this} to respond to ' + _.inspect(method)\n    , 'expected #{this} to not respond to ' + _.inspect(method)\n  );\n}\n\nAssertion.addMethod('respondTo', respondTo);\nAssertion.addMethod('respondsTo', respondTo);",
    "ctx": {
      "type": "function",
      "name": "respondTo",
      "string": "respondTo()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "itself"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .itself\n\nForces all `.respondTo` assertions that follow in the chain to behave as if\nthe target is a non-function object, even if it's a function. Thus, it\ncauses `.respondTo` to assert that the target has a method with the given\nname, rather than asserting that the target's `prototype` property has a\nmethod with the given name.\n\n    function Cat () {}\n    Cat.prototype.meow = function () {};\n    Cat.hiss = function () {};\n\n    expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');",
      "summary": "### .itself",
      "body": "Forces all `.respondTo` assertions that follow in the chain to behave as if\nthe target is a non-function object, even if it's a function. Thus, it\ncauses `.respondTo` to assert that the target has a method with the given\nname, rather than asserting that the target's `prototype` property has a\nmethod with the given name.\n\n    function Cat () {}\n    Cat.prototype.meow = function () {};\n    Cat.hiss = function () {};\n\n    expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3113,
    "codeStart": 3133,
    "code": "Assertion.addProperty('itself', function () {\n  flag(this, 'itself', true);\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "satisfy"
      },
      {
        "type": "alias",
        "string": "satisfies"
      },
      {
        "type": "param",
        "string": "{Function} matcher",
        "name": "matcher",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .satisfy(matcher[, msg])\n\nInvokes the given `matcher` function with the target being passed as the\nfirst argument, and asserts that the value returned is truthy.\n\n    expect(1).to.satisfy(function(num) {\n      return num > 0; \n    });\n\nAdd `.not` earlier in the chain to negate `.satisfy`.\n\n    expect(1).to.not.satisfy(function(num) {\n      return num > 2;\n    });\n\n`.satisfy` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect(1).to.satisfy(function(num) {\n      return num > 2;\n    }, 'nooo why fail??');\n\n    expect(1, 'nooo why fail??').to.satisfy(function(num) {\n      return num > 2;\n    });\n\nThe alias `.satisfies` can be used interchangeably with `.satisfy`.",
      "summary": "### .satisfy(matcher[, msg])",
      "body": "Invokes the given `matcher` function with the target being passed as the\nfirst argument, and asserts that the value returned is truthy.\n\n    expect(1).to.satisfy(function(num) {\n      return num > 0; \n    });\n\nAdd `.not` earlier in the chain to negate `.satisfy`.\n\n    expect(1).to.not.satisfy(function(num) {\n      return num > 2;\n    });\n\n`.satisfy` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect(1).to.satisfy(function(num) {\n      return num > 2;\n    }, 'nooo why fail??');\n\n    expect(1, 'nooo why fail??').to.satisfy(function(num) {\n      return num > 2;\n    });\n\nThe alias `.satisfies` can be used interchangeably with `.satisfy`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3137,
    "codeStart": 3175,
    "code": "function satisfy (matcher, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object');\n  var result = matcher(obj);\n  this.assert(\n      result\n    , 'expected #{this} to satisfy ' + _.objDisplay(matcher)\n    , 'expected #{this} to not satisfy' + _.objDisplay(matcher)\n    , flag(this, 'negate') ? false : true\n    , result\n  );\n}\n\nAssertion.addMethod('satisfy', satisfy);\nAssertion.addMethod('satisfies', satisfy);",
    "ctx": {
      "type": "function",
      "name": "satisfy",
      "string": "satisfy()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "closeTo"
      },
      {
        "type": "alias",
        "string": "approximately"
      },
      {
        "type": "param",
        "string": "{Number} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} delta",
        "name": "delta",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .closeTo(expected, delta[, msg])\n\nAsserts that the target is a number that's within a given +/- `delta` range\nof the given number `expected`. However, it's often best to assert that the\ntarget is equal to its expected value.\n\n    // Recommended\n    expect(1.5).to.equal(1.5);\n\n    // Not recommended\n    expect(1.5).to.be.closeTo(1, 0.5);\n    expect(1.5).to.be.closeTo(2, 0.5);\n    expect(1.5).to.be.closeTo(1, 1);\n\nAdd `.not` earlier in the chain to negate `.closeTo`.\n\n    expect(1.5).to.equal(1.5); // Recommended\n    expect(1.5).to.not.be.closeTo(3, 1); // Not recommended\n\n`.closeTo` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');\n    expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);\n\nThe alias `.approximately` can be used interchangeably with `.closeTo`.",
      "summary": "### .closeTo(expected, delta[, msg])",
      "body": "Asserts that the target is a number that's within a given +/- `delta` range\nof the given number `expected`. However, it's often best to assert that the\ntarget is equal to its expected value.\n\n    // Recommended\n    expect(1.5).to.equal(1.5);\n\n    // Not recommended\n    expect(1.5).to.be.closeTo(1, 0.5);\n    expect(1.5).to.be.closeTo(2, 0.5);\n    expect(1.5).to.be.closeTo(1, 1);\n\nAdd `.not` earlier in the chain to negate `.closeTo`.\n\n    expect(1.5).to.equal(1.5); // Recommended\n    expect(1.5).to.not.be.closeTo(3, 1); // Not recommended\n\n`.closeTo` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');\n    expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);\n\nThe alias `.approximately` can be used interchangeably with `.closeTo`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3191,
    "codeStart": 3229,
    "code": "function closeTo(expected, delta, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object')\n    , flagMsg = flag(this, 'message')\n    , ssfi = flag(this, 'ssfi');\n\n  new Assertion(obj, flagMsg, ssfi, true).is.a('number');\n  if (typeof expected !== 'number' || typeof delta !== 'number') {\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n    throw new AssertionError(\n        flagMsg + 'the arguments to closeTo or approximately must be numbers',\n        undefined,\n        ssfi\n    );\n  }\n\n  this.assert(\n      Math.abs(obj - expected) <= delta\n    , 'expected #{this} to be close to ' + expected + ' +/- ' + delta\n    , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta\n  );\n}\n\nAssertion.addMethod('closeTo', closeTo);\nAssertion.addMethod('approximately', closeTo);\n\n// Note: Duplicates are ignored if testing for inclusion instead of sameness.\nfunction isSubsetOf(subset, superset, cmp, contains, ordered) {\n  if (!contains) {\n    if (subset.length !== superset.length) return false;\n    superset = superset.slice();\n  }\n\n  return subset.every(function(elem, idx) {\n    if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];\n\n    if (!cmp) {\n      var matchIdx = superset.indexOf(elem);\n      if (matchIdx === -1) return false;\n\n      // Remove match from superset so not counted twice if duplicate in subset.\n      if (!contains) superset.splice(matchIdx, 1);\n      return true;\n    }\n\n    return superset.some(function(elem2, matchIdx) {\n      if (!cmp(elem, elem2)) return false;\n\n      // Remove match from superset so not counted twice if duplicate in subset.\n      if (!contains) superset.splice(matchIdx, 1);\n      return true;\n    });\n  });\n}",
    "ctx": {
      "type": "function",
      "name": "closeTo",
      "string": "closeTo()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "members"
      },
      {
        "type": "param",
        "string": "{Array} set",
        "name": "set",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .members(set[, msg])\n\nAsserts that the target array has the same members as the given array\n`set`.\n\n    expect([1, 2, 3]).to.have.members([2, 1, 3]);\n    expect([1, 2, 2]).to.have.members([2, 1, 2]);\n\nBy default, members are compared using strict (`===`) equality. Add `.deep`\nearlier in the chain to use deep equality instead. See the `deep-eql`\nproject page for info on the deep equality algorithm:\nhttps://github.com/chaijs/deep-eql.\n\n    // Target array deeply (but not strictly) has member `{a: 1}`\n    expect([{a: 1}]).to.have.deep.members([{a: 1}]);\n    expect([{a: 1}]).to.not.have.members([{a: 1}]);\n\nBy default, order doesn't matter. Add `.ordered` earlier in the chain to\nrequire that members appear in the same order.\n\n    expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);\n    expect([1, 2, 3]).to.have.members([2, 1, 3])\n      .but.not.ordered.members([2, 1, 3]);\n\nBy default, both arrays must be the same size. Add `.include` earlier in\nthe chain to require that the target's members be a superset of the\nexpected members. Note that duplicates are ignored in the subset when\n`.include` is added.\n\n    // Target array is a superset of [1, 2] but not identical\n    expect([1, 2, 3]).to.include.members([1, 2]);\n    expect([1, 2, 3]).to.not.have.members([1, 2]);\n\n    // Duplicates in the subset are ignored\n    expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);\n\n`.deep`, `.ordered`, and `.include` can all be combined. However, if\n`.include` and `.ordered` are combined, the ordering begins at the start of\nboth arrays.\n\n    expect([{a: 1}, {b: 2}, {c: 3}])\n      .to.include.deep.ordered.members([{a: 1}, {b: 2}])\n      .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);\n\nAdd `.not` earlier in the chain to negate `.members`. However, it's\ndangerous to do so. The problem is that it creates uncertain expectations\nby asserting that the target array doesn't have all of the same members as\nthe given array `set` but may or may not have some of them. It's often best\nto identify the exact output that's expected, and then write an assertion\nthat only accepts that exact output.\n\n    expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended\n    expect([1, 2]).to.not.have.members([3, 4]); // Not recommended\n\n`.members` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');\n    expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);",
      "summary": "### .members(set[, msg])",
      "body": "Asserts that the target array has the same members as the given array\n`set`.\n\n    expect([1, 2, 3]).to.have.members([2, 1, 3]);\n    expect([1, 2, 2]).to.have.members([2, 1, 2]);\n\nBy default, members are compared using strict (`===`) equality. Add `.deep`\nearlier in the chain to use deep equality instead. See the `deep-eql`\nproject page for info on the deep equality algorithm:\nhttps://github.com/chaijs/deep-eql.\n\n    // Target array deeply (but not strictly) has member `{a: 1}`\n    expect([{a: 1}]).to.have.deep.members([{a: 1}]);\n    expect([{a: 1}]).to.not.have.members([{a: 1}]);\n\nBy default, order doesn't matter. Add `.ordered` earlier in the chain to\nrequire that members appear in the same order.\n\n    expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);\n    expect([1, 2, 3]).to.have.members([2, 1, 3])\n      .but.not.ordered.members([2, 1, 3]);\n\nBy default, both arrays must be the same size. Add `.include` earlier in\nthe chain to require that the target's members be a superset of the\nexpected members. Note that duplicates are ignored in the subset when\n`.include` is added.\n\n    // Target array is a superset of [1, 2] but not identical\n    expect([1, 2, 3]).to.include.members([1, 2]);\n    expect([1, 2, 3]).to.not.have.members([1, 2]);\n\n    // Duplicates in the subset are ignored\n    expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);\n\n`.deep`, `.ordered`, and `.include` can all be combined. However, if\n`.include` and `.ordered` are combined, the ordering begins at the start of\nboth arrays.\n\n    expect([{a: 1}, {b: 2}, {c: 3}])\n      .to.include.deep.ordered.members([{a: 1}, {b: 2}])\n      .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);\n\nAdd `.not` earlier in the chain to negate `.members`. However, it's\ndangerous to do so. The problem is that it creates uncertain expectations\nby asserting that the target array doesn't have all of the same members as\nthe given array `set` but may or may not have some of them. It's often best\nto identify the exact output that's expected, and then write an assertion\nthat only accepts that exact output.\n\n    expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended\n    expect([1, 2]).to.not.have.members([3, 4]); // Not recommended\n\n`.members` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`.\n\n    expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');\n    expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3284,
    "codeStart": 3353,
    "code": "Assertion.addMethod('members', function (subset, msg) {\n  if (msg) flag(this, 'message', msg);\n  var obj = flag(this, 'object')\n    , flagMsg = flag(this, 'message')\n    , ssfi = flag(this, 'ssfi');\n\n  new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');\n  new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');\n\n  var contains = flag(this, 'contains');\n  var ordered = flag(this, 'ordered');\n\n  var subject, failMsg, failNegateMsg, lengthCheck;\n\n  if (contains) {\n    subject = ordered ? 'an ordered superset' : 'a superset';\n    failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';\n    failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';\n  } else {\n    subject = ordered ? 'ordered members' : 'members';\n    failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';\n    failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';\n  }\n\n  var cmp = flag(this, 'deep') ? _.eql : undefined;\n\n  this.assert(\n      isSubsetOf(subset, obj, cmp, contains, ordered)\n    , failMsg\n    , failNegateMsg\n    , subset\n    , obj\n    , true\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "oneOf"
      },
      {
        "type": "param",
        "string": "{Array<*>} list",
        "name": "list",
        "description": "",
        "types": [
          "Array.<*>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>*</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .oneOf(list[, msg])\n\nAsserts that the target is a member of the given array `list`. However,\nit's often best to assert that the target is equal to its expected value.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.be.oneOf([1, 2, 3]); // Not recommended\n\nComparisons are performed using strict (`===`) equality.\n\nAdd `.not` earlier in the chain to negate `.oneOf`.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended\n\n`.oneOf` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');\n    expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);",
      "summary": "### .oneOf(list[, msg])",
      "body": "Asserts that the target is a member of the given array `list`. However,\nit's often best to assert that the target is equal to its expected value.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.be.oneOf([1, 2, 3]); // Not recommended\n\nComparisons are performed using strict (`===`) equality.\n\nAdd `.not` earlier in the chain to negate `.oneOf`.\n\n    expect(1).to.equal(1); // Recommended\n    expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended\n\n`.oneOf` accepts an optional `msg` argument which is a custom error message\nto show when the assertion fails. The message can also be given as the\nsecond argument to `expect`.\n\n    expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');\n    expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3389,
    "codeStart": 3419,
    "code": "function oneOf (list, msg) {\n  if (msg) flag(this, 'message', msg);\n  var expected = flag(this, 'object')\n    , flagMsg = flag(this, 'message')\n    , ssfi = flag(this, 'ssfi');\n  new Assertion(list, flagMsg, ssfi, true).to.be.an('array');\n\n  this.assert(\n      list.indexOf(expected) > -1\n    , 'expected #{this} to be one of #{exp}'\n    , 'expected #{this} to not be one of #{exp}'\n    , list\n    , expected\n  );\n}\n\nAssertion.addMethod('oneOf', oneOf);",
    "ctx": {
      "type": "function",
      "name": "oneOf",
      "string": "oneOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "change"
      },
      {
        "type": "alias",
        "string": "changes"
      },
      {
        "type": "param",
        "string": "{String} subject",
        "name": "subject",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} prop name _optional_",
        "name": "prop",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .change(subject[, prop[, msg]])\n\nWhen one argument is provided, `.change` asserts that the given function\n`subject` returns a different value when it's invoked before the target\nfunction compared to when it's invoked afterward. However, it's often best\nto assert that `subject` is equal to its expected value.\n\n    var dots = ''\n      , addDot = function () { dots += '.'; }\n      , getDots = function () { return dots; };\n\n    // Recommended\n    expect(getDots()).to.equal('');\n    addDot();\n    expect(getDots()).to.equal('.');\n\n    // Not recommended\n    expect(addDot).to.change(getDots);\n\nWhen two arguments are provided, `.change` asserts that the value of the\ngiven object `subject`'s `prop` property is different before invoking the\ntarget function compared to afterward.\n\n    var myObj = {dots: ''}\n      , addDot = function () { myObj.dots += '.'; };\n\n    // Recommended\n    expect(myObj).to.have.property('dots', '');\n    addDot();\n    expect(myObj).to.have.property('dots', '.');\n\n    // Not recommended\n    expect(addDot).to.change(myObj, 'dots');\n\nStrict (`===`) equality is used to compare before and after values.\n\nAdd `.not` earlier in the chain to negate `.change`.\n\n    var dots = ''\n      , noop = function () {}\n      , getDots = function () { return dots; };\n\n    expect(noop).to.not.change(getDots);\n\n    var myObj = {dots: ''}\n      , noop = function () {};\n\n    expect(noop).to.not.change(myObj, 'dots');\n\n`.change` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`. When not providing two arguments, always\nuse the second form.\n\n    var myObj = {dots: ''}\n      , addDot = function () { myObj.dots += '.'; };\n\n    expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');\n\n    var dots = ''\n      , addDot = function () { dots += '.'; }\n      , getDots = function () { return dots; };\n\n    expect(addDot, 'nooo why fail??').to.not.change(getDots);\n\n`.change` also causes all `.by` assertions that follow in the chain to\nassert how much a numeric subject was increased or decreased by. However,\nit's dangerous to use `.change.by`. The problem is that it creates\nuncertain expectations by asserting that the subject either increases by\nthe given delta, or that it decreases by the given delta. It's often best\nto identify the exact output that's expected, and then write an assertion\nthat only accepts that exact output.\n\n    var myObj = {val: 1}\n      , addTwo = function () { myObj.val += 2; }\n      , subtractTwo = function () { myObj.val -= 2; };\n\n    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n    expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended\n\n    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n    expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended\n\nThe alias `.changes` can be used interchangeably with `.change`.",
      "summary": "### .change(subject[, prop[, msg]])",
      "body": "When one argument is provided, `.change` asserts that the given function\n`subject` returns a different value when it's invoked before the target\nfunction compared to when it's invoked afterward. However, it's often best\nto assert that `subject` is equal to its expected value.\n\n    var dots = ''\n      , addDot = function () { dots += '.'; }\n      , getDots = function () { return dots; };\n\n    // Recommended\n    expect(getDots()).to.equal('');\n    addDot();\n    expect(getDots()).to.equal('.');\n\n    // Not recommended\n    expect(addDot).to.change(getDots);\n\nWhen two arguments are provided, `.change` asserts that the value of the\ngiven object `subject`'s `prop` property is different before invoking the\ntarget function compared to afterward.\n\n    var myObj = {dots: ''}\n      , addDot = function () { myObj.dots += '.'; };\n\n    // Recommended\n    expect(myObj).to.have.property('dots', '');\n    addDot();\n    expect(myObj).to.have.property('dots', '.');\n\n    // Not recommended\n    expect(addDot).to.change(myObj, 'dots');\n\nStrict (`===`) equality is used to compare before and after values.\n\nAdd `.not` earlier in the chain to negate `.change`.\n\n    var dots = ''\n      , noop = function () {}\n      , getDots = function () { return dots; };\n\n    expect(noop).to.not.change(getDots);\n\n    var myObj = {dots: ''}\n      , noop = function () {};\n\n    expect(noop).to.not.change(myObj, 'dots');\n\n`.change` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`. When not providing two arguments, always\nuse the second form.\n\n    var myObj = {dots: ''}\n      , addDot = function () { myObj.dots += '.'; };\n\n    expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');\n\n    var dots = ''\n      , addDot = function () { dots += '.'; }\n      , getDots = function () { return dots; };\n\n    expect(addDot, 'nooo why fail??').to.not.change(getDots);\n\n`.change` also causes all `.by` assertions that follow in the chain to\nassert how much a numeric subject was increased or decreased by. However,\nit's dangerous to use `.change.by`. The problem is that it creates\nuncertain expectations by asserting that the subject either increases by\nthe given delta, or that it decreases by the given delta. It's often best\nto identify the exact output that's expected, and then write an assertion\nthat only accepts that exact output.\n\n    var myObj = {val: 1}\n      , addTwo = function () { myObj.val += 2; }\n      , subtractTwo = function () { myObj.val -= 2; };\n\n    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n    expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended\n\n    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n    expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended\n\nThe alias `.changes` can be used interchangeably with `.change`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3438,
    "codeStart": 3533,
    "code": "function assertChanges (subject, prop, msg) {\n  if (msg) flag(this, 'message', msg);\n  var fn = flag(this, 'object')\n    , flagMsg = flag(this, 'message')\n    , ssfi = flag(this, 'ssfi');\n  new Assertion(fn, flagMsg, ssfi, true).is.a('function');\n\n  var initial;\n  if (!prop) {\n    new Assertion(subject, flagMsg, ssfi, true).is.a('function');\n    initial = subject();\n  } else {\n    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\n    initial = subject[prop];\n  }\n\n  fn();\n\n  var final = prop === undefined || prop === null ? subject() : subject[prop];\n  var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\n\n  // This gets flagged because of the .by(delta) assertion\n  flag(this, 'deltaMsgObj', msgObj);\n  flag(this, 'initialDeltaValue', initial);\n  flag(this, 'finalDeltaValue', final);\n  flag(this, 'deltaBehavior', 'change');\n  flag(this, 'realDelta', final !== initial);\n\n  this.assert(\n    initial !== final\n    , 'expected ' + msgObj + ' to change'\n    , 'expected ' + msgObj + ' to not change'\n  );\n}\n\nAssertion.addMethod('change', assertChanges);\nAssertion.addMethod('changes', assertChanges);",
    "ctx": {
      "type": "function",
      "name": "assertChanges",
      "string": "assertChanges()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "increase"
      },
      {
        "type": "alias",
        "string": "increases"
      },
      {
        "type": "param",
        "string": "{String|Function} subject",
        "name": "subject",
        "description": "",
        "types": [
          "String",
          "Function"
        ],
        "typesDescription": "<code>String</code>|<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} prop name _optional_",
        "name": "prop",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .increase(subject[, prop[, msg]])\n\nWhen one argument is provided, `.increase` asserts that the given function\n`subject` returns a greater number when it's invoked after invoking the\ntarget function compared to when it's invoked beforehand. `.increase` also\ncauses all `.by` assertions that follow in the chain to assert how much\ngreater of a number is returned. It's often best to assert that the return\nvalue increased by the expected amount, rather than asserting it increased\nby any amount.\n\n    var val = 1\n      , addTwo = function () { val += 2; }\n      , getVal = function () { return val; };\n\n    expect(addTwo).to.increase(getVal).by(2); // Recommended\n    expect(addTwo).to.increase(getVal); // Not recommended\n\nWhen two arguments are provided, `.increase` asserts that the value of the\ngiven object `subject`'s `prop` property is greater after invoking the\ntarget function compared to beforehand.\n\n    var myObj = {val: 1}\n      , addTwo = function () { myObj.val += 2; };\n\n    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n    expect(addTwo).to.increase(myObj, 'val'); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.increase`. However, it's\ndangerous to do so. The problem is that it creates uncertain expectations\nby asserting that the subject either decreases, or that it stays the same.\nIt's often best to identify the exact output that's expected, and then\nwrite an assertion that only accepts that exact output.\n\nWhen the subject is expected to decrease, it's often best to assert that it\ndecreased by the expected amount.\n\n    var myObj = {val: 1}\n      , subtractTwo = function () { myObj.val -= 2; };\n\n    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n    expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended\n\nWhen the subject is expected to stay the same, it's often best to assert\nexactly that.\n\n    var myObj = {val: 1}\n      , noop = function () {};\n\n    expect(noop).to.not.change(myObj, 'val'); // Recommended\n    expect(noop).to.not.increase(myObj, 'val'); // Not recommended\n\n`.increase` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`. When not providing two arguments, always\nuse the second form.\n\n    var myObj = {val: 1}\n      , noop = function () {};\n\n    expect(noop).to.increase(myObj, 'val', 'nooo why fail??');\n\n    var val = 1\n      , noop = function () {}\n      , getVal = function () { return val; };\n\n    expect(noop, 'nooo why fail??').to.increase(getVal);\n\nThe alias `.increases` can be used interchangeably with `.increase`.",
      "summary": "### .increase(subject[, prop[, msg]])",
      "body": "When one argument is provided, `.increase` asserts that the given function\n`subject` returns a greater number when it's invoked after invoking the\ntarget function compared to when it's invoked beforehand. `.increase` also\ncauses all `.by` assertions that follow in the chain to assert how much\ngreater of a number is returned. It's often best to assert that the return\nvalue increased by the expected amount, rather than asserting it increased\nby any amount.\n\n    var val = 1\n      , addTwo = function () { val += 2; }\n      , getVal = function () { return val; };\n\n    expect(addTwo).to.increase(getVal).by(2); // Recommended\n    expect(addTwo).to.increase(getVal); // Not recommended\n\nWhen two arguments are provided, `.increase` asserts that the value of the\ngiven object `subject`'s `prop` property is greater after invoking the\ntarget function compared to beforehand.\n\n    var myObj = {val: 1}\n      , addTwo = function () { myObj.val += 2; };\n\n    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n    expect(addTwo).to.increase(myObj, 'val'); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.increase`. However, it's\ndangerous to do so. The problem is that it creates uncertain expectations\nby asserting that the subject either decreases, or that it stays the same.\nIt's often best to identify the exact output that's expected, and then\nwrite an assertion that only accepts that exact output.\n\nWhen the subject is expected to decrease, it's often best to assert that it\ndecreased by the expected amount.\n\n    var myObj = {val: 1}\n      , subtractTwo = function () { myObj.val -= 2; };\n\n    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n    expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended\n\nWhen the subject is expected to stay the same, it's often best to assert\nexactly that.\n\n    var myObj = {val: 1}\n      , noop = function () {};\n\n    expect(noop).to.not.change(myObj, 'val'); // Recommended\n    expect(noop).to.not.increase(myObj, 'val'); // Not recommended\n\n`.increase` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`. When not providing two arguments, always\nuse the second form.\n\n    var myObj = {val: 1}\n      , noop = function () {};\n\n    expect(noop).to.increase(myObj, 'val', 'nooo why fail??');\n\n    var val = 1\n      , noop = function () {}\n      , getVal = function () { return val; };\n\n    expect(noop, 'nooo why fail??').to.increase(getVal);\n\nThe alias `.increases` can be used interchangeably with `.increase`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3571,
    "codeStart": 3650,
    "code": "function assertIncreases (subject, prop, msg) {\n  if (msg) flag(this, 'message', msg);\n  var fn = flag(this, 'object')\n    , flagMsg = flag(this, 'message')\n    , ssfi = flag(this, 'ssfi');\n  new Assertion(fn, flagMsg, ssfi, true).is.a('function');\n\n  var initial;\n  if (!prop) {\n    new Assertion(subject, flagMsg, ssfi, true).is.a('function');\n    initial = subject();\n  } else {\n    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\n    initial = subject[prop];\n  }\n\n  // Make sure that the target is a number\n  new Assertion(initial, flagMsg, ssfi, true).is.a('number');\n\n  fn();\n\n  var final = prop === undefined || prop === null ? subject() : subject[prop];\n  var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\n\n  flag(this, 'deltaMsgObj', msgObj);\n  flag(this, 'initialDeltaValue', initial);\n  flag(this, 'finalDeltaValue', final);\n  flag(this, 'deltaBehavior', 'increase');\n  flag(this, 'realDelta', final - initial);\n\n  this.assert(\n    final - initial > 0\n    , 'expected ' + msgObj + ' to increase'\n    , 'expected ' + msgObj + ' to not increase'\n  );\n}\n\nAssertion.addMethod('increase', assertIncreases);\nAssertion.addMethod('increases', assertIncreases);",
    "ctx": {
      "type": "function",
      "name": "assertIncreases",
      "string": "assertIncreases()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "decrease"
      },
      {
        "type": "alias",
        "string": "decreases"
      },
      {
        "type": "param",
        "string": "{String|Function} subject",
        "name": "subject",
        "description": "",
        "types": [
          "String",
          "Function"
        ],
        "typesDescription": "<code>String</code>|<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} prop name _optional_",
        "name": "prop",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .decrease(subject[, prop[, msg]])\n\nWhen one argument is provided, `.decrease` asserts that the given function\n`subject` returns a lesser number when it's invoked after invoking the\ntarget function compared to when it's invoked beforehand. `.decrease` also\ncauses all `.by` assertions that follow in the chain to assert how much\nlesser of a number is returned. It's often best to assert that the return\nvalue decreased by the expected amount, rather than asserting it decreased\nby any amount.\n\n    var val = 1\n      , subtractTwo = function () { val -= 2; }\n      , getVal = function () { return val; };\n\n    expect(subtractTwo).to.decrease(getVal).by(2); // Recommended\n    expect(subtractTwo).to.decrease(getVal); // Not recommended\n\nWhen two arguments are provided, `.decrease` asserts that the value of the\ngiven object `subject`'s `prop` property is lesser after invoking the\ntarget function compared to beforehand. \n\n    var myObj = {val: 1}\n      , subtractTwo = function () { myObj.val -= 2; };\n\n    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n    expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.decrease`. However, it's\ndangerous to do so. The problem is that it creates uncertain expectations\nby asserting that the subject either increases, or that it stays the same.\nIt's often best to identify the exact output that's expected, and then\nwrite an assertion that only accepts that exact output.\n\nWhen the subject is expected to increase, it's often best to assert that it\nincreased by the expected amount.\n\n    var myObj = {val: 1}\n      , addTwo = function () { myObj.val += 2; };\n\n    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n    expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended\n\nWhen the subject is expected to stay the same, it's often best to assert\nexactly that.\n\n    var myObj = {val: 1}\n      , noop = function () {};\n\n    expect(noop).to.not.change(myObj, 'val'); // Recommended\n    expect(noop).to.not.decrease(myObj, 'val'); // Not recommended\n\n`.decrease` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`. When not providing two arguments, always\nuse the second form.\n\n    var myObj = {val: 1}\n      , noop = function () {};\n\n    expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');\n\n    var val = 1\n      , noop = function () {}\n      , getVal = function () { return val; };\n\n    expect(noop, 'nooo why fail??').to.decrease(getVal);\n\nThe alias `.decreases` can be used interchangeably with `.decrease`.",
      "summary": "### .decrease(subject[, prop[, msg]])",
      "body": "When one argument is provided, `.decrease` asserts that the given function\n`subject` returns a lesser number when it's invoked after invoking the\ntarget function compared to when it's invoked beforehand. `.decrease` also\ncauses all `.by` assertions that follow in the chain to assert how much\nlesser of a number is returned. It's often best to assert that the return\nvalue decreased by the expected amount, rather than asserting it decreased\nby any amount.\n\n    var val = 1\n      , subtractTwo = function () { val -= 2; }\n      , getVal = function () { return val; };\n\n    expect(subtractTwo).to.decrease(getVal).by(2); // Recommended\n    expect(subtractTwo).to.decrease(getVal); // Not recommended\n\nWhen two arguments are provided, `.decrease` asserts that the value of the\ngiven object `subject`'s `prop` property is lesser after invoking the\ntarget function compared to beforehand. \n\n    var myObj = {val: 1}\n      , subtractTwo = function () { myObj.val -= 2; };\n\n    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n    expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.decrease`. However, it's\ndangerous to do so. The problem is that it creates uncertain expectations\nby asserting that the subject either increases, or that it stays the same.\nIt's often best to identify the exact output that's expected, and then\nwrite an assertion that only accepts that exact output.\n\nWhen the subject is expected to increase, it's often best to assert that it\nincreased by the expected amount.\n\n    var myObj = {val: 1}\n      , addTwo = function () { myObj.val += 2; };\n\n    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n    expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended\n\nWhen the subject is expected to stay the same, it's often best to assert\nexactly that.\n\n    var myObj = {val: 1}\n      , noop = function () {};\n\n    expect(noop).to.not.change(myObj, 'val'); // Recommended\n    expect(noop).to.not.decrease(myObj, 'val'); // Not recommended\n\n`.decrease` accepts an optional `msg` argument which is a custom error\nmessage to show when the assertion fails. The message can also be given as\nthe second argument to `expect`. When not providing two arguments, always\nuse the second form.\n\n    var myObj = {val: 1}\n      , noop = function () {};\n\n    expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');\n\n    var val = 1\n      , noop = function () {}\n      , getVal = function () { return val; };\n\n    expect(noop, 'nooo why fail??').to.decrease(getVal);\n\nThe alias `.decreases` can be used interchangeably with `.decrease`."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3690,
    "codeStart": 3769,
    "code": "function assertDecreases (subject, prop, msg) {\n  if (msg) flag(this, 'message', msg);\n  var fn = flag(this, 'object')\n    , flagMsg = flag(this, 'message')\n    , ssfi = flag(this, 'ssfi');\n  new Assertion(fn, flagMsg, ssfi, true).is.a('function');\n\n  var initial;\n  if (!prop) {\n    new Assertion(subject, flagMsg, ssfi, true).is.a('function');\n    initial = subject();\n  } else {\n    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\n    initial = subject[prop];\n  }\n\n  // Make sure that the target is a number\n  new Assertion(initial, flagMsg, ssfi, true).is.a('number');\n\n  fn();\n\n  var final = prop === undefined || prop === null ? subject() : subject[prop];\n  var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\n\n  flag(this, 'deltaMsgObj', msgObj);\n  flag(this, 'initialDeltaValue', initial);\n  flag(this, 'finalDeltaValue', final);\n  flag(this, 'deltaBehavior', 'decrease');\n  flag(this, 'realDelta', initial - final);\n\n  this.assert(\n    final - initial < 0\n    , 'expected ' + msgObj + ' to decrease'\n    , 'expected ' + msgObj + ' to not decrease'\n  );\n}\n\nAssertion.addMethod('decrease', assertDecreases);\nAssertion.addMethod('decreases', assertDecreases);",
    "ctx": {
      "type": "function",
      "name": "assertDecreases",
      "string": "assertDecreases()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "by"
      },
      {
        "type": "param",
        "string": "{Number} delta",
        "name": "delta",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} msg _optional_",
        "name": "msg",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .by(delta[, msg])\n\nWhen following an `.increase` assertion in the chain, `.by` asserts that\nthe subject of the `.increase` assertion increased by the given `delta`.\n\n    var myObj = {val: 1}\n      , addTwo = function () { myObj.val += 2; };\n\n    expect(addTwo).to.increase(myObj, 'val').by(2);\n\nWhen following a `.decrease` assertion in the chain, `.by` asserts that the\nsubject of the `.decrease` assertion decreased by the given `delta`.\n\n    var myObj = {val: 1}\n      , subtractTwo = function () { myObj.val -= 2; };\n\n    expect(subtractTwo).to.decrease(myObj, 'val').by(2);\n\nWhen following a `.change` assertion in the chain, `.by` asserts that the\nsubject of the `.change` assertion either increased or decreased by the\ngiven `delta`. However, it's dangerous to use `.change.by`. The problem is\nthat it creates uncertain expectations. It's often best to identify the\nexact output that's expected, and then write an assertion that only accepts\nthat exact output.\n\n    var myObj = {val: 1}\n      , addTwo = function () { myObj.val += 2; }\n      , subtractTwo = function () { myObj.val -= 2; };\n\n    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n    expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended\n\n    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n    expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.by`. However, it's often best\nto assert that the subject changed by its expected delta, rather than\nasserting that it didn't change by one of countless unexpected deltas.\n\n    var myObj = {val: 1}\n      , addTwo = function () { myObj.val += 2; };\n\n    // Recommended\n    expect(addTwo).to.increase(myObj, 'val').by(2);\n\n    // Not recommended\n    expect(addTwo).to.increase(myObj, 'val').but.not.by(3);\n\n`.by` accepts an optional `msg` argument which is a custom error message to\nshow when the assertion fails. The message can also be given as the second\nargument to `expect`.\n\n    var myObj = {val: 1}\n      , addTwo = function () { myObj.val += 2; };\n\n    expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');\n    expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);",
      "summary": "### .by(delta[, msg])",
      "body": "When following an `.increase` assertion in the chain, `.by` asserts that\nthe subject of the `.increase` assertion increased by the given `delta`.\n\n    var myObj = {val: 1}\n      , addTwo = function () { myObj.val += 2; };\n\n    expect(addTwo).to.increase(myObj, 'val').by(2);\n\nWhen following a `.decrease` assertion in the chain, `.by` asserts that the\nsubject of the `.decrease` assertion decreased by the given `delta`.\n\n    var myObj = {val: 1}\n      , subtractTwo = function () { myObj.val -= 2; };\n\n    expect(subtractTwo).to.decrease(myObj, 'val').by(2);\n\nWhen following a `.change` assertion in the chain, `.by` asserts that the\nsubject of the `.change` assertion either increased or decreased by the\ngiven `delta`. However, it's dangerous to use `.change.by`. The problem is\nthat it creates uncertain expectations. It's often best to identify the\nexact output that's expected, and then write an assertion that only accepts\nthat exact output.\n\n    var myObj = {val: 1}\n      , addTwo = function () { myObj.val += 2; }\n      , subtractTwo = function () { myObj.val -= 2; };\n\n    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n    expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended\n\n    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n    expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended\n\nAdd `.not` earlier in the chain to negate `.by`. However, it's often best\nto assert that the subject changed by its expected delta, rather than\nasserting that it didn't change by one of countless unexpected deltas.\n\n    var myObj = {val: 1}\n      , addTwo = function () { myObj.val += 2; };\n\n    // Recommended\n    expect(addTwo).to.increase(myObj, 'val').by(2);\n\n    // Not recommended\n    expect(addTwo).to.increase(myObj, 'val').but.not.by(3);\n\n`.by` accepts an optional `msg` argument which is a custom error message to\nshow when the assertion fails. The message can also be given as the second\nargument to `expect`.\n\n    var myObj = {val: 1}\n      , addTwo = function () { myObj.val += 2; };\n\n    expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');\n    expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3809,
    "codeStart": 3875,
    "code": "function assertDelta(delta, msg) {\n  if (msg) flag(this, 'message', msg);\n\n  var msgObj = flag(this, 'deltaMsgObj');\n  var initial = flag(this, 'initialDeltaValue');\n  var final = flag(this, 'finalDeltaValue');\n  var behavior = flag(this, 'deltaBehavior');\n  var realDelta = flag(this, 'realDelta');\n\n  var expression;\n  if (behavior === 'change') {\n    expression = Math.abs(final - initial) === Math.abs(delta);\n  } else {\n    expression = realDelta === Math.abs(delta);\n  }\n\n  this.assert(\n    expression\n    , 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta\n    , 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta\n  );\n}\n\nAssertion.addMethod('by', assertDelta);",
    "ctx": {
      "type": "function",
      "name": "assertDelta",
      "string": "assertDelta()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "extensible"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .extensible\n\nAsserts that the target is extensible, which means that new properties can\nbe added to it. Primitives are never extensible.\n\n    expect({a: 1}).to.be.extensible;\n\nAdd `.not` earlier in the chain to negate `.extensible`.\n\n    var nonExtensibleObject = Object.preventExtensions({})\n      , sealedObject = Object.seal({})\n      , frozenObject = Object.freeze({});\n\n    expect(nonExtensibleObject).to.not.be.extensible;\n    expect(sealedObject).to.not.be.extensible;\n    expect(frozenObject).to.not.be.extensible;\n    expect(1).to.not.be.extensible;\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(1, 'nooo why fail??').to.be.extensible;",
      "summary": "### .extensible",
      "body": "Asserts that the target is extensible, which means that new properties can\nbe added to it. Primitives are never extensible.\n\n    expect({a: 1}).to.be.extensible;\n\nAdd `.not` earlier in the chain to negate `.extensible`.\n\n    var nonExtensibleObject = Object.preventExtensions({})\n      , sealedObject = Object.seal({})\n      , frozenObject = Object.freeze({});\n\n    expect(nonExtensibleObject).to.not.be.extensible;\n    expect(sealedObject).to.not.be.extensible;\n    expect(frozenObject).to.not.be.extensible;\n    expect(1).to.not.be.extensible;\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect(1, 'nooo why fail??').to.be.extensible;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3900,
    "codeStart": 3928,
    "code": "Assertion.addProperty('extensible', function() {\n  var obj = flag(this, 'object');\n\n  // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\n  // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n  // The following provides ES6 behavior for ES5 environments.\n\n  var isExtensible = obj === Object(obj) && Object.isExtensible(obj);\n\n  this.assert(\n    isExtensible\n    , 'expected #{this} to be extensible'\n    , 'expected #{this} to not be extensible'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "sealed"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .sealed\n\nAsserts that the target is sealed, which means that new properties can't be\nadded to it, and its existing properties can't be reconfigured or deleted.\nHowever, it's possible that its existing properties can still be reassigned\nto different values. Primitives are always sealed.\n\n    var sealedObject = Object.seal({});\n    var frozenObject = Object.freeze({});\n\n    expect(sealedObject).to.be.sealed;\n    expect(frozenObject).to.be.sealed;\n    expect(1).to.be.sealed;\n\nAdd `.not` earlier in the chain to negate `.sealed`.\n\n    expect({a: 1}).to.not.be.sealed;\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect({a: 1}, 'nooo why fail??').to.be.sealed;",
      "summary": "### .sealed",
      "body": "Asserts that the target is sealed, which means that new properties can't be\nadded to it, and its existing properties can't be reconfigured or deleted.\nHowever, it's possible that its existing properties can still be reassigned\nto different values. Primitives are always sealed.\n\n    var sealedObject = Object.seal({});\n    var frozenObject = Object.freeze({});\n\n    expect(sealedObject).to.be.sealed;\n    expect(frozenObject).to.be.sealed;\n    expect(1).to.be.sealed;\n\nAdd `.not` earlier in the chain to negate `.sealed`.\n\n    expect({a: 1}).to.not.be.sealed;\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect({a: 1}, 'nooo why fail??').to.be.sealed;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3945,
    "codeStart": 3973,
    "code": "Assertion.addProperty('sealed', function() {\n  var obj = flag(this, 'object');\n\n  // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\n  // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n  // The following provides ES6 behavior for ES5 environments.\n\n  var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;\n\n  this.assert(\n    isSealed\n    , 'expected #{this} to be sealed'\n    , 'expected #{this} to not be sealed'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "frozen"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .frozen\n\nAsserts that the target is frozen, which means that new properties can't be\nadded to it, and its existing properties can't be reassigned to different\nvalues, reconfigured, or deleted. Primitives are always frozen.\n\n    var frozenObject = Object.freeze({});\n\n    expect(frozenObject).to.be.frozen;\n    expect(1).to.be.frozen;\n\nAdd `.not` earlier in the chain to negate `.frozen`.\n\n    expect({a: 1}).to.not.be.frozen;\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect({a: 1}, 'nooo why fail??').to.be.frozen;",
      "summary": "### .frozen",
      "body": "Asserts that the target is frozen, which means that new properties can't be\nadded to it, and its existing properties can't be reassigned to different\nvalues, reconfigured, or deleted. Primitives are always frozen.\n\n    var frozenObject = Object.freeze({});\n\n    expect(frozenObject).to.be.frozen;\n    expect(1).to.be.frozen;\n\nAdd `.not` earlier in the chain to negate `.frozen`.\n\n    expect({a: 1}).to.not.be.frozen;\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect({a: 1}, 'nooo why fail??').to.be.frozen;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 3990,
    "codeStart": 4015,
    "code": "Assertion.addProperty('frozen', function() {\n  var obj = flag(this, 'object');\n\n  // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\n  // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n  // The following provides ES6 behavior for ES5 environments.\n\n  var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;\n\n  this.assert(\n    isFrozen\n    , 'expected #{this} to be frozen'\n    , 'expected #{this} to not be frozen'\n  );\n});",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "finite"
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .finite\n\nAsserts that the target is a number, and isn't `NaN` or positive/negative\n`Infinity`.\n\n    expect(1).to.be.finite;\n\nAdd `.not` earlier in the chain to negate `.finite`. However, it's\ndangerous to do so. The problem is that it creates uncertain expectations\nby asserting that the subject either isn't a number, or that it's `NaN`, or\nthat it's positive `Infinity`, or that it's negative `Infinity`. It's often\nbest to identify the exact output that's expected, and then write an\nassertion that only accepts that exact output.\n\nWhen the target isn't expected to be a number, it's often best to assert\nthat it's the expected type, rather than asserting that it isn't one of\nmany unexpected types.\n\n    expect('foo').to.be.a('string'); // Recommended\n    expect('foo').to.not.be.finite; // Not recommended\n\nWhen the target is expected to be `NaN`, it's often best to assert exactly\nthat.\n\n    expect(NaN).to.be.NaN; // Recommended\n    expect(NaN).to.not.be.finite; // Not recommended\n\nWhen the target is expected to be positive infinity, it's often best to\nassert exactly that.\n\n    expect(Infinity).to.equal(Infinity); // Recommended\n    expect(Infinity).to.not.be.finite; // Not recommended\n\nWhen the target is expected to be negative infinity, it's often best to\nassert exactly that.\n\n    expect(-Infinity).to.equal(-Infinity); // Recommended\n    expect(-Infinity).to.not.be.finite; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect('foo', 'nooo why fail??').to.be.finite;",
      "summary": "### .finite",
      "body": "Asserts that the target is a number, and isn't `NaN` or positive/negative\n`Infinity`.\n\n    expect(1).to.be.finite;\n\nAdd `.not` earlier in the chain to negate `.finite`. However, it's\ndangerous to do so. The problem is that it creates uncertain expectations\nby asserting that the subject either isn't a number, or that it's `NaN`, or\nthat it's positive `Infinity`, or that it's negative `Infinity`. It's often\nbest to identify the exact output that's expected, and then write an\nassertion that only accepts that exact output.\n\nWhen the target isn't expected to be a number, it's often best to assert\nthat it's the expected type, rather than asserting that it isn't one of\nmany unexpected types.\n\n    expect('foo').to.be.a('string'); // Recommended\n    expect('foo').to.not.be.finite; // Not recommended\n\nWhen the target is expected to be `NaN`, it's often best to assert exactly\nthat.\n\n    expect(NaN).to.be.NaN; // Recommended\n    expect(NaN).to.not.be.finite; // Not recommended\n\nWhen the target is expected to be positive infinity, it's often best to\nassert exactly that.\n\n    expect(Infinity).to.equal(Infinity); // Recommended\n    expect(Infinity).to.not.be.finite; // Not recommended\n\nWhen the target is expected to be negative infinity, it's often best to\nassert exactly that.\n\n    expect(-Infinity).to.equal(-Infinity); // Recommended\n    expect(-Infinity).to.not.be.finite; // Not recommended\n\nA custom error message can be given as the second argument to `expect`.\n\n    expect('foo', 'nooo why fail??').to.be.finite;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4032,
    "codeStart": 4081,
    "code": "Assertion.addProperty('finite', function(msg) {\n  var obj = flag(this, 'object');\n\n  this.assert(\n      typeof obj === \"number\" && isFinite(obj)\n    , 'expected #{this} to be a finite number'\n    , 'expected #{this} to not be a finite number'\n  );\n});\n};\n\n},{}],6:[function(require,module,exports){",
    "ctx": false
  },
  {
    "tags": [],
    "description": {
      "full": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4093,
    "codeStart": 4100,
    "code": "module.exports = function (chai, util) {",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai dependencies.",
      "summary": "Chai dependencies.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4102,
    "codeStart": 4106,
    "code": "var Assertion = chai.Assertion\n  , flag = util.flag;",
    "ctx": {
      "type": "declaration",
      "name": "Assertion",
      "value": "chai.Assertion",
      "string": "Assertion"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Module export.",
      "summary": "Module export.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 4109,
    "codeStart": 4112
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} expression to test for truthiness",
        "name": "expression",
        "description": "to test for truthiness",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message to display on error",
        "name": "message",
        "description": "to display on error",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "name",
        "string": "assert"
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### assert(expression, message)\n\nWrite your own test expressions.\n\n    assert('foo' !== 'bar', 'foo is not bar');\n    assert(Array.isArray([]), 'empty arrays are arrays');",
      "summary": "### assert(expression, message)",
      "body": "Write your own test expressions.\n\n    assert('foo' !== 'bar', 'foo is not bar');\n    assert(Array.isArray([]), 'empty arrays are arrays');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4113,
    "codeStart": 4128,
    "code": "var assert = chai.assert = function (express, errmsg) {\n  var test = new Assertion(null, null, chai.assert, true);\n  test.assert(\n      express\n    , errmsg\n    , '[ negation message unavailable ]'\n  );\n};",
    "ctx": {
      "type": "declaration",
      "name": "assert",
      "value": "chai.assert = function (express, errmsg) {",
      "string": "assert"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "fail"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} operator",
        "name": "operator",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .fail(actual, expected, [message], [operator])\n\nThrow a failure. Node.js `assert` module-compatible.",
      "summary": "### .fail(actual, expected, [message], [operator])",
      "body": "Throw a failure. Node.js `assert` module-compatible."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4137,
    "codeStart": 4151,
    "code": "assert.fail = function (actual, expected, message, operator) {\n  message = message || 'assert.fail()';\n  throw new chai.AssertionError(message, {\n      actual: actual\n    , expected: expected\n    , operator: operator\n  }, assert.fail);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "fail",
      "string": "assert.fail()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isOk"
      },
      {
        "type": "alias",
        "string": "ok"
      },
      {
        "type": "param",
        "string": "{Mixed} object to test",
        "name": "object",
        "description": "to test",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isOk(object, [message])\n\nAsserts that `object` is truthy.\n\n    assert.isOk('everything', 'everything is ok');\n    assert.isOk(false, 'this will fail');",
      "summary": "### .isOk(object, [message])",
      "body": "Asserts that `object` is truthy.\n\n    assert.isOk('everything', 'everything is ok');\n    assert.isOk(false, 'this will fail');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4160,
    "codeStart": 4176,
    "code": "assert.isOk = function (val, msg) {\n  new Assertion(val, msg, assert.isOk, true).is.ok;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isOk",
      "string": "assert.isOk()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotOk"
      },
      {
        "type": "alias",
        "string": "notOk"
      },
      {
        "type": "param",
        "string": "{Mixed} object to test",
        "name": "object",
        "description": "to test",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotOk(object, [message])\n\nAsserts that `object` is falsy.\n\n    assert.isNotOk('everything', 'this will fail');\n    assert.isNotOk(false, 'this will pass');",
      "summary": "### .isNotOk(object, [message])",
      "body": "Asserts that `object` is falsy.\n\n    assert.isNotOk('everything', 'this will fail');\n    assert.isNotOk(false, 'this will pass');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4180,
    "codeStart": 4196,
    "code": "assert.isNotOk = function (val, msg) {\n  new Assertion(val, msg, assert.isNotOk, true).is.not.ok;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotOk",
      "string": "assert.isNotOk()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "equal"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .equal(actual, expected, [message])\n\nAsserts non-strict equality (`==`) of `actual` and `expected`.\n\n    assert.equal(3, '3', '== coerces values to strings');",
      "summary": "### .equal(actual, expected, [message])",
      "body": "Asserts non-strict equality (`==`) of `actual` and `expected`.\n\n    assert.equal(3, '3', '== coerces values to strings');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4200,
    "codeStart": 4215,
    "code": "assert.equal = function (act, exp, msg) {\n  var test = new Assertion(act, msg, assert.equal, true);\n\n  test.assert(\n      exp == flag(test, 'object')\n    , 'expected #{this} to equal #{exp}'\n    , 'expected #{this} to not equal #{act}'\n    , exp\n    , act\n    , true\n  );\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "equal",
      "string": "assert.equal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notEqual"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notEqual(actual, expected, [message])\n\nAsserts non-strict inequality (`!=`) of `actual` and `expected`.\n\n    assert.notEqual(3, 4, 'these numbers are not equal');",
      "summary": "### .notEqual(actual, expected, [message])",
      "body": "Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n\n    assert.notEqual(3, 4, 'these numbers are not equal');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4228,
    "codeStart": 4243,
    "code": "assert.notEqual = function (act, exp, msg) {\n  var test = new Assertion(act, msg, assert.notEqual, true);\n\n  test.assert(\n      exp != flag(test, 'object')\n    , 'expected #{this} to not equal #{exp}'\n    , 'expected #{this} to equal #{act}'\n    , exp\n    , act\n    , true\n  );\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notEqual",
      "string": "assert.notEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "strictEqual"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .strictEqual(actual, expected, [message])\n\nAsserts strict equality (`===`) of `actual` and `expected`.\n\n    assert.strictEqual(true, true, 'these booleans are strictly equal');",
      "summary": "### .strictEqual(actual, expected, [message])",
      "body": "Asserts strict equality (`===`) of `actual` and `expected`.\n\n    assert.strictEqual(true, true, 'these booleans are strictly equal');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4256,
    "codeStart": 4271,
    "code": "assert.strictEqual = function (act, exp, msg) {\n  new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "strictEqual",
      "string": "assert.strictEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notStrictEqual"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notStrictEqual(actual, expected, [message])\n\nAsserts strict inequality (`!==`) of `actual` and `expected`.\n\n    assert.notStrictEqual(3, '3', 'no coercion for strict equality');",
      "summary": "### .notStrictEqual(actual, expected, [message])",
      "body": "Asserts strict inequality (`!==`) of `actual` and `expected`.\n\n    assert.notStrictEqual(3, '3', 'no coercion for strict equality');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4275,
    "codeStart": 4290,
    "code": "assert.notStrictEqual = function (act, exp, msg) {\n  new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notStrictEqual",
      "string": "assert.notStrictEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "deepEqual"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "alias",
        "string": "deepStrictEqual"
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .deepEqual(actual, expected, [message])\n\nAsserts that `actual` is deeply equal to `expected`.\n\n    assert.deepEqual({ tea: 'green' }, { tea: 'green' });",
      "summary": "### .deepEqual(actual, expected, [message])",
      "body": "Asserts that `actual` is deeply equal to `expected`.\n\n    assert.deepEqual({ tea: 'green' }, { tea: 'green' });"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4294,
    "codeStart": 4310,
    "code": "assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {\n  new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);\n};",
    "ctx": {
      "type": "property",
      "receiver": "assert",
      "name": "deepEqual",
      "value": "assert.deepStrictEqual = function (act, exp, msg) {",
      "string": "assert.deepEqual"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notDeepEqual"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notDeepEqual(actual, expected, [message])\n\nAssert that `actual` is not deeply equal to `expected`.\n\n    assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });",
      "summary": "### .notDeepEqual(actual, expected, [message])",
      "body": "Assert that `actual` is not deeply equal to `expected`.\n\n    assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4314,
    "codeStart": 4329,
    "code": "assert.notDeepEqual = function (act, exp, msg) {\n  new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notDeepEqual",
      "string": "assert.notDeepEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isAbove"
      },
      {
        "type": "param",
        "string": "{Mixed} valueToCheck",
        "name": "valueToCheck",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} valueToBeAbove",
        "name": "valueToBeAbove",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isAbove(valueToCheck, valueToBeAbove, [message])\n\nAsserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.\n\n    assert.isAbove(5, 2, '5 is strictly greater than 2');",
      "summary": "### .isAbove(valueToCheck, valueToBeAbove, [message])",
      "body": "Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.\n\n    assert.isAbove(5, 2, '5 is strictly greater than 2');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4333,
    "codeStart": 4348,
    "code": "assert.isAbove = function (val, abv, msg) {\n  new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isAbove",
      "string": "assert.isAbove()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isAtLeast"
      },
      {
        "type": "param",
        "string": "{Mixed} valueToCheck",
        "name": "valueToCheck",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} valueToBeAtLeast",
        "name": "valueToBeAtLeast",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])\n\nAsserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.\n\n    assert.isAtLeast(5, 2, '5 is greater or equal to 2');\n    assert.isAtLeast(3, 3, '3 is greater or equal to 3');",
      "summary": "### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])",
      "body": "Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.\n\n    assert.isAtLeast(5, 2, '5 is greater or equal to 2');\n    assert.isAtLeast(3, 3, '3 is greater or equal to 3');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4352,
    "codeStart": 4368,
    "code": "assert.isAtLeast = function (val, atlst, msg) {\n  new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isAtLeast",
      "string": "assert.isAtLeast()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isBelow"
      },
      {
        "type": "param",
        "string": "{Mixed} valueToCheck",
        "name": "valueToCheck",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} valueToBeBelow",
        "name": "valueToBeBelow",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isBelow(valueToCheck, valueToBeBelow, [message])\n\nAsserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.\n\n    assert.isBelow(3, 6, '3 is strictly less than 6');",
      "summary": "### .isBelow(valueToCheck, valueToBeBelow, [message])",
      "body": "Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.\n\n    assert.isBelow(3, 6, '3 is strictly less than 6');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4372,
    "codeStart": 4387,
    "code": "assert.isBelow = function (val, blw, msg) {\n  new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isBelow",
      "string": "assert.isBelow()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isAtMost"
      },
      {
        "type": "param",
        "string": "{Mixed} valueToCheck",
        "name": "valueToCheck",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} valueToBeAtMost",
        "name": "valueToBeAtMost",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isAtMost(valueToCheck, valueToBeAtMost, [message])\n\nAsserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.\n\n    assert.isAtMost(3, 6, '3 is less than or equal to 6');\n    assert.isAtMost(4, 4, '4 is less than or equal to 4');",
      "summary": "### .isAtMost(valueToCheck, valueToBeAtMost, [message])",
      "body": "Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.\n\n    assert.isAtMost(3, 6, '3 is less than or equal to 6');\n    assert.isAtMost(4, 4, '4 is less than or equal to 4');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4391,
    "codeStart": 4407,
    "code": "assert.isAtMost = function (val, atmst, msg) {\n  new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isAtMost",
      "string": "assert.isAtMost()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isTrue"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isTrue(value, [message])\n\nAsserts that `value` is true.\n\n    var teaServed = true;\n    assert.isTrue(teaServed, 'the tea has been served');",
      "summary": "### .isTrue(value, [message])",
      "body": "Asserts that `value` is true.\n\n    var teaServed = true;\n    assert.isTrue(teaServed, 'the tea has been served');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4411,
    "codeStart": 4426,
    "code": "assert.isTrue = function (val, msg) {\n  new Assertion(val, msg, assert.isTrue, true).is['true'];\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isTrue",
      "string": "assert.isTrue()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotTrue"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotTrue(value, [message])\n\nAsserts that `value` is not true.\n\n    var tea = 'tasty chai';\n    assert.isNotTrue(tea, 'great, time for tea!');",
      "summary": "### .isNotTrue(value, [message])",
      "body": "Asserts that `value` is not true.\n\n    var tea = 'tasty chai';\n    assert.isNotTrue(tea, 'great, time for tea!');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4430,
    "codeStart": 4445,
    "code": "assert.isNotTrue = function (val, msg) {\n  new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotTrue",
      "string": "assert.isNotTrue()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isFalse"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isFalse(value, [message])\n\nAsserts that `value` is false.\n\n    var teaServed = false;\n    assert.isFalse(teaServed, 'no tea yet? hmm...');",
      "summary": "### .isFalse(value, [message])",
      "body": "Asserts that `value` is false.\n\n    var teaServed = false;\n    assert.isFalse(teaServed, 'no tea yet? hmm...');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4449,
    "codeStart": 4464,
    "code": "assert.isFalse = function (val, msg) {\n  new Assertion(val, msg, assert.isFalse, true).is['false'];\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isFalse",
      "string": "assert.isFalse()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotFalse"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotFalse(value, [message])\n\nAsserts that `value` is not false.\n\n    var tea = 'tasty chai';\n    assert.isNotFalse(tea, 'great, time for tea!');",
      "summary": "### .isNotFalse(value, [message])",
      "body": "Asserts that `value` is not false.\n\n    var tea = 'tasty chai';\n    assert.isNotFalse(tea, 'great, time for tea!');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4468,
    "codeStart": 4483,
    "code": "assert.isNotFalse = function (val, msg) {\n  new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotFalse",
      "string": "assert.isNotFalse()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNull"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNull(value, [message])\n\nAsserts that `value` is null.\n\n    assert.isNull(err, 'there was no error');",
      "summary": "### .isNull(value, [message])",
      "body": "Asserts that `value` is null.\n\n    assert.isNull(err, 'there was no error');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4487,
    "codeStart": 4501,
    "code": "assert.isNull = function (val, msg) {\n  new Assertion(val, msg, assert.isNull, true).to.equal(null);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNull",
      "string": "assert.isNull()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotNull"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotNull(value, [message])\n\nAsserts that `value` is not null.\n\n    var tea = 'tasty chai';\n    assert.isNotNull(tea, 'great, time for tea!');",
      "summary": "### .isNotNull(value, [message])",
      "body": "Asserts that `value` is not null.\n\n    var tea = 'tasty chai';\n    assert.isNotNull(tea, 'great, time for tea!');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4505,
    "codeStart": 4520,
    "code": "assert.isNotNull = function (val, msg) {\n  new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotNull",
      "string": "assert.isNotNull()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNaN"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNaN\n\nAsserts that value is NaN.\n\n    assert.isNaN(NaN, 'NaN is NaN');",
      "summary": "### .isNaN",
      "body": "Asserts that value is NaN.\n\n    assert.isNaN(NaN, 'NaN is NaN');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4524,
    "codeStart": 4538,
    "code": "assert.isNaN = function (val, msg) {\n  new Assertion(val, msg, assert.isNaN, true).to.be.NaN;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNaN",
      "string": "assert.isNaN()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotNaN"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotNaN\n\nAsserts that value is not NaN.\n\n    assert.isNotNaN(4, '4 is not NaN');",
      "summary": "### .isNotNaN",
      "body": "Asserts that value is not NaN.\n\n    assert.isNotNaN(4, '4 is not NaN');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4542,
    "codeStart": 4555,
    "code": "assert.isNotNaN = function (val, msg) {\n  new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotNaN",
      "string": "assert.isNotNaN()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "exists"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .exists\n\nAsserts that the target is neither `null` nor `undefined`.\n\n    var foo = 'hi';\n\n    assert.exists(foo, 'foo is neither `null` nor `undefined`');",
      "summary": "### .exists",
      "body": "Asserts that the target is neither `null` nor `undefined`.\n\n    var foo = 'hi';\n\n    assert.exists(foo, 'foo is neither `null` nor `undefined`');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4559,
    "codeStart": 4575,
    "code": "assert.exists = function (val, msg) {\n  new Assertion(val, msg, assert.exists, true).to.exist;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "exists",
      "string": "assert.exists()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notExists"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notExists\n\nAsserts that the target is either `null` or `undefined`.\n\n    var bar = null\n      , baz;\n\n    assert.notExists(bar);\n    assert.notExists(baz, 'baz is either null or undefined');",
      "summary": "### .notExists",
      "body": "Asserts that the target is either `null` or `undefined`.\n\n    var bar = null\n      , baz;\n\n    assert.notExists(bar);\n    assert.notExists(baz, 'baz is either null or undefined');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4579,
    "codeStart": 4597,
    "code": "assert.notExists = function (val, msg) {\n  new Assertion(val, msg, assert.notExists, true).to.not.exist;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notExists",
      "string": "assert.notExists()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isUndefined"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isUndefined(value, [message])\n\nAsserts that `value` is `undefined`.\n\n    var tea;\n    assert.isUndefined(tea, 'no tea defined');",
      "summary": "### .isUndefined(value, [message])",
      "body": "Asserts that `value` is `undefined`.\n\n    var tea;\n    assert.isUndefined(tea, 'no tea defined');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4601,
    "codeStart": 4616,
    "code": "assert.isUndefined = function (val, msg) {\n  new Assertion(val, msg, assert.isUndefined, true).to.equal(undefined);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isUndefined",
      "string": "assert.isUndefined()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isDefined"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isDefined(value, [message])\n\nAsserts that `value` is not `undefined`.\n\n    var tea = 'cup of chai';\n    assert.isDefined(tea, 'tea has been defined');",
      "summary": "### .isDefined(value, [message])",
      "body": "Asserts that `value` is not `undefined`.\n\n    var tea = 'cup of chai';\n    assert.isDefined(tea, 'tea has been defined');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4620,
    "codeStart": 4635,
    "code": "assert.isDefined = function (val, msg) {\n  new Assertion(val, msg, assert.isDefined, true).to.not.equal(undefined);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isDefined",
      "string": "assert.isDefined()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isFunction"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isFunction(value, [message])\n\nAsserts that `value` is a function.\n\n    function serveTea() { return 'cup of tea'; };\n    assert.isFunction(serveTea, 'great, we can have tea now');",
      "summary": "### .isFunction(value, [message])",
      "body": "Asserts that `value` is a function.\n\n    function serveTea() { return 'cup of tea'; };\n    assert.isFunction(serveTea, 'great, we can have tea now');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4639,
    "codeStart": 4654,
    "code": "assert.isFunction = function (val, msg) {\n  new Assertion(val, msg, assert.isFunction, true).to.be.a('function');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isFunction",
      "string": "assert.isFunction()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotFunction"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotFunction(value, [message])\n\nAsserts that `value` is _not_ a function.\n\n    var serveTea = [ 'heat', 'pour', 'sip' ];\n    assert.isNotFunction(serveTea, 'great, we have listed the steps');",
      "summary": "### .isNotFunction(value, [message])",
      "body": "Asserts that `value` is _not_ a function.\n\n    var serveTea = [ 'heat', 'pour', 'sip' ];\n    assert.isNotFunction(serveTea, 'great, we have listed the steps');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4658,
    "codeStart": 4673,
    "code": "assert.isNotFunction = function (val, msg) {\n  new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a('function');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotFunction",
      "string": "assert.isNotFunction()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isObject"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isObject(value, [message])\n\nAsserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).\n_The assertion does not match subclassed objects._\n\n    var selection = { name: 'Chai', serve: 'with spices' };\n    assert.isObject(selection, 'tea selection is an object');",
      "summary": "### .isObject(value, [message])",
      "body": "Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).\n_The assertion does not match subclassed objects._\n\n    var selection = { name: 'Chai', serve: 'with spices' };\n    assert.isObject(selection, 'tea selection is an object');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4677,
    "codeStart": 4693,
    "code": "assert.isObject = function (val, msg) {\n  new Assertion(val, msg, assert.isObject, true).to.be.a('object');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isObject",
      "string": "assert.isObject()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotObject"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotObject(value, [message])\n\nAsserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).\n\n    var selection = 'chai'\n    assert.isNotObject(selection, 'tea selection is not an object');\n    assert.isNotObject(null, 'null is not an object');",
      "summary": "### .isNotObject(value, [message])",
      "body": "Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).\n\n    var selection = 'chai'\n    assert.isNotObject(selection, 'tea selection is not an object');\n    assert.isNotObject(null, 'null is not an object');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4697,
    "codeStart": 4713,
    "code": "assert.isNotObject = function (val, msg) {\n  new Assertion(val, msg, assert.isNotObject, true).to.not.be.a('object');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotObject",
      "string": "assert.isNotObject()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isArray"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isArray(value, [message])\n\nAsserts that `value` is an array.\n\n    var menu = [ 'green', 'chai', 'oolong' ];\n    assert.isArray(menu, 'what kind of tea do we want?');",
      "summary": "### .isArray(value, [message])",
      "body": "Asserts that `value` is an array.\n\n    var menu = [ 'green', 'chai', 'oolong' ];\n    assert.isArray(menu, 'what kind of tea do we want?');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4717,
    "codeStart": 4732,
    "code": "assert.isArray = function (val, msg) {\n  new Assertion(val, msg, assert.isArray, true).to.be.an('array');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isArray",
      "string": "assert.isArray()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotArray"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotArray(value, [message])\n\nAsserts that `value` is _not_ an array.\n\n    var menu = 'green|chai|oolong';\n    assert.isNotArray(menu, 'what kind of tea do we want?');",
      "summary": "### .isNotArray(value, [message])",
      "body": "Asserts that `value` is _not_ an array.\n\n    var menu = 'green|chai|oolong';\n    assert.isNotArray(menu, 'what kind of tea do we want?');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4736,
    "codeStart": 4751,
    "code": "assert.isNotArray = function (val, msg) {\n  new Assertion(val, msg, assert.isNotArray, true).to.not.be.an('array');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotArray",
      "string": "assert.isNotArray()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isString"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isString(value, [message])\n\nAsserts that `value` is a string.\n\n    var teaOrder = 'chai';\n    assert.isString(teaOrder, 'order placed');",
      "summary": "### .isString(value, [message])",
      "body": "Asserts that `value` is a string.\n\n    var teaOrder = 'chai';\n    assert.isString(teaOrder, 'order placed');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4755,
    "codeStart": 4770,
    "code": "assert.isString = function (val, msg) {\n  new Assertion(val, msg, assert.isString, true).to.be.a('string');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isString",
      "string": "assert.isString()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotString"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotString(value, [message])\n\nAsserts that `value` is _not_ a string.\n\n    var teaOrder = 4;\n    assert.isNotString(teaOrder, 'order placed');",
      "summary": "### .isNotString(value, [message])",
      "body": "Asserts that `value` is _not_ a string.\n\n    var teaOrder = 4;\n    assert.isNotString(teaOrder, 'order placed');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4774,
    "codeStart": 4789,
    "code": "assert.isNotString = function (val, msg) {\n  new Assertion(val, msg, assert.isNotString, true).to.not.be.a('string');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotString",
      "string": "assert.isNotString()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNumber"
      },
      {
        "type": "param",
        "string": "{Number} value",
        "name": "value",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNumber(value, [message])\n\nAsserts that `value` is a number.\n\n    var cups = 2;\n    assert.isNumber(cups, 'how many cups');",
      "summary": "### .isNumber(value, [message])",
      "body": "Asserts that `value` is a number.\n\n    var cups = 2;\n    assert.isNumber(cups, 'how many cups');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4793,
    "codeStart": 4808,
    "code": "assert.isNumber = function (val, msg) {\n  new Assertion(val, msg, assert.isNumber, true).to.be.a('number');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNumber",
      "string": "assert.isNumber()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotNumber"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotNumber(value, [message])\n\nAsserts that `value` is _not_ a number.\n\n    var cups = '2 cups please';\n    assert.isNotNumber(cups, 'how many cups');",
      "summary": "### .isNotNumber(value, [message])",
      "body": "Asserts that `value` is _not_ a number.\n\n    var cups = '2 cups please';\n    assert.isNotNumber(cups, 'how many cups');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4812,
    "codeStart": 4827,
    "code": "assert.isNotNumber = function (val, msg) {\n  new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a('number');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotNumber",
      "string": "assert.isNotNumber()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isFinite"
      },
      {
        "type": "param",
        "string": "{Number} value",
        "name": "value",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isFinite(value, [message])\n\nAsserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.\n\n    var cups = 2;\n    assert.isFinite(cups, 'how many cups');\n\n    assert.isFinite(NaN); // throws",
      "summary": "### .isFinite(value, [message])",
      "body": "Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.\n\n    var cups = 2;\n    assert.isFinite(cups, 'how many cups');\n\n    assert.isFinite(NaN); // throws"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4831,
    "codeStart": 4848,
    "code": "assert.isFinite = function (val, msg) {\n  new Assertion(val, msg, assert.isFinite, true).to.be.finite;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isFinite",
      "string": "assert.isFinite()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isBoolean"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isBoolean(value, [message])\n\nAsserts that `value` is a boolean.\n\n    var teaReady = true\n      , teaServed = false;\n\n    assert.isBoolean(teaReady, 'is the tea ready');\n    assert.isBoolean(teaServed, 'has tea been served');",
      "summary": "### .isBoolean(value, [message])",
      "body": "Asserts that `value` is a boolean.\n\n    var teaReady = true\n      , teaServed = false;\n\n    assert.isBoolean(teaReady, 'is the tea ready');\n    assert.isBoolean(teaServed, 'has tea been served');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4852,
    "codeStart": 4870,
    "code": "assert.isBoolean = function (val, msg) {\n  new Assertion(val, msg, assert.isBoolean, true).to.be.a('boolean');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isBoolean",
      "string": "assert.isBoolean()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotBoolean"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotBoolean(value, [message])\n\nAsserts that `value` is _not_ a boolean.\n\n    var teaReady = 'yep'\n      , teaServed = 'nope';\n\n    assert.isNotBoolean(teaReady, 'is the tea ready');\n    assert.isNotBoolean(teaServed, 'has tea been served');",
      "summary": "### .isNotBoolean(value, [message])",
      "body": "Asserts that `value` is _not_ a boolean.\n\n    var teaReady = 'yep'\n      , teaServed = 'nope';\n\n    assert.isNotBoolean(teaReady, 'is the tea ready');\n    assert.isNotBoolean(teaServed, 'has tea been served');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4874,
    "codeStart": 4892,
    "code": "assert.isNotBoolean = function (val, msg) {\n  new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a('boolean');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotBoolean",
      "string": "assert.isNotBoolean()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "typeOf"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} name",
        "name": "name",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .typeOf(value, name, [message])\n\nAsserts that `value`'s type is `name`, as determined by\n`Object.prototype.toString`.\n\n    assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n    assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n    assert.typeOf('tea', 'string', 'we have a string');\n    assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n    assert.typeOf(null, 'null', 'we have a null');\n    assert.typeOf(undefined, 'undefined', 'we have an undefined');",
      "summary": "### .typeOf(value, name, [message])",
      "body": "Asserts that `value`'s type is `name`, as determined by\n`Object.prototype.toString`.\n\n    assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n    assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n    assert.typeOf('tea', 'string', 'we have a string');\n    assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n    assert.typeOf(null, 'null', 'we have a null');\n    assert.typeOf(undefined, 'undefined', 'we have an undefined');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4896,
    "codeStart": 4917,
    "code": "assert.typeOf = function (val, type, msg) {\n  new Assertion(val, msg, assert.typeOf, true).to.be.a(type);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "typeOf",
      "string": "assert.typeOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notTypeOf"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} typeof name",
        "name": "typeof",
        "description": "name",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notTypeOf(value, name, [message])\n\nAsserts that `value`'s type is _not_ `name`, as determined by\n`Object.prototype.toString`.\n\n    assert.notTypeOf('tea', 'number', 'strings are not numbers');",
      "summary": "### .notTypeOf(value, name, [message])",
      "body": "Asserts that `value`'s type is _not_ `name`, as determined by\n`Object.prototype.toString`.\n\n    assert.notTypeOf('tea', 'number', 'strings are not numbers');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4921,
    "codeStart": 4937,
    "code": "assert.notTypeOf = function (val, type, msg) {\n  new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notTypeOf",
      "string": "assert.notTypeOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "instanceOf"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Constructor} constructor",
        "name": "constructor",
        "description": "",
        "types": [
          "Constructor"
        ],
        "typesDescription": "<a href=\"Constructor.html\">Constructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .instanceOf(object, constructor, [message])\n\nAsserts that `value` is an instance of `constructor`.\n\n    var Tea = function (name) { this.name = name; }\n      , chai = new Tea('chai');\n\n    assert.instanceOf(chai, Tea, 'chai is an instance of tea');",
      "summary": "### .instanceOf(object, constructor, [message])",
      "body": "Asserts that `value` is an instance of `constructor`.\n\n    var Tea = function (name) { this.name = name; }\n      , chai = new Tea('chai');\n\n    assert.instanceOf(chai, Tea, 'chai is an instance of tea');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4941,
    "codeStart": 4959,
    "code": "assert.instanceOf = function (val, type, msg) {\n  new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "instanceOf",
      "string": "assert.instanceOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notInstanceOf"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Constructor} constructor",
        "name": "constructor",
        "description": "",
        "types": [
          "Constructor"
        ],
        "typesDescription": "<a href=\"Constructor.html\">Constructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notInstanceOf(object, constructor, [message])\n\nAsserts `value` is not an instance of `constructor`.\n\n    var Tea = function (name) { this.name = name; }\n      , chai = new String('chai');\n\n    assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');",
      "summary": "### .notInstanceOf(object, constructor, [message])",
      "body": "Asserts `value` is not an instance of `constructor`.\n\n    var Tea = function (name) { this.name = name; }\n      , chai = new String('chai');\n\n    assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4963,
    "codeStart": 4981,
    "code": "assert.notInstanceOf = function (val, type, msg) {\n  new Assertion(val, msg, assert.notInstanceOf, true)\n    .to.not.be.instanceOf(type);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notInstanceOf",
      "string": "assert.notInstanceOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "include"
      },
      {
        "type": "param",
        "string": "{Array|String} haystack",
        "name": "haystack",
        "description": "",
        "types": [
          "Array",
          "String"
        ],
        "typesDescription": "<code>Array</code>|<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} needle",
        "name": "needle",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .include(haystack, needle, [message])\n\nAsserts that `haystack` includes `needle`. Can be used to assert the\ninclusion of a value in an array, a substring in a string, or a subset of\nproperties in an object.\n\n    assert.include([1,2,3], 2, 'array contains value');\n    assert.include('foobar', 'foo', 'string contains substring');\n    assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');\n\nStrict equality (===) is used. When asserting the inclusion of a value in\nan array, the array is searched for an element that's strictly equal to the\ngiven value. When asserting a subset of properties in an object, the object\nis searched for the given property keys, checking that each one is present\nand stricty equal to the given property value. For instance:\n\n    var obj1 = {a: 1}\n      , obj2 = {b: 2};\n    assert.include([obj1, obj2], obj1);\n    assert.include({foo: obj1, bar: obj2}, {foo: obj1});\n    assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});",
      "summary": "### .include(haystack, needle, [message])",
      "body": "Asserts that `haystack` includes `needle`. Can be used to assert the\ninclusion of a value in an array, a substring in a string, or a subset of\nproperties in an object.\n\n    assert.include([1,2,3], 2, 'array contains value');\n    assert.include('foobar', 'foo', 'string contains substring');\n    assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');\n\nStrict equality (===) is used. When asserting the inclusion of a value in\nan array, the array is searched for an element that's strictly equal to the\ngiven value. When asserting a subset of properties in an object, the object\nis searched for the given property keys, checking that each one is present\nand stricty equal to the given property value. For instance:\n\n    var obj1 = {a: 1}\n      , obj2 = {b: 2};\n    assert.include([obj1, obj2], obj1);\n    assert.include({foo: obj1, bar: obj2}, {foo: obj1});\n    assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 4986,
    "codeStart": 5017,
    "code": "assert.include = function (exp, inc, msg) {\n  new Assertion(exp, msg, assert.include, true).include(inc);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "include",
      "string": "assert.include()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notInclude"
      },
      {
        "type": "param",
        "string": "{Array|String} haystack",
        "name": "haystack",
        "description": "",
        "types": [
          "Array",
          "String"
        ],
        "typesDescription": "<code>Array</code>|<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} needle",
        "name": "needle",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notInclude(haystack, needle, [message])\n\nAsserts that `haystack` does not include `needle`. Can be used to assert\nthe absence of a value in an array, a substring in a string, or a subset of\nproperties in an object.\n\n    assert.notInclude([1,2,3], 4, 'array doesn't contain value');\n    assert.notInclude('foobar', 'baz', 'string doesn't contain substring');\n    assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');\n\nStrict equality (===) is used. When asserting the absence of a value in an\narray, the array is searched to confirm the absence of an element that's\nstrictly equal to the given value. When asserting a subset of properties in\nan object, the object is searched to confirm that at least one of the given\nproperty keys is either not present or not strictly equal to the given\nproperty value. For instance:\n\n    var obj1 = {a: 1}\n      , obj2 = {b: 2};\n    assert.notInclude([obj1, obj2], {a: 1});\n    assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});\n    assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});",
      "summary": "### .notInclude(haystack, needle, [message])",
      "body": "Asserts that `haystack` does not include `needle`. Can be used to assert\nthe absence of a value in an array, a substring in a string, or a subset of\nproperties in an object.\n\n    assert.notInclude([1,2,3], 4, 'array doesn't contain value');\n    assert.notInclude('foobar', 'baz', 'string doesn't contain substring');\n    assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');\n\nStrict equality (===) is used. When asserting the absence of a value in an\narray, the array is searched to confirm the absence of an element that's\nstrictly equal to the given value. When asserting a subset of properties in\nan object, the object is searched to confirm that at least one of the given\nproperty keys is either not present or not strictly equal to the given\nproperty value. For instance:\n\n    var obj1 = {a: 1}\n      , obj2 = {b: 2};\n    assert.notInclude([obj1, obj2], {a: 1});\n    assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});\n    assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5021,
    "codeStart": 5053,
    "code": "assert.notInclude = function (exp, inc, msg) {\n  new Assertion(exp, msg, assert.notInclude, true).not.include(inc);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notInclude",
      "string": "assert.notInclude()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "deepInclude"
      },
      {
        "type": "param",
        "string": "{Array|String} haystack",
        "name": "haystack",
        "description": "",
        "types": [
          "Array",
          "String"
        ],
        "typesDescription": "<code>Array</code>|<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} needle",
        "name": "needle",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .deepInclude(haystack, needle, [message])\n\nAsserts that `haystack` includes `needle`. Can be used to assert the\ninclusion of a value in an array or a subset of properties in an object.\nDeep equality is used.\n\n    var obj1 = {a: 1}\n      , obj2 = {b: 2};\n    assert.deepInclude([obj1, obj2], {a: 1});\n    assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});\n    assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});",
      "summary": "### .deepInclude(haystack, needle, [message])",
      "body": "Asserts that `haystack` includes `needle`. Can be used to assert the\ninclusion of a value in an array or a subset of properties in an object.\nDeep equality is used.\n\n    var obj1 = {a: 1}\n      , obj2 = {b: 2};\n    assert.deepInclude([obj1, obj2], {a: 1});\n    assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});\n    assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5057,
    "codeStart": 5078,
    "code": "assert.deepInclude = function (exp, inc, msg) {\n  new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "deepInclude",
      "string": "assert.deepInclude()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notDeepInclude"
      },
      {
        "type": "param",
        "string": "{Array|String} haystack",
        "name": "haystack",
        "description": "",
        "types": [
          "Array",
          "String"
        ],
        "typesDescription": "<code>Array</code>|<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} needle",
        "name": "needle",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notDeepInclude(haystack, needle, [message])\n\nAsserts that `haystack` does not include `needle`. Can be used to assert\nthe absence of a value in an array or a subset of properties in an object.\nDeep equality is used.\n\n    var obj1 = {a: 1}\n      , obj2 = {b: 2};\n    assert.notDeepInclude([obj1, obj2], {a: 9});\n    assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});\n    assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});",
      "summary": "### .notDeepInclude(haystack, needle, [message])",
      "body": "Asserts that `haystack` does not include `needle`. Can be used to assert\nthe absence of a value in an array or a subset of properties in an object.\nDeep equality is used.\n\n    var obj1 = {a: 1}\n      , obj2 = {b: 2};\n    assert.notDeepInclude([obj1, obj2], {a: 9});\n    assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});\n    assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5082,
    "codeStart": 5103,
    "code": "assert.notDeepInclude = function (exp, inc, msg) {\n  new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notDeepInclude",
      "string": "assert.notDeepInclude()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "nestedInclude"
      },
      {
        "type": "param",
        "string": "{Object} haystack",
        "name": "haystack",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} needle",
        "name": "needle",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .nestedInclude(haystack, needle, [message])\n\nAsserts that 'haystack' includes 'needle'. \nCan be used to assert the inclusion of a subset of properties in an \nobject.\nEnables the use of dot- and bracket-notation for referencing nested \nproperties.\n'[]' and '.' in property names can be escaped using double backslashes.\n\n    assert.nestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.[b]': 'x'});\n    assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'x'});",
      "summary": "### .nestedInclude(haystack, needle, [message])",
      "body": "Asserts that 'haystack' includes 'needle'. \nCan be used to assert the inclusion of a subset of properties in an \nobject.\nEnables the use of dot- and bracket-notation for referencing nested \nproperties.\n'[]' and '.' in property names can be escaped using double backslashes.\n\n    assert.nestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.[b]': 'x'});\n    assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'x'});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5107,
    "codeStart": 5129,
    "code": "assert.nestedInclude = function (exp, inc, msg) {\n  new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "nestedInclude",
      "string": "assert.nestedInclude()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notNestedInclude"
      },
      {
        "type": "param",
        "string": "{Object} haystack",
        "name": "haystack",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} needle",
        "name": "needle",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notNestedInclude(haystack, needle, [message])\n\nAsserts that 'haystack' does not include 'needle'. \nCan be used to assert the absence of a subset of properties in an \nobject.\nEnables the use of dot- and bracket-notation for referencing nested \nproperties. \n'[]' and '.' in property names can be escaped using double backslashes.\n\n    assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.b': 'y'});\n    assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'y'});",
      "summary": "### .notNestedInclude(haystack, needle, [message])",
      "body": "Asserts that 'haystack' does not include 'needle'. \nCan be used to assert the absence of a subset of properties in an \nobject.\nEnables the use of dot- and bracket-notation for referencing nested \nproperties. \n'[]' and '.' in property names can be escaped using double backslashes.\n\n    assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.b': 'y'});\n    assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'y'});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5132,
    "codeStart": 5154,
    "code": "assert.notNestedInclude = function (exp, inc, msg) {\n  new Assertion(exp, msg, assert.notNestedInclude, true)\n    .not.nested.include(inc);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notNestedInclude",
      "string": "assert.notNestedInclude()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "deepNestedInclude"
      },
      {
        "type": "param",
        "string": "{Object} haystack",
        "name": "haystack",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} needle",
        "name": "needle",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .deepNestedInclude(haystack, needle, [message])\n\nAsserts that 'haystack' includes 'needle'.\nCan be used to assert the inclusion of a subset of properties in an \nobject while checking for deep equality.\nEnables the use of dot- and bracket-notation for referencing nested \nproperties.\n'[]' and '.' in property names can be escaped using double backslashes.\n\n    assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});\n    assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {x: 1}});",
      "summary": "### .deepNestedInclude(haystack, needle, [message])",
      "body": "Asserts that 'haystack' includes 'needle'.\nCan be used to assert the inclusion of a subset of properties in an \nobject while checking for deep equality.\nEnables the use of dot- and bracket-notation for referencing nested \nproperties.\n'[]' and '.' in property names can be escaped using double backslashes.\n\n    assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});\n    assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {x: 1}});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5158,
    "codeStart": 5179,
    "code": "assert.deepNestedInclude = function(exp, inc, msg) {\n  new Assertion(exp, msg, assert.deepNestedInclude, true)\n    .deep.nested.include(inc);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "deepNestedInclude",
      "string": "assert.deepNestedInclude()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notDeepNestedInclude"
      },
      {
        "type": "param",
        "string": "{Object} haystack",
        "name": "haystack",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} needle",
        "name": "needle",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notDeepNestedInclude(haystack, needle, [message])\n\nAsserts that 'haystack' does not include 'needle'.\nCan be used to assert the absence of a subset of properties in an \nobject while checking for deep equality.\nEnables the use of dot- and bracket-notation for referencing nested \nproperties.\n'[]' and '.' in property names can be escaped using double backslashes.\n\n    assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})\n    assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {y: 2}});",
      "summary": "### .notDeepNestedInclude(haystack, needle, [message])",
      "body": "Asserts that 'haystack' does not include 'needle'.\nCan be used to assert the absence of a subset of properties in an \nobject while checking for deep equality.\nEnables the use of dot- and bracket-notation for referencing nested \nproperties.\n'[]' and '.' in property names can be escaped using double backslashes.\n\n    assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})\n    assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {y: 2}});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5184,
    "codeStart": 5205,
    "code": "assert.notDeepNestedInclude = function(exp, inc, msg) {\n  new Assertion(exp, msg, assert.notDeepNestedInclude, true)\n    .not.deep.nested.include(inc);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notDeepNestedInclude",
      "string": "assert.notDeepNestedInclude()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "ownInclude"
      },
      {
        "type": "param",
        "string": "{Object} haystack",
        "name": "haystack",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} needle",
        "name": "needle",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .ownInclude(haystack, needle, [message])\n\nAsserts that 'haystack' includes 'needle'.\nCan be used to assert the inclusion of a subset of properties in an \nobject while ignoring inherited properties.\n\n    assert.ownInclude({ a: 1 }, { a: 1 });",
      "summary": "### .ownInclude(haystack, needle, [message])",
      "body": "Asserts that 'haystack' includes 'needle'.\nCan be used to assert the inclusion of a subset of properties in an \nobject while ignoring inherited properties.\n\n    assert.ownInclude({ a: 1 }, { a: 1 });"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5210,
    "codeStart": 5227,
    "code": "assert.ownInclude = function(exp, inc, msg) {\n  new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "ownInclude",
      "string": "assert.ownInclude()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notOwnInclude"
      },
      {
        "type": "param",
        "string": "{Object} haystack",
        "name": "haystack",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} needle",
        "name": "needle",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notOwnInclude(haystack, needle, [message])\n\nAsserts that 'haystack' includes 'needle'.\nCan be used to assert the absence of a subset of properties in an \nobject while ignoring inherited properties.\n\n    Object.prototype.b = 2;\n\n    assert.notOwnInclude({ a: 1 }, { b: 2 });",
      "summary": "### .notOwnInclude(haystack, needle, [message])",
      "body": "Asserts that 'haystack' includes 'needle'.\nCan be used to assert the absence of a subset of properties in an \nobject while ignoring inherited properties.\n\n    Object.prototype.b = 2;\n\n    assert.notOwnInclude({ a: 1 }, { b: 2 });"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5231,
    "codeStart": 5250,
    "code": "assert.notOwnInclude = function(exp, inc, msg) {\n  new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notOwnInclude",
      "string": "assert.notOwnInclude()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "deepOwnInclude"
      },
      {
        "type": "param",
        "string": "{Object} haystack",
        "name": "haystack",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} needle",
        "name": "needle",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .deepOwnInclude(haystack, needle, [message])\n\nAsserts that 'haystack' includes 'needle'.\nCan be used to assert the inclusion of a subset of properties in an \nobject while ignoring inherited properties and checking for deep equality.\n\n     assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});",
      "summary": "### .deepOwnInclude(haystack, needle, [message])",
      "body": "Asserts that 'haystack' includes 'needle'.\nCan be used to assert the inclusion of a subset of properties in an \nobject while ignoring inherited properties and checking for deep equality.\n\n     assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5254,
    "codeStart": 5271,
    "code": "assert.deepOwnInclude = function(exp, inc, msg) {\n  new Assertion(exp, msg, assert.deepOwnInclude, true)\n    .deep.own.include(inc);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "deepOwnInclude",
      "string": "assert.deepOwnInclude()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notDeepOwnInclude"
      },
      {
        "type": "param",
        "string": "{Object} haystack",
        "name": "haystack",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} needle",
        "name": "needle",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notDeepOwnInclude(haystack, needle, [message])\n\nAsserts that 'haystack' includes 'needle'.\nCan be used to assert the absence of a subset of properties in an \nobject while ignoring inherited properties and checking for deep equality.\n\n     assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});",
      "summary": "### .notDeepOwnInclude(haystack, needle, [message])",
      "body": "Asserts that 'haystack' includes 'needle'.\nCan be used to assert the absence of a subset of properties in an \nobject while ignoring inherited properties and checking for deep equality.\n\n     assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5276,
    "codeStart": 5293,
    "code": "assert.notDeepOwnInclude = function(exp, inc, msg) {\n  new Assertion(exp, msg, assert.notDeepOwnInclude, true)\n    .not.deep.own.include(inc);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notDeepOwnInclude",
      "string": "assert.notDeepOwnInclude()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "match"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp} regexp",
        "name": "regexp",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .match(value, regexp, [message])\n\nAsserts that `value` matches the regular expression `regexp`.\n\n    assert.match('foobar', /^foo/, 'regexp matches');",
      "summary": "### .match(value, regexp, [message])",
      "body": "Asserts that `value` matches the regular expression `regexp`.\n\n    assert.match('foobar', /^foo/, 'regexp matches');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5298,
    "codeStart": 5313,
    "code": "assert.match = function (exp, re, msg) {\n  new Assertion(exp, msg, assert.match, true).to.match(re);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "match",
      "string": "assert.match()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notMatch"
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp} regexp",
        "name": "regexp",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notMatch(value, regexp, [message])\n\nAsserts that `value` does not match the regular expression `regexp`.\n\n    assert.notMatch('foobar', /^foo/, 'regexp does not match');",
      "summary": "### .notMatch(value, regexp, [message])",
      "body": "Asserts that `value` does not match the regular expression `regexp`.\n\n    assert.notMatch('foobar', /^foo/, 'regexp does not match');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5317,
    "codeStart": 5332,
    "code": "assert.notMatch = function (exp, re, msg) {\n  new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notMatch",
      "string": "assert.notMatch()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "property"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .property(object, property, [message])\n\nAsserts that `object` has a direct or inherited property named by\n`property`.\n\n    assert.property({ tea: { green: 'matcha' }}, 'tea');\n    assert.property({ tea: { green: 'matcha' }}, 'toString');",
      "summary": "### .property(object, property, [message])",
      "body": "Asserts that `object` has a direct or inherited property named by\n`property`.\n\n    assert.property({ tea: { green: 'matcha' }}, 'tea');\n    assert.property({ tea: { green: 'matcha' }}, 'toString');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5336,
    "codeStart": 5353,
    "code": "assert.property = function (obj, prop, msg) {\n  new Assertion(obj, msg, assert.property, true).to.have.property(prop);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "property",
      "string": "assert.property()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notProperty"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notProperty(object, property, [message])\n\nAsserts that `object` does _not_ have a direct or inherited property named\nby `property`.\n\n    assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');",
      "summary": "### .notProperty(object, property, [message])",
      "body": "Asserts that `object` does _not_ have a direct or inherited property named\nby `property`.\n\n    assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5357,
    "codeStart": 5373,
    "code": "assert.notProperty = function (obj, prop, msg) {\n  new Assertion(obj, msg, assert.notProperty, true)\n    .to.not.have.property(prop);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notProperty",
      "string": "assert.notProperty()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "propertyVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .propertyVal(object, property, value, [message])\n\nAsserts that `object` has a direct or inherited property named by\n`property` with a value given by `value`. Uses a strict equality check\n(===).\n\n    assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');",
      "summary": "### .propertyVal(object, property, value, [message])",
      "body": "Asserts that `object` has a direct or inherited property named by\n`property` with a value given by `value`. Uses a strict equality check\n(===).\n\n    assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5378,
    "codeStart": 5396,
    "code": "assert.propertyVal = function (obj, prop, val, msg) {\n  new Assertion(obj, msg, assert.propertyVal, true)\n    .to.have.property(prop, val);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "propertyVal",
      "string": "assert.propertyVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notPropertyVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notPropertyVal(object, property, value, [message])\n\nAsserts that `object` does _not_ have a direct or inherited property named\nby `property` with value given by `value`. Uses a strict equality check\n(===).\n\n    assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');\n    assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');",
      "summary": "### .notPropertyVal(object, property, value, [message])",
      "body": "Asserts that `object` does _not_ have a direct or inherited property named\nby `property` with value given by `value`. Uses a strict equality check\n(===).\n\n    assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');\n    assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5401,
    "codeStart": 5420,
    "code": "assert.notPropertyVal = function (obj, prop, val, msg) {\n  new Assertion(obj, msg, assert.notPropertyVal, true)\n    .to.not.have.property(prop, val);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notPropertyVal",
      "string": "assert.notPropertyVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "deepPropertyVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .deepPropertyVal(object, property, value, [message])\n\nAsserts that `object` has a direct or inherited property named by\n`property` with a value given by `value`. Uses a deep equality check.\n\n    assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });",
      "summary": "### .deepPropertyVal(object, property, value, [message])",
      "body": "Asserts that `object` has a direct or inherited property named by\n`property` with a value given by `value`. Uses a deep equality check.\n\n    assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5425,
    "codeStart": 5442,
    "code": "assert.deepPropertyVal = function (obj, prop, val, msg) {\n  new Assertion(obj, msg, assert.deepPropertyVal, true)\n    .to.have.deep.property(prop, val);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "deepPropertyVal",
      "string": "assert.deepPropertyVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notDeepPropertyVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notDeepPropertyVal(object, property, value, [message])\n\nAsserts that `object` does _not_ have a direct or inherited property named\nby `property` with value given by `value`. Uses a deep equality check.\n\n    assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });\n    assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });\n    assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });",
      "summary": "### .notDeepPropertyVal(object, property, value, [message])",
      "body": "Asserts that `object` does _not_ have a direct or inherited property named\nby `property` with value given by `value`. Uses a deep equality check.\n\n    assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });\n    assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });\n    assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5447,
    "codeStart": 5466,
    "code": "assert.notDeepPropertyVal = function (obj, prop, val, msg) {\n  new Assertion(obj, msg, assert.notDeepPropertyVal, true)\n    .to.not.have.deep.property(prop, val);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notDeepPropertyVal",
      "string": "assert.notDeepPropertyVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "ownProperty"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .ownProperty(object, property, [message])\n\nAsserts that `object` has a direct property named by `property`. Inherited\nproperties aren't checked.\n\n    assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');",
      "summary": "### .ownProperty(object, property, [message])",
      "body": "Asserts that `object` has a direct property named by `property`. Inherited\nproperties aren't checked.\n\n    assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5471,
    "codeStart": 5486,
    "code": "assert.ownProperty = function (obj, prop, msg) {\n  new Assertion(obj, msg, assert.ownProperty, true)\n    .to.have.own.property(prop);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "ownProperty",
      "string": "assert.ownProperty()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notOwnProperty"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notOwnProperty(object, property, [message])\n\nAsserts that `object` does _not_ have a direct property named by\n`property`. Inherited properties aren't checked.\n\n    assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');\n    assert.notOwnProperty({}, 'toString');",
      "summary": "### .notOwnProperty(object, property, [message])",
      "body": "Asserts that `object` does _not_ have a direct property named by\n`property`. Inherited properties aren't checked.\n\n    assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');\n    assert.notOwnProperty({}, 'toString');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5491,
    "codeStart": 5507,
    "code": "assert.notOwnProperty = function (obj, prop, msg) {\n  new Assertion(obj, msg, assert.notOwnProperty, true)\n    .to.not.have.own.property(prop);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notOwnProperty",
      "string": "assert.notOwnProperty()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "ownPropertyVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .ownPropertyVal(object, property, value, [message])\n\nAsserts that `object` has a direct property named by `property` and a value\nequal to the provided `value`. Uses a strict equality check (===).\nInherited properties aren't checked.\n\n    assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');",
      "summary": "### .ownPropertyVal(object, property, value, [message])",
      "body": "Asserts that `object` has a direct property named by `property` and a value\nequal to the provided `value`. Uses a strict equality check (===).\nInherited properties aren't checked.\n\n    assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5512,
    "codeStart": 5529,
    "code": "assert.ownPropertyVal = function (obj, prop, value, msg) {\n  new Assertion(obj, msg, assert.ownPropertyVal, true)\n    .to.have.own.property(prop, value);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "ownPropertyVal",
      "string": "assert.ownPropertyVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notOwnPropertyVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notOwnPropertyVal(object, property, value, [message])\n\nAsserts that `object` does _not_ have a direct property named by `property`\nwith a value equal to the provided `value`. Uses a strict equality check\n(===). Inherited properties aren't checked.\n\n    assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');\n    assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);",
      "summary": "### .notOwnPropertyVal(object, property, value, [message])",
      "body": "Asserts that `object` does _not_ have a direct property named by `property`\nwith a value equal to the provided `value`. Uses a strict equality check\n(===). Inherited properties aren't checked.\n\n    assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');\n    assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5534,
    "codeStart": 5552,
    "code": "assert.notOwnPropertyVal = function (obj, prop, value, msg) {\n  new Assertion(obj, msg, assert.notOwnPropertyVal, true)\n    .to.not.have.own.property(prop, value);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notOwnPropertyVal",
      "string": "assert.notOwnPropertyVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "deepOwnPropertyVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .deepOwnPropertyVal(object, property, value, [message])\n\nAsserts that `object` has a direct property named by `property` and a value\nequal to the provided `value`. Uses a deep equality check. Inherited\nproperties aren't checked.\n\n    assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });",
      "summary": "### .deepOwnPropertyVal(object, property, value, [message])",
      "body": "Asserts that `object` has a direct property named by `property` and a value\nequal to the provided `value`. Uses a deep equality check. Inherited\nproperties aren't checked.\n\n    assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5557,
    "codeStart": 5574,
    "code": "assert.deepOwnPropertyVal = function (obj, prop, value, msg) {\n  new Assertion(obj, msg, assert.deepOwnPropertyVal, true)\n    .to.have.deep.own.property(prop, value);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "deepOwnPropertyVal",
      "string": "assert.deepOwnPropertyVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notDeepOwnPropertyVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notDeepOwnPropertyVal(object, property, value, [message])\n\nAsserts that `object` does _not_ have a direct property named by `property`\nwith a value equal to the provided `value`. Uses a deep equality check.\nInherited properties aren't checked.\n\n    assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });\n    assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });\n    assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });\n    assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);",
      "summary": "### .notDeepOwnPropertyVal(object, property, value, [message])",
      "body": "Asserts that `object` does _not_ have a direct property named by `property`\nwith a value equal to the provided `value`. Uses a deep equality check.\nInherited properties aren't checked.\n\n    assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });\n    assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });\n    assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });\n    assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5579,
    "codeStart": 5599,
    "code": "assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {\n  new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true)\n    .to.not.have.deep.own.property(prop, value);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notDeepOwnPropertyVal",
      "string": "assert.notDeepOwnPropertyVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "nestedProperty"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .nestedProperty(object, property, [message])\n\nAsserts that `object` has a direct or inherited property named by\n`property`, which can be a string using dot- and bracket-notation for\nnested reference.\n\n    assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');",
      "summary": "### .nestedProperty(object, property, [message])",
      "body": "Asserts that `object` has a direct or inherited property named by\n`property`, which can be a string using dot- and bracket-notation for\nnested reference.\n\n    assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5604,
    "codeStart": 5621,
    "code": "assert.nestedProperty = function (obj, prop, msg) {\n  new Assertion(obj, msg, assert.nestedProperty, true)\n    .to.have.nested.property(prop);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "nestedProperty",
      "string": "assert.nestedProperty()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notNestedProperty"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notNestedProperty(object, property, [message])\n\nAsserts that `object` does _not_ have a property named by `property`, which\ncan be a string using dot- and bracket-notation for nested reference. The\nproperty cannot exist on the object nor anywhere in its prototype chain.\n\n    assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');",
      "summary": "### .notNestedProperty(object, property, [message])",
      "body": "Asserts that `object` does _not_ have a property named by `property`, which\ncan be a string using dot- and bracket-notation for nested reference. The\nproperty cannot exist on the object nor anywhere in its prototype chain.\n\n    assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5626,
    "codeStart": 5643,
    "code": "assert.notNestedProperty = function (obj, prop, msg) {\n  new Assertion(obj, msg, assert.notNestedProperty, true)\n    .to.not.have.nested.property(prop);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notNestedProperty",
      "string": "assert.notNestedProperty()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "nestedPropertyVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .nestedPropertyVal(object, property, value, [message])\n\nAsserts that `object` has a property named by `property` with value given\nby `value`. `property` can use dot- and bracket-notation for nested\nreference. Uses a strict equality check (===).\n\n    assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');",
      "summary": "### .nestedPropertyVal(object, property, value, [message])",
      "body": "Asserts that `object` has a property named by `property` with value given\nby `value`. `property` can use dot- and bracket-notation for nested\nreference. Uses a strict equality check (===).\n\n    assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5648,
    "codeStart": 5666,
    "code": "assert.nestedPropertyVal = function (obj, prop, val, msg) {\n  new Assertion(obj, msg, assert.nestedPropertyVal, true)\n    .to.have.nested.property(prop, val);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "nestedPropertyVal",
      "string": "assert.nestedPropertyVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notNestedPropertyVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notNestedPropertyVal(object, property, value, [message])\n\nAsserts that `object` does _not_ have a property named by `property` with\nvalue given by `value`. `property` can use dot- and bracket-notation for\nnested reference. Uses a strict equality check (===).\n\n    assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\n    assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');",
      "summary": "### .notNestedPropertyVal(object, property, value, [message])",
      "body": "Asserts that `object` does _not_ have a property named by `property` with\nvalue given by `value`. `property` can use dot- and bracket-notation for\nnested reference. Uses a strict equality check (===).\n\n    assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\n    assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5671,
    "codeStart": 5690,
    "code": "assert.notNestedPropertyVal = function (obj, prop, val, msg) {\n  new Assertion(obj, msg, assert.notNestedPropertyVal, true)\n    .to.not.have.nested.property(prop, val);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notNestedPropertyVal",
      "string": "assert.notNestedPropertyVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "deepNestedPropertyVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .deepNestedPropertyVal(object, property, value, [message])\n\nAsserts that `object` has a property named by `property` with a value given\nby `value`. `property` can use dot- and bracket-notation for nested\nreference. Uses a deep equality check.\n\n    assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });",
      "summary": "### .deepNestedPropertyVal(object, property, value, [message])",
      "body": "Asserts that `object` has a property named by `property` with a value given\nby `value`. `property` can use dot- and bracket-notation for nested\nreference. Uses a deep equality check.\n\n    assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5695,
    "codeStart": 5713,
    "code": "assert.deepNestedPropertyVal = function (obj, prop, val, msg) {\n  new Assertion(obj, msg, assert.deepNestedPropertyVal, true)\n    .to.have.deep.nested.property(prop, val);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "deepNestedPropertyVal",
      "string": "assert.deepNestedPropertyVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notDeepNestedPropertyVal"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property",
        "name": "property",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notDeepNestedPropertyVal(object, property, value, [message])\n\nAsserts that `object` does _not_ have a property named by `property` with\nvalue given by `value`. `property` can use dot- and bracket-notation for\nnested reference. Uses a deep equality check.\n\n    assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });\n    assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });\n    assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });",
      "summary": "### .notDeepNestedPropertyVal(object, property, value, [message])",
      "body": "Asserts that `object` does _not_ have a property named by `property` with\nvalue given by `value`. `property` can use dot- and bracket-notation for\nnested reference. Uses a deep equality check.\n\n    assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });\n    assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });\n    assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5718,
    "codeStart": 5738,
    "code": "assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {\n  new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true)\n    .to.not.have.deep.nested.property(prop, val);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notDeepNestedPropertyVal",
      "string": "assert.notDeepNestedPropertyVal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "lengthOf"
      },
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} length",
        "name": "length",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .lengthOf(object, length, [message])\n\nAsserts that `object` has a `length` property with the expected value.\n\n    assert.lengthOf([1,2,3], 3, 'array has length of 3');\n    assert.lengthOf('foobar', 6, 'string has length of 6');",
      "summary": "### .lengthOf(object, length, [message])",
      "body": "Asserts that `object` has a `length` property with the expected value.\n\n    assert.lengthOf([1,2,3], 3, 'array has length of 3');\n    assert.lengthOf('foobar', 6, 'string has length of 6');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5743,
    "codeStart": 5759,
    "code": "assert.lengthOf = function (exp, len, msg) {\n  new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "lengthOf",
      "string": "assert.lengthOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "hasAnyKeys"
      },
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array|Object} keys",
        "name": "keys",
        "description": "",
        "types": [
          "Array",
          "Object"
        ],
        "typesDescription": "<code>Array</code>|<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .hasAnyKeys(object, [keys], [message])\n\nAsserts that `object` has at least one of the `keys` provided.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);\n    assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});\n    assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n    assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);",
      "summary": "### .hasAnyKeys(object, [keys], [message])",
      "body": "Asserts that `object` has at least one of the `keys` provided.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);\n    assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});\n    assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n    assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5763,
    "codeStart": 5783,
    "code": "assert.hasAnyKeys = function (obj, keys, msg) {\n  new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "hasAnyKeys",
      "string": "assert.hasAnyKeys()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "hasAllKeys"
      },
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String[]} keys",
        "name": "keys",
        "description": "",
        "types": [
          "Array.<String>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>String</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .hasAllKeys(object, [keys], [message])\n\nAsserts that `object` has all and only all of the `keys` provided.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);\n    assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);\n    assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n    assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);",
      "summary": "### .hasAllKeys(object, [keys], [message])",
      "body": "Asserts that `object` has all and only all of the `keys` provided.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);\n    assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);\n    assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n    assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5787,
    "codeStart": 5807,
    "code": "assert.hasAllKeys = function (obj, keys, msg) {\n  new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "hasAllKeys",
      "string": "assert.hasAllKeys()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "containsAllKeys"
      },
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String[]} keys",
        "name": "keys",
        "description": "",
        "types": [
          "Array.<String>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>String</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .containsAllKeys(object, [keys], [message])\n\nAsserts that `object` has all of the `keys` provided but may have more keys not listed.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);\n    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);\n    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});\n    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});\n    assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);\n    assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n    assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);\n    assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);",
      "summary": "### .containsAllKeys(object, [keys], [message])",
      "body": "Asserts that `object` has all of the `keys` provided but may have more keys not listed.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);\n    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);\n    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});\n    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});\n    assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);\n    assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n    assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);\n    assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5811,
    "codeStart": 5835,
    "code": "assert.containsAllKeys = function (obj, keys, msg) {\n  new Assertion(obj, msg, assert.containsAllKeys, true)\n    .to.contain.all.keys(keys);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "containsAllKeys",
      "string": "assert.containsAllKeys()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "doesNotHaveAnyKeys"
      },
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String[]} keys",
        "name": "keys",
        "description": "",
        "types": [
          "Array.<String>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>String</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .doesNotHaveAnyKeys(object, [keys], [message])\n\nAsserts that `object` has none of the `keys` provided.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);\n    assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});\n    assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);\n    assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);",
      "summary": "### .doesNotHaveAnyKeys(object, [keys], [message])",
      "body": "Asserts that `object` has none of the `keys` provided.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);\n    assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});\n    assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);\n    assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5840,
    "codeStart": 5860,
    "code": "assert.doesNotHaveAnyKeys = function (obj, keys, msg) {\n  new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true)\n    .to.not.have.any.keys(keys);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "doesNotHaveAnyKeys",
      "string": "assert.doesNotHaveAnyKeys()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "doesNotHaveAllKeys"
      },
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String[]} keys",
        "name": "keys",
        "description": "",
        "types": [
          "Array.<String>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>String</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .doesNotHaveAllKeys(object, [keys], [message])\n\nAsserts that `object` does not have at least one of the `keys` provided.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);\n    assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});\n    assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);\n    assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);",
      "summary": "### .doesNotHaveAllKeys(object, [keys], [message])",
      "body": "Asserts that `object` does not have at least one of the `keys` provided.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);\n    assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});\n    assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);\n    assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5865,
    "codeStart": 5885,
    "code": "assert.doesNotHaveAllKeys = function (obj, keys, msg) {\n  new Assertion(obj, msg, assert.doesNotHaveAllKeys, true)\n    .to.not.have.all.keys(keys);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "doesNotHaveAllKeys",
      "string": "assert.doesNotHaveAllKeys()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "doesNotHaveAllKeys"
      },
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array|Object} keys",
        "name": "keys",
        "description": "",
        "types": [
          "Array",
          "Object"
        ],
        "typesDescription": "<code>Array</code>|<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .hasAnyDeepKeys(object, [keys], [message])\n\nAsserts that `object` has at least one of the `keys` provided.\nSince Sets and Maps can have objects as keys you can use this assertion to perform\na deep comparison.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});\n    assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);\n    assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n    assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});\n    assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);\n    assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);",
      "summary": "### .hasAnyDeepKeys(object, [keys], [message])",
      "body": "Asserts that `object` has at least one of the `keys` provided.\nSince Sets and Maps can have objects as keys you can use this assertion to perform\na deep comparison.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});\n    assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);\n    assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n    assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});\n    assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);\n    assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5890,
    "codeStart": 5914,
    "code": "assert.hasAnyDeepKeys = function (obj, keys, msg) {\n  new Assertion(obj, msg, assert.hasAnyDeepKeys, true)\n    .to.have.any.deep.keys(keys);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "hasAnyDeepKeys",
      "string": "assert.hasAnyDeepKeys()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "hasAllDeepKeys"
      },
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array|Object} keys",
        "name": "keys",
        "description": "",
        "types": [
          "Array",
          "Object"
        ],
        "typesDescription": "<code>Array</code>|<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .hasAllDeepKeys(object, [keys], [message])\n\nAsserts that `object` has all and only all of the `keys` provided.\nSince Sets and Maps can have objects as keys you can use this assertion to perform\na deep comparison.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});\n    assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n    assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});\n    assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);",
      "summary": "### .hasAllDeepKeys(object, [keys], [message])",
      "body": "Asserts that `object` has all and only all of the `keys` provided.\nSince Sets and Maps can have objects as keys you can use this assertion to perform\na deep comparison.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});\n    assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n    assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});\n    assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5919,
    "codeStart": 5941,
    "code": "assert.hasAllDeepKeys = function (obj, keys, msg) {\n  new Assertion(obj, msg, assert.hasAllDeepKeys, true)\n    .to.have.all.deep.keys(keys);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "hasAllDeepKeys",
      "string": "assert.hasAllDeepKeys()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "containsAllDeepKeys"
      },
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array|Object} keys",
        "name": "keys",
        "description": "",
        "types": [
          "Array",
          "Object"
        ],
        "typesDescription": "<code>Array</code>|<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .containsAllDeepKeys(object, [keys], [message])\n\nAsserts that `object` contains all of the `keys` provided.\nSince Sets and Maps can have objects as keys you can use this assertion to perform\na deep comparison.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});\n    assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n    assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});\n    assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);",
      "summary": "### .containsAllDeepKeys(object, [keys], [message])",
      "body": "Asserts that `object` contains all of the `keys` provided.\nSince Sets and Maps can have objects as keys you can use this assertion to perform\na deep comparison.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});\n    assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n    assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});\n    assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5946,
    "codeStart": 5968,
    "code": "assert.containsAllDeepKeys = function (obj, keys, msg) {\n  new Assertion(obj, msg, assert.containsAllDeepKeys, true)\n    .to.contain.all.deep.keys(keys);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "containsAllDeepKeys",
      "string": "assert.containsAllDeepKeys()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "doesNotHaveAnyDeepKeys"
      },
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array|Object} keys",
        "name": "keys",
        "description": "",
        "types": [
          "Array",
          "Object"
        ],
        "typesDescription": "<code>Array</code>|<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .doesNotHaveAnyDeepKeys(object, [keys], [message])\n\nAsserts that `object` has none of the `keys` provided.\nSince Sets and Maps can have objects as keys you can use this assertion to perform\na deep comparison.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});\n    assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);\n    assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});\n    assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);",
      "summary": "### .doesNotHaveAnyDeepKeys(object, [keys], [message])",
      "body": "Asserts that `object` has none of the `keys` provided.\nSince Sets and Maps can have objects as keys you can use this assertion to perform\na deep comparison.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});\n    assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);\n    assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});\n    assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 5973,
    "codeStart": 5995,
    "code": "assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {\n  new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true)\n    .to.not.have.any.deep.keys(keys);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "doesNotHaveAnyDeepKeys",
      "string": "assert.doesNotHaveAnyDeepKeys()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "doesNotHaveAllDeepKeys"
      },
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array|Object} keys",
        "name": "keys",
        "description": "",
        "types": [
          "Array",
          "Object"
        ],
        "typesDescription": "<code>Array</code>|<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .doesNotHaveAllDeepKeys(object, [keys], [message])\n\nAsserts that `object` does not have at least one of the `keys` provided.\nSince Sets and Maps can have objects as keys you can use this assertion to perform\na deep comparison.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});\n    assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);\n    assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});\n    assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);",
      "summary": "### .doesNotHaveAllDeepKeys(object, [keys], [message])",
      "body": "Asserts that `object` does not have at least one of the `keys` provided.\nSince Sets and Maps can have objects as keys you can use this assertion to perform\na deep comparison.\nYou can also provide a single object instead of a `keys` array and its keys\nwill be used as the expected set of keys.\n\n    assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});\n    assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);\n    assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});\n    assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6000,
    "codeStart": 6022,
    "code": "assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {\n  new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true)\n    .to.not.have.all.deep.keys(keys);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "doesNotHaveAllDeepKeys",
      "string": "assert.doesNotHaveAllDeepKeys()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "throws"
      },
      {
        "type": "alias",
        "string": "throw"
      },
      {
        "type": "alias",
        "string": "Throw"
      },
      {
        "type": "param",
        "string": "{Function} fn",
        "name": "fn",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{ErrorConstructor|Error} errorLike",
        "name": "errorLike",
        "description": "",
        "types": [
          "ErrorConstructor",
          "Error"
        ],
        "typesDescription": "<a href=\"ErrorConstructor.html\">ErrorConstructor</a>|<code>Error</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp|String} errMsgMatcher",
        "name": "errMsgMatcher",
        "description": "",
        "types": [
          "RegExp",
          "String"
        ],
        "typesDescription": "<code>RegExp</code>|<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "see",
        "string": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types",
        "title": "",
        "url": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types"
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])\n\nIf `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an\ninstance of `errorLike`.\nIf `errorLike` is an `Error` instance, asserts that the error thrown is the same\ninstance as `errorLike`.\nIf `errMsgMatcher` is provided, it also asserts that the error thrown will have a\nmessage matching `errMsgMatcher`.\n\n    assert.throws(fn, 'function throws a reference error');\n    assert.throws(fn, /function throws a reference error/);\n    assert.throws(fn, ReferenceError);\n    assert.throws(fn, errorInstance);\n    assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');\n    assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');\n    assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);\n    assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);",
      "summary": "### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])",
      "body": "If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an\ninstance of `errorLike`.\nIf `errorLike` is an `Error` instance, asserts that the error thrown is the same\ninstance as `errorLike`.\nIf `errMsgMatcher` is provided, it also asserts that the error thrown will have a\nmessage matching `errMsgMatcher`.\n\n    assert.throws(fn, 'function throws a reference error');\n    assert.throws(fn, /function throws a reference error/);\n    assert.throws(fn, ReferenceError);\n    assert.throws(fn, errorInstance);\n    assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');\n    assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');\n    assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);\n    assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6027,
    "codeStart": 6058,
    "code": "assert.throws = function (fn, errorLike, errMsgMatcher, msg) {\n  if ('string' === typeof errorLike || errorLike instanceof RegExp) {\n    errMsgMatcher = errorLike;\n    errorLike = null;\n  }\n\n  var assertErr = new Assertion(fn, msg, assert.throws, true)\n    .to.throw(errorLike, errMsgMatcher);\n  return flag(assertErr, 'object');\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "throws",
      "string": "assert.throws()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "doesNotThrow"
      },
      {
        "type": "param",
        "string": "{Function} fn",
        "name": "fn",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{ErrorConstructor} errorLike",
        "name": "errorLike",
        "description": "",
        "types": [
          "ErrorConstructor"
        ],
        "typesDescription": "<a href=\"ErrorConstructor.html\">ErrorConstructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp|String} errMsgMatcher",
        "name": "errMsgMatcher",
        "description": "",
        "types": [
          "RegExp",
          "String"
        ],
        "typesDescription": "<code>RegExp</code>|<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "see",
        "string": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types",
        "title": "",
        "url": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types"
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])\n\nIf `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an\ninstance of `errorLike`.\nIf `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same\ninstance as `errorLike`.\nIf `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a\nmessage matching `errMsgMatcher`.\n\n    assert.doesNotThrow(fn, 'Any Error thrown must not have this message');\n    assert.doesNotThrow(fn, /Any Error thrown must not match this/);\n    assert.doesNotThrow(fn, Error);\n    assert.doesNotThrow(fn, errorInstance);\n    assert.doesNotThrow(fn, Error, 'Error must not have this message');\n    assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');\n    assert.doesNotThrow(fn, Error, /Error must not match this/);\n    assert.doesNotThrow(fn, errorInstance, /Error must not match this/);",
      "summary": "### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])",
      "body": "If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an\ninstance of `errorLike`.\nIf `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same\ninstance as `errorLike`.\nIf `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a\nmessage matching `errMsgMatcher`.\n\n    assert.doesNotThrow(fn, 'Any Error thrown must not have this message');\n    assert.doesNotThrow(fn, /Any Error thrown must not match this/);\n    assert.doesNotThrow(fn, Error);\n    assert.doesNotThrow(fn, errorInstance);\n    assert.doesNotThrow(fn, Error, 'Error must not have this message');\n    assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');\n    assert.doesNotThrow(fn, Error, /Error must not match this/);\n    assert.doesNotThrow(fn, errorInstance, /Error must not match this/);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6069,
    "codeStart": 6098,
    "code": "assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {\n  if ('string' === typeof errorLike || errorLike instanceof RegExp) {\n    errMsgMatcher = errorLike;\n    errorLike = null;\n  }\n\n  new Assertion(fn, msg, assert.doesNotThrow, true)\n    .to.not.throw(errorLike, errMsgMatcher);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "doesNotThrow",
      "string": "assert.doesNotThrow()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "operator"
      },
      {
        "type": "param",
        "string": "{Mixed} val1",
        "name": "val1",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} operator",
        "name": "operator",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} val2",
        "name": "val2",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .operator(val1, operator, val2, [message])\n\nCompares two values using `operator`.\n\n    assert.operator(1, '<', 2, 'everything is ok');\n    assert.operator(1, '>', 2, 'this will fail');",
      "summary": "### .operator(val1, operator, val2, [message])",
      "body": "Compares two values using `operator`.\n\n    assert.operator(1, '<', 2, 'everything is ok');\n    assert.operator(1, '>', 2, 'this will fail');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6108,
    "codeStart": 6125,
    "code": "assert.operator = function (val, operator, val2, msg) {\n  var ok;\n  switch(operator) {\n    case '==':\n      ok = val == val2;\n      break;\n    case '===':\n      ok = val === val2;\n      break;\n    case '>':\n      ok = val > val2;\n      break;\n    case '>=':\n      ok = val >= val2;\n      break;\n    case '<':\n      ok = val < val2;\n      break;\n    case '<=':\n      ok = val <= val2;\n      break;\n    case '!=':\n      ok = val != val2;\n      break;\n    case '!==':\n      ok = val !== val2;\n      break;\n    default:\n      msg = msg ? msg + ': ' : msg;\n      throw new chai.AssertionError(\n        msg + 'Invalid operator \"' + operator + '\"',\n        undefined,\n        assert.operator\n      );\n  }\n  var test = new Assertion(ok, msg, assert.operator, true);\n  test.assert(\n      true === flag(test, 'object')\n    , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)\n    , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "operator",
      "string": "assert.operator()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "closeTo"
      },
      {
        "type": "param",
        "string": "{Number} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} delta",
        "name": "delta",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .closeTo(actual, expected, delta, [message])\n\nAsserts that the target is equal `expected`, to within a +/- `delta` range.\n\n    assert.closeTo(1.5, 1, 0.5, 'numbers are close');",
      "summary": "### .closeTo(actual, expected, delta, [message])",
      "body": "Asserts that the target is equal `expected`, to within a +/- `delta` range.\n\n    assert.closeTo(1.5, 1, 0.5, 'numbers are close');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6167,
    "codeStart": 6183,
    "code": "assert.closeTo = function (act, exp, delta, msg) {\n  new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "closeTo",
      "string": "assert.closeTo()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "approximately"
      },
      {
        "type": "param",
        "string": "{Number} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} delta",
        "name": "delta",
        "description": "",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .approximately(actual, expected, delta, [message])\n\nAsserts that the target is equal `expected`, to within a +/- `delta` range.\n\n    assert.approximately(1.5, 1, 0.5, 'numbers are close');",
      "summary": "### .approximately(actual, expected, delta, [message])",
      "body": "Asserts that the target is equal `expected`, to within a +/- `delta` range.\n\n    assert.approximately(1.5, 1, 0.5, 'numbers are close');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6187,
    "codeStart": 6203,
    "code": "assert.approximately = function (act, exp, delta, msg) {\n  new Assertion(act, msg, assert.approximately, true)\n    .to.be.approximately(exp, delta);\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "approximately",
      "string": "assert.approximately()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "sameMembers"
      },
      {
        "type": "param",
        "string": "{Array} set1",
        "name": "set1",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} set2",
        "name": "set2",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .sameMembers(set1, set2, [message])\n\nAsserts that `set1` and `set2` have the same members in any order. Uses a\nstrict equality check (===).\n\n    assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');",
      "summary": "### .sameMembers(set1, set2, [message])",
      "body": "Asserts that `set1` and `set2` have the same members in any order. Uses a\nstrict equality check (===).\n\n    assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6208,
    "codeStart": 6224,
    "code": "assert.sameMembers = function (set1, set2, msg) {\n  new Assertion(set1, msg, assert.sameMembers, true)\n    .to.have.same.members(set2);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "sameMembers",
      "string": "assert.sameMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notSameMembers"
      },
      {
        "type": "param",
        "string": "{Array} set1",
        "name": "set1",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} set2",
        "name": "set2",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notSameMembers(set1, set2, [message])\n\nAsserts that `set1` and `set2` don't have the same members in any order.\nUses a strict equality check (===).\n\n    assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');",
      "summary": "### .notSameMembers(set1, set2, [message])",
      "body": "Asserts that `set1` and `set2` don't have the same members in any order.\nUses a strict equality check (===).\n\n    assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6229,
    "codeStart": 6245,
    "code": "assert.notSameMembers = function (set1, set2, msg) {\n  new Assertion(set1, msg, assert.notSameMembers, true)\n    .to.not.have.same.members(set2);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notSameMembers",
      "string": "assert.notSameMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "sameDeepMembers"
      },
      {
        "type": "param",
        "string": "{Array} set1",
        "name": "set1",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} set2",
        "name": "set2",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .sameDeepMembers(set1, set2, [message])\n\nAsserts that `set1` and `set2` have the same members in any order. Uses a\ndeep equality check.\n\n    assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');",
      "summary": "### .sameDeepMembers(set1, set2, [message])",
      "body": "Asserts that `set1` and `set2` have the same members in any order. Uses a\ndeep equality check.\n\n    assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6250,
    "codeStart": 6266,
    "code": "assert.sameDeepMembers = function (set1, set2, msg) {\n  new Assertion(set1, msg, assert.sameDeepMembers, true)\n    .to.have.same.deep.members(set2);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "sameDeepMembers",
      "string": "assert.sameDeepMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notSameDeepMembers"
      },
      {
        "type": "param",
        "string": "{Array} set1",
        "name": "set1",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} set2",
        "name": "set2",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notSameDeepMembers(set1, set2, [message])\n\nAsserts that `set1` and `set2` don't have the same members in any order.\nUses a deep equality check.\n\n    assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');",
      "summary": "### .notSameDeepMembers(set1, set2, [message])",
      "body": "Asserts that `set1` and `set2` don't have the same members in any order.\nUses a deep equality check.\n\n    assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6271,
    "codeStart": 6287,
    "code": "assert.notSameDeepMembers = function (set1, set2, msg) {\n  new Assertion(set1, msg, assert.notSameDeepMembers, true)\n    .to.not.have.same.deep.members(set2);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notSameDeepMembers",
      "string": "assert.notSameDeepMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "sameOrderedMembers"
      },
      {
        "type": "param",
        "string": "{Array} set1",
        "name": "set1",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} set2",
        "name": "set2",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .sameOrderedMembers(set1, set2, [message])\n\nAsserts that `set1` and `set2` have the same members in the same order.\nUses a strict equality check (===).\n\n    assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');",
      "summary": "### .sameOrderedMembers(set1, set2, [message])",
      "body": "Asserts that `set1` and `set2` have the same members in the same order.\nUses a strict equality check (===).\n\n    assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6292,
    "codeStart": 6308,
    "code": "assert.sameOrderedMembers = function (set1, set2, msg) {\n  new Assertion(set1, msg, assert.sameOrderedMembers, true)\n    .to.have.same.ordered.members(set2);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "sameOrderedMembers",
      "string": "assert.sameOrderedMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notSameOrderedMembers"
      },
      {
        "type": "param",
        "string": "{Array} set1",
        "name": "set1",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} set2",
        "name": "set2",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notSameOrderedMembers(set1, set2, [message])\n\nAsserts that `set1` and `set2` don't have the same members in the same\norder. Uses a strict equality check (===).\n\n    assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');",
      "summary": "### .notSameOrderedMembers(set1, set2, [message])",
      "body": "Asserts that `set1` and `set2` don't have the same members in the same\norder. Uses a strict equality check (===).\n\n    assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6313,
    "codeStart": 6329,
    "code": "assert.notSameOrderedMembers = function (set1, set2, msg) {\n  new Assertion(set1, msg, assert.notSameOrderedMembers, true)\n    .to.not.have.same.ordered.members(set2);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notSameOrderedMembers",
      "string": "assert.notSameOrderedMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "sameDeepOrderedMembers"
      },
      {
        "type": "param",
        "string": "{Array} set1",
        "name": "set1",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} set2",
        "name": "set2",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .sameDeepOrderedMembers(set1, set2, [message])\n\nAsserts that `set1` and `set2` have the same members in the same order.\nUses a deep equality check.\n\nassert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');",
      "summary": "### .sameDeepOrderedMembers(set1, set2, [message])",
      "body": "Asserts that `set1` and `set2` have the same members in the same order.\nUses a deep equality check.\n\nassert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6334,
    "codeStart": 6350,
    "code": "assert.sameDeepOrderedMembers = function (set1, set2, msg) {\n  new Assertion(set1, msg, assert.sameDeepOrderedMembers, true)\n    .to.have.same.deep.ordered.members(set2);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "sameDeepOrderedMembers",
      "string": "assert.sameDeepOrderedMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notSameDeepOrderedMembers"
      },
      {
        "type": "param",
        "string": "{Array} set1",
        "name": "set1",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} set2",
        "name": "set2",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notSameDeepOrderedMembers(set1, set2, [message])\n\nAsserts that `set1` and `set2` don't have the same members in the same\norder. Uses a deep equality check.\n\nassert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');\nassert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');",
      "summary": "### .notSameDeepOrderedMembers(set1, set2, [message])",
      "body": "Asserts that `set1` and `set2` don't have the same members in the same\norder. Uses a deep equality check.\n\nassert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');\nassert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6355,
    "codeStart": 6372,
    "code": "assert.notSameDeepOrderedMembers = function (set1, set2, msg) {\n  new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true)\n    .to.not.have.same.deep.ordered.members(set2);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notSameDeepOrderedMembers",
      "string": "assert.notSameDeepOrderedMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "includeMembers"
      },
      {
        "type": "param",
        "string": "{Array} superset",
        "name": "superset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} subset",
        "name": "subset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .includeMembers(superset, subset, [message])\n\nAsserts that `subset` is included in `superset` in any order. Uses a\nstrict equality check (===). Duplicates are ignored.\n\n    assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');",
      "summary": "### .includeMembers(superset, subset, [message])",
      "body": "Asserts that `subset` is included in `superset` in any order. Uses a\nstrict equality check (===). Duplicates are ignored.\n\n    assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6377,
    "codeStart": 6393,
    "code": "assert.includeMembers = function (superset, subset, msg) {\n  new Assertion(superset, msg, assert.includeMembers, true)\n    .to.include.members(subset);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "includeMembers",
      "string": "assert.includeMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notIncludeMembers"
      },
      {
        "type": "param",
        "string": "{Array} superset",
        "name": "superset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} subset",
        "name": "subset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notIncludeMembers(superset, subset, [message])\n\nAsserts that `subset` isn't included in `superset` in any order. Uses a\nstrict equality check (===). Duplicates are ignored.\n\n    assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');",
      "summary": "### .notIncludeMembers(superset, subset, [message])",
      "body": "Asserts that `subset` isn't included in `superset` in any order. Uses a\nstrict equality check (===). Duplicates are ignored.\n\n    assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6398,
    "codeStart": 6414,
    "code": "assert.notIncludeMembers = function (superset, subset, msg) {\n  new Assertion(superset, msg, assert.notIncludeMembers, true)\n    .to.not.include.members(subset);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notIncludeMembers",
      "string": "assert.notIncludeMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "includeDeepMembers"
      },
      {
        "type": "param",
        "string": "{Array} superset",
        "name": "superset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} subset",
        "name": "subset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .includeDeepMembers(superset, subset, [message])\n\nAsserts that `subset` is included in `superset` in any order. Uses a deep\nequality check. Duplicates are ignored.\n\n    assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');",
      "summary": "### .includeDeepMembers(superset, subset, [message])",
      "body": "Asserts that `subset` is included in `superset` in any order. Uses a deep\nequality check. Duplicates are ignored.\n\n    assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6419,
    "codeStart": 6435,
    "code": "assert.includeDeepMembers = function (superset, subset, msg) {\n  new Assertion(superset, msg, assert.includeDeepMembers, true)\n    .to.include.deep.members(subset);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "includeDeepMembers",
      "string": "assert.includeDeepMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notIncludeDeepMembers"
      },
      {
        "type": "param",
        "string": "{Array} superset",
        "name": "superset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} subset",
        "name": "subset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notIncludeDeepMembers(superset, subset, [message])\n\nAsserts that `subset` isn't included in `superset` in any order. Uses a\ndeep equality check. Duplicates are ignored.\n\n    assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');",
      "summary": "### .notIncludeDeepMembers(superset, subset, [message])",
      "body": "Asserts that `subset` isn't included in `superset` in any order. Uses a\ndeep equality check. Duplicates are ignored.\n\n    assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6440,
    "codeStart": 6456,
    "code": "assert.notIncludeDeepMembers = function (superset, subset, msg) {\n  new Assertion(superset, msg, assert.notIncludeDeepMembers, true)\n    .to.not.include.deep.members(subset);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notIncludeDeepMembers",
      "string": "assert.notIncludeDeepMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "includeOrderedMembers"
      },
      {
        "type": "param",
        "string": "{Array} superset",
        "name": "superset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} subset",
        "name": "subset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .includeOrderedMembers(superset, subset, [message])\n\nAsserts that `subset` is included in `superset` in the same order\nbeginning with the first element in `superset`. Uses a strict equality\ncheck (===).\n\n    assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');",
      "summary": "### .includeOrderedMembers(superset, subset, [message])",
      "body": "Asserts that `subset` is included in `superset` in the same order\nbeginning with the first element in `superset`. Uses a strict equality\ncheck (===).\n\n    assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6461,
    "codeStart": 6478,
    "code": "assert.includeOrderedMembers = function (superset, subset, msg) {\n  new Assertion(superset, msg, assert.includeOrderedMembers, true)\n    .to.include.ordered.members(subset);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "includeOrderedMembers",
      "string": "assert.includeOrderedMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notIncludeOrderedMembers"
      },
      {
        "type": "param",
        "string": "{Array} superset",
        "name": "superset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} subset",
        "name": "subset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notIncludeOrderedMembers(superset, subset, [message])\n\nAsserts that `subset` isn't included in `superset` in the same order\nbeginning with the first element in `superset`. Uses a strict equality\ncheck (===).\n\n    assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');\n    assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');",
      "summary": "### .notIncludeOrderedMembers(superset, subset, [message])",
      "body": "Asserts that `subset` isn't included in `superset` in the same order\nbeginning with the first element in `superset`. Uses a strict equality\ncheck (===).\n\n    assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');\n    assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6483,
    "codeStart": 6501,
    "code": "assert.notIncludeOrderedMembers = function (superset, subset, msg) {\n  new Assertion(superset, msg, assert.notIncludeOrderedMembers, true)\n    .to.not.include.ordered.members(subset);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notIncludeOrderedMembers",
      "string": "assert.notIncludeOrderedMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "includeDeepOrderedMembers"
      },
      {
        "type": "param",
        "string": "{Array} superset",
        "name": "superset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} subset",
        "name": "subset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .includeDeepOrderedMembers(superset, subset, [message])\n\nAsserts that `subset` is included in `superset` in the same order\nbeginning with the first element in `superset`. Uses a deep equality\ncheck.\n\n    assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');",
      "summary": "### .includeDeepOrderedMembers(superset, subset, [message])",
      "body": "Asserts that `subset` is included in `superset` in the same order\nbeginning with the first element in `superset`. Uses a deep equality\ncheck.\n\n    assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6506,
    "codeStart": 6523,
    "code": "assert.includeDeepOrderedMembers = function (superset, subset, msg) {\n  new Assertion(superset, msg, assert.includeDeepOrderedMembers, true)\n    .to.include.deep.ordered.members(subset);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "includeDeepOrderedMembers",
      "string": "assert.includeDeepOrderedMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "notIncludeDeepOrderedMembers"
      },
      {
        "type": "param",
        "string": "{Array} superset",
        "name": "superset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} subset",
        "name": "subset",
        "description": "",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .notIncludeDeepOrderedMembers(superset, subset, [message])\n\nAsserts that `subset` isn't included in `superset` in the same order\nbeginning with the first element in `superset`. Uses a deep equality\ncheck.\n\n    assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');\n    assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');\n    assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');",
      "summary": "### .notIncludeDeepOrderedMembers(superset, subset, [message])",
      "body": "Asserts that `subset` isn't included in `superset` in the same order\nbeginning with the first element in `superset`. Uses a deep equality\ncheck.\n\n    assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');\n    assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');\n    assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6528,
    "codeStart": 6547,
    "code": "assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {\n  new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true)\n    .to.not.include.deep.ordered.members(subset);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "notIncludeDeepOrderedMembers",
      "string": "assert.notIncludeDeepOrderedMembers()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "oneOf"
      },
      {
        "type": "param",
        "string": "{*} inList",
        "name": "inList",
        "description": "",
        "types": [],
        "typesDescription": "<code>*</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array<*>} list",
        "name": "list",
        "description": "",
        "types": [
          "Array.<*>"
        ],
        "typesDescription": "<code>Array</code>.&lt;<code>*</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .oneOf(inList, list, [message])\n\nAsserts that non-object, non-array value `inList` appears in the flat array `list`.\n\n    assert.oneOf(1, [ 2, 1 ], 'Not found in list');",
      "summary": "### .oneOf(inList, list, [message])",
      "body": "Asserts that non-object, non-array value `inList` appears in the flat array `list`.\n\n    assert.oneOf(1, [ 2, 1 ], 'Not found in list');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6552,
    "codeStart": 6567,
    "code": "assert.oneOf = function (inList, list, msg) {\n  new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "oneOf",
      "string": "assert.oneOf()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "changes"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object or getter function",
        "name": "object",
        "description": "or getter function",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name _optional_",
        "name": "property",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .changes(function, object, property, [message])\n\nAsserts that a function changes the value of a property.\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 22 };\n    assert.changes(fn, obj, 'val');",
      "summary": "### .changes(function, object, property, [message])",
      "body": "Asserts that a function changes the value of a property.\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 22 };\n    assert.changes(fn, obj, 'val');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6571,
    "codeStart": 6589,
    "code": "assert.changes = function (fn, obj, prop, msg) {\n  if (arguments.length === 3 && typeof obj === 'function') {\n    msg = prop;\n    prop = null;\n  }\n\n  new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "changes",
      "string": "assert.changes()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "changesBy"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object or getter function",
        "name": "object",
        "description": "or getter function",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name _optional_",
        "name": "property",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} change amount (delta)",
        "name": "change",
        "description": "amount (delta)",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .changesBy(function, object, property, delta, [message])\n\nAsserts that a function changes the value of a property by an amount (delta).\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val += 2 };\n    assert.changesBy(fn, obj, 'val', 2);",
      "summary": "### .changesBy(function, object, property, delta, [message])",
      "body": "Asserts that a function changes the value of a property by an amount (delta).\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val += 2 };\n    assert.changesBy(fn, obj, 'val', 2);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6598,
    "codeStart": 6617,
    "code": "assert.changesBy = function (fn, obj, prop, delta, msg) {\n  if (arguments.length === 4 && typeof obj === 'function') {\n    var tmpMsg = delta;\n    delta = prop;\n    msg = tmpMsg;\n  } else if (arguments.length === 3) {\n    delta = prop;\n    prop = null;\n  }\n\n  new Assertion(fn, msg, assert.changesBy, true)\n    .to.change(obj, prop).by(delta);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "changesBy",
      "string": "assert.changesBy()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "doesNotChange"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object or getter function",
        "name": "object",
        "description": "or getter function",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name _optional_",
        "name": "property",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .doesNotChange(function, object, property, [message])\n\nAsserts that a function does not change the value of a property.\n\n    var obj = { val: 10 };\n    var fn = function() { console.log('foo'); };\n    assert.doesNotChange(fn, obj, 'val');",
      "summary": "### .doesNotChange(function, object, property, [message])",
      "body": "Asserts that a function does not change the value of a property.\n\n    var obj = { val: 10 };\n    var fn = function() { console.log('foo'); };\n    assert.doesNotChange(fn, obj, 'val');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6631,
    "codeStart": 6649,
    "code": "assert.doesNotChange = function (fn, obj, prop, msg) {\n  if (arguments.length === 3 && typeof obj === 'function') {\n    msg = prop;\n    prop = null;\n  }\n\n  return new Assertion(fn, msg, assert.doesNotChange, true)\n    .to.not.change(obj, prop);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "doesNotChange",
      "string": "assert.doesNotChange()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "changesButNotBy"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object or getter function",
        "name": "object",
        "description": "or getter function",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name _optional_",
        "name": "property",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} change amount (delta)",
        "name": "change",
        "description": "amount (delta)",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .changesButNotBy(function, object, property, delta, [message])\n\nAsserts that a function does not change the value of a property or of a function's return value by an amount (delta)\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val += 10 };\n    assert.changesButNotBy(fn, obj, 'val', 5);",
      "summary": "### .changesButNotBy(function, object, property, delta, [message])",
      "body": "Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val += 10 };\n    assert.changesButNotBy(fn, obj, 'val', 5);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6659,
    "codeStart": 6678,
    "code": "assert.changesButNotBy = function (fn, obj, prop, delta, msg) {\n  if (arguments.length === 4 && typeof obj === 'function') {\n    var tmpMsg = delta;\n    delta = prop;\n    msg = tmpMsg;\n  } else if (arguments.length === 3) {\n    delta = prop;\n    prop = null;\n  }\n\n  new Assertion(fn, msg, assert.changesButNotBy, true)\n    .to.change(obj, prop).but.not.by(delta);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "changesButNotBy",
      "string": "assert.changesButNotBy()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "increases"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object or getter function",
        "name": "object",
        "description": "or getter function",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name _optional_",
        "name": "property",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .increases(function, object, property, [message])\n\nAsserts that a function increases a numeric object property.\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 13 };\n    assert.increases(fn, obj, 'val');",
      "summary": "### .increases(function, object, property, [message])",
      "body": "Asserts that a function increases a numeric object property.\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 13 };\n    assert.increases(fn, obj, 'val');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6692,
    "codeStart": 6710,
    "code": "assert.increases = function (fn, obj, prop, msg) {\n  if (arguments.length === 3 && typeof obj === 'function') {\n    msg = prop;\n    prop = null;\n  }\n\n  return new Assertion(fn, msg, assert.increases, true)\n    .to.increase(obj, prop);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "increases",
      "string": "assert.increases()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "increasesBy"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object or getter function",
        "name": "object",
        "description": "or getter function",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name _optional_",
        "name": "property",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} change amount (delta)",
        "name": "change",
        "description": "amount (delta)",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .increasesBy(function, object, property, delta, [message])\n\nAsserts that a function increases a numeric object property or a function's return value by an amount (delta).\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val += 10 };\n    assert.increasesBy(fn, obj, 'val', 10);",
      "summary": "### .increasesBy(function, object, property, delta, [message])",
      "body": "Asserts that a function increases a numeric object property or a function's return value by an amount (delta).\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val += 10 };\n    assert.increasesBy(fn, obj, 'val', 10);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6720,
    "codeStart": 6739,
    "code": "assert.increasesBy = function (fn, obj, prop, delta, msg) {\n  if (arguments.length === 4 && typeof obj === 'function') {\n    var tmpMsg = delta;\n    delta = prop;\n    msg = tmpMsg;\n  } else if (arguments.length === 3) {\n    delta = prop;\n    prop = null;\n  }\n\n  new Assertion(fn, msg, assert.increasesBy, true)\n    .to.increase(obj, prop).by(delta);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "increasesBy",
      "string": "assert.increasesBy()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "doesNotIncrease"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object or getter function",
        "name": "object",
        "description": "or getter function",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name _optional_",
        "name": "property",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .doesNotIncrease(function, object, property, [message])\n\nAsserts that a function does not increase a numeric object property.\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 8 };\n    assert.doesNotIncrease(fn, obj, 'val');",
      "summary": "### .doesNotIncrease(function, object, property, [message])",
      "body": "Asserts that a function does not increase a numeric object property.\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 8 };\n    assert.doesNotIncrease(fn, obj, 'val');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6753,
    "codeStart": 6771,
    "code": "assert.doesNotIncrease = function (fn, obj, prop, msg) {\n  if (arguments.length === 3 && typeof obj === 'function') {\n    msg = prop;\n    prop = null;\n  }\n\n  return new Assertion(fn, msg, assert.doesNotIncrease, true)\n    .to.not.increase(obj, prop);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "doesNotIncrease",
      "string": "assert.doesNotIncrease()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "increasesButNotBy"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object or getter function",
        "name": "object",
        "description": "or getter function",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name _optional_",
        "name": "property",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} change amount (delta)",
        "name": "change",
        "description": "amount (delta)",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .increasesButNotBy(function, object, property, [message])\n\nAsserts that a function does not increase a numeric object property or function's return value by an amount (delta).\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 15 };\n    assert.increasesButNotBy(fn, obj, 'val', 10);",
      "summary": "### .increasesButNotBy(function, object, property, [message])",
      "body": "Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 15 };\n    assert.increasesButNotBy(fn, obj, 'val', 10);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6781,
    "codeStart": 6800,
    "code": "assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {\n  if (arguments.length === 4 && typeof obj === 'function') {\n    var tmpMsg = delta;\n    delta = prop;\n    msg = tmpMsg;\n  } else if (arguments.length === 3) {\n    delta = prop;\n    prop = null;\n  }\n\n  new Assertion(fn, msg, assert.increasesButNotBy, true)\n    .to.increase(obj, prop).but.not.by(delta);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "increasesButNotBy",
      "string": "assert.increasesButNotBy()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "decreases"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object or getter function",
        "name": "object",
        "description": "or getter function",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name _optional_",
        "name": "property",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .decreases(function, object, property, [message])\n\nAsserts that a function decreases a numeric object property.\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 5 };\n    assert.decreases(fn, obj, 'val');",
      "summary": "### .decreases(function, object, property, [message])",
      "body": "Asserts that a function decreases a numeric object property.\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 5 };\n    assert.decreases(fn, obj, 'val');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6814,
    "codeStart": 6832,
    "code": "assert.decreases = function (fn, obj, prop, msg) {\n  if (arguments.length === 3 && typeof obj === 'function') {\n    msg = prop;\n    prop = null;\n  }\n\n  return new Assertion(fn, msg, assert.decreases, true)\n    .to.decrease(obj, prop);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "decreases",
      "string": "assert.decreases()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "decreasesBy"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object or getter function",
        "name": "object",
        "description": "or getter function",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name _optional_",
        "name": "property",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} change amount (delta)",
        "name": "change",
        "description": "amount (delta)",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .decreasesBy(function, object, property, delta, [message])\n\nAsserts that a function decreases a numeric object property or a function's return value by an amount (delta)\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val -= 5 };\n    assert.decreasesBy(fn, obj, 'val', 5);",
      "summary": "### .decreasesBy(function, object, property, delta, [message])",
      "body": "Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val -= 5 };\n    assert.decreasesBy(fn, obj, 'val', 5);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6842,
    "codeStart": 6861,
    "code": "assert.decreasesBy = function (fn, obj, prop, delta, msg) {\n  if (arguments.length === 4 && typeof obj === 'function') {\n    var tmpMsg = delta;\n    delta = prop;\n    msg = tmpMsg;\n  } else if (arguments.length === 3) {\n    delta = prop;\n    prop = null;\n  }\n\n  new Assertion(fn, msg, assert.decreasesBy, true)\n    .to.decrease(obj, prop).by(delta);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "decreasesBy",
      "string": "assert.decreasesBy()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "doesNotDecrease"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object or getter function",
        "name": "object",
        "description": "or getter function",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name _optional_",
        "name": "property",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .doesNotDecrease(function, object, property, [message])\n\nAsserts that a function does not decreases a numeric object property.\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 15 };\n    assert.doesNotDecrease(fn, obj, 'val');",
      "summary": "### .doesNotDecrease(function, object, property, [message])",
      "body": "Asserts that a function does not decreases a numeric object property.\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 15 };\n    assert.doesNotDecrease(fn, obj, 'val');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6875,
    "codeStart": 6893,
    "code": "assert.doesNotDecrease = function (fn, obj, prop, msg) {\n  if (arguments.length === 3 && typeof obj === 'function') {\n    msg = prop;\n    prop = null;\n  }\n\n  return new Assertion(fn, msg, assert.doesNotDecrease, true)\n    .to.not.decrease(obj, prop);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "doesNotDecrease",
      "string": "assert.doesNotDecrease()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "doesNotDecrease"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object or getter function",
        "name": "object",
        "description": "or getter function",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name _optional_",
        "name": "property",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} change amount (delta)",
        "name": "change",
        "description": "amount (delta)",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .doesNotDecreaseBy(function, object, property, delta, [message])\n\nAsserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 5 };\n    assert.doesNotDecreaseBy(fn, obj, 'val', 1);",
      "summary": "### .doesNotDecreaseBy(function, object, property, delta, [message])",
      "body": "Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 5 };\n    assert.doesNotDecreaseBy(fn, obj, 'val', 1);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6903,
    "codeStart": 6922,
    "code": "assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {\n  if (arguments.length === 4 && typeof obj === 'function') {\n    var tmpMsg = delta;\n    delta = prop;\n    msg = tmpMsg;\n  } else if (arguments.length === 3) {\n    delta = prop;\n    prop = null;\n  }\n\n  return new Assertion(fn, msg, assert.doesNotDecreaseBy, true)\n    .to.not.decrease(obj, prop).by(delta);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "doesNotDecreaseBy",
      "string": "assert.doesNotDecreaseBy()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "decreasesButNotBy"
      },
      {
        "type": "param",
        "string": "{Function} modifier function",
        "name": "modifier",
        "description": "function",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object or getter function",
        "name": "object",
        "description": "or getter function",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} property name _optional_",
        "name": "property",
        "description": "name _optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} change amount (delta)",
        "name": "change",
        "description": "amount (delta)",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .decreasesButNotBy(function, object, property, delta, [message])\n\nAsserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 5 };\n    assert.decreasesButNotBy(fn, obj, 'val', 1);",
      "summary": "### .decreasesButNotBy(function, object, property, delta, [message])",
      "body": "Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)\n\n    var obj = { val: 10 };\n    var fn = function() { obj.val = 5 };\n    assert.decreasesButNotBy(fn, obj, 'val', 1);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6936,
    "codeStart": 6955,
    "code": "assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {\n  if (arguments.length === 4 && typeof obj === 'function') {\n    var tmpMsg = delta;\n    delta = prop;\n    msg = tmpMsg;\n  } else if (arguments.length === 3) {\n    delta = prop;\n    prop = null;\n  }\n\n  new Assertion(fn, msg, assert.decreasesButNotBy, true)\n    .to.decrease(obj, prop).but.not.by(delta);\n}",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "decreasesButNotBy",
      "string": "assert.decreasesButNotBy()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "ifError"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .ifError(object)\n\nAsserts if value is not a false value, and throws if it is a true value.\nThis is added to allow for chai to be a drop-in replacement for Node's\nassert class.\n\n    var err = new Error('I am a custom error');\n    assert.ifError(err); // Rethrows err!",
      "summary": "### .ifError(object)",
      "body": "Asserts if value is not a false value, and throws if it is a true value.\nThis is added to allow for chai to be a drop-in replacement for Node's\nassert class.\n\n    var err = new Error('I am a custom error');\n    assert.ifError(err); // Rethrows err!"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 6969,
    "codeStart": 6985,
    "code": "assert.ifError = function (val) {\n  if (val) {\n    throw(val);\n  }\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "ifError",
      "string": "assert.ifError()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isExtensible"
      },
      {
        "type": "alias",
        "string": "extensible"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isExtensible(object)\n\nAsserts that `object` is extensible (can have new properties added to it).\n\n    assert.isExtensible({});",
      "summary": "### .isExtensible(object)",
      "body": "Asserts that `object` is extensible (can have new properties added to it).\n\n    assert.isExtensible({});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 6991,
    "codeStart": 7006,
    "code": "assert.isExtensible = function (obj, msg) {\n  new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isExtensible",
      "string": "assert.isExtensible()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotExtensible"
      },
      {
        "type": "alias",
        "string": "notExtensible"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotExtensible(object)\n\nAsserts that `object` is _not_ extensible.\n\n    var nonExtensibleObject = Object.preventExtensions({});\n    var sealedObject = Object.seal({});\n    var frozenObject = Object.freeze({});\n\n    assert.isNotExtensible(nonExtensibleObject);\n    assert.isNotExtensible(sealedObject);\n    assert.isNotExtensible(frozenObject);",
      "summary": "### .isNotExtensible(object)",
      "body": "Asserts that `object` is _not_ extensible.\n\n    var nonExtensibleObject = Object.preventExtensions({});\n    var sealedObject = Object.seal({});\n    var frozenObject = Object.freeze({});\n\n    assert.isNotExtensible(nonExtensibleObject);\n    assert.isNotExtensible(sealedObject);\n    assert.isNotExtensible(frozenObject);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7010,
    "codeStart": 7031,
    "code": "assert.isNotExtensible = function (obj, msg) {\n  new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotExtensible",
      "string": "assert.isNotExtensible()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isSealed"
      },
      {
        "type": "alias",
        "string": "sealed"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isSealed(object)\n\nAsserts that `object` is sealed (cannot have new properties added to it\nand its existing properties cannot be removed).\n\n    var sealedObject = Object.seal({});\n    var frozenObject = Object.seal({});\n\n    assert.isSealed(sealedObject);\n    assert.isSealed(frozenObject);",
      "summary": "### .isSealed(object)",
      "body": "Asserts that `object` is sealed (cannot have new properties added to it\nand its existing properties cannot be removed).\n\n    var sealedObject = Object.seal({});\n    var frozenObject = Object.seal({});\n\n    assert.isSealed(sealedObject);\n    assert.isSealed(frozenObject);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7035,
    "codeStart": 7055,
    "code": "assert.isSealed = function (obj, msg) {\n  new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isSealed",
      "string": "assert.isSealed()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotSealed"
      },
      {
        "type": "alias",
        "string": "notSealed"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotSealed(object)\n\nAsserts that `object` is _not_ sealed.\n\n    assert.isNotSealed({});",
      "summary": "### .isNotSealed(object)",
      "body": "Asserts that `object` is _not_ sealed.\n\n    assert.isNotSealed({});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7059,
    "codeStart": 7074,
    "code": "assert.isNotSealed = function (obj, msg) {\n  new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotSealed",
      "string": "assert.isNotSealed()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isFrozen"
      },
      {
        "type": "alias",
        "string": "frozen"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isFrozen(object)\n\nAsserts that `object` is frozen (cannot have new properties added to it\nand its existing properties cannot be modified).\n\n    var frozenObject = Object.freeze({});\n    assert.frozen(frozenObject);",
      "summary": "### .isFrozen(object)",
      "body": "Asserts that `object` is frozen (cannot have new properties added to it\nand its existing properties cannot be modified).\n\n    var frozenObject = Object.freeze({});\n    assert.frozen(frozenObject);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7078,
    "codeStart": 7095,
    "code": "assert.isFrozen = function (obj, msg) {\n  new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isFrozen",
      "string": "assert.isFrozen()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotFrozen"
      },
      {
        "type": "alias",
        "string": "notFrozen"
      },
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotFrozen(object)\n\nAsserts that `object` is _not_ frozen.\n\n    assert.isNotFrozen({});",
      "summary": "### .isNotFrozen(object)",
      "body": "Asserts that `object` is _not_ frozen.\n\n    assert.isNotFrozen({});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7099,
    "codeStart": 7114,
    "code": "assert.isNotFrozen = function (obj, msg) {\n  new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotFrozen",
      "string": "assert.isNotFrozen()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isEmpty"
      },
      {
        "type": "alias",
        "string": "empty"
      },
      {
        "type": "param",
        "string": "{Object|Array|String|Map|Set} target",
        "name": "target",
        "description": "",
        "types": [
          "Object",
          "Array",
          "String",
          "Map",
          "Set"
        ],
        "typesDescription": "<code>Object</code>|<code>Array</code>|<code>String</code>|<a href=\"Map.html\">Map</a>|<a href=\"Set.html\">Set</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isEmpty(target)\n\nAsserts that the target does not contain any values.\nFor arrays and strings, it checks the `length` property.\nFor `Map` and `Set` instances, it checks the `size` property.\nFor non-function objects, it gets the count of own\nenumerable string keys.\n\n    assert.isEmpty([]);\n    assert.isEmpty('');\n    assert.isEmpty(new Map);\n    assert.isEmpty({});",
      "summary": "### .isEmpty(target)",
      "body": "Asserts that the target does not contain any values.\nFor arrays and strings, it checks the `length` property.\nFor `Map` and `Set` instances, it checks the `size` property.\nFor non-function objects, it gets the count of own\nenumerable string keys.\n\n    assert.isEmpty([]);\n    assert.isEmpty('');\n    assert.isEmpty(new Map);\n    assert.isEmpty({});"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7118,
    "codeStart": 7140,
    "code": "assert.isEmpty = function(val, msg) {\n  new Assertion(val, msg, assert.isEmpty, true).to.be.empty;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isEmpty",
      "string": "assert.isEmpty()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "isNotEmpty"
      },
      {
        "type": "alias",
        "string": "notEmpty"
      },
      {
        "type": "param",
        "string": "{Object|Array|String|Map|Set} target",
        "name": "target",
        "description": "",
        "types": [
          "Object",
          "Array",
          "String",
          "Map",
          "Set"
        ],
        "typesDescription": "<code>Object</code>|<code>Array</code>|<code>String</code>|<a href=\"Map.html\">Map</a>|<a href=\"Set.html\">Set</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message _optional_",
        "name": "message",
        "description": "_optional_",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Assert"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .isNotEmpty(target)\n\nAsserts that the target contains values.\nFor arrays and strings, it checks the `length` property.\nFor `Map` and `Set` instances, it checks the `size` property.\nFor non-function objects, it gets the count of own\nenumerable string keys.\n\n    assert.isNotEmpty([1, 2]);\n    assert.isNotEmpty('34');\n    assert.isNotEmpty(new Set([5, 6]));\n    assert.isNotEmpty({ key: 7 });",
      "summary": "### .isNotEmpty(target)",
      "body": "Asserts that the target contains values.\nFor arrays and strings, it checks the `length` property.\nFor `Map` and `Set` instances, it checks the `size` property.\nFor non-function objects, it gets the count of own\nenumerable string keys.\n\n    assert.isNotEmpty([1, 2]);\n    assert.isNotEmpty('34');\n    assert.isNotEmpty(new Set([5, 6]));\n    assert.isNotEmpty({ key: 7 });"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7144,
    "codeStart": 7166,
    "code": "assert.isNotEmpty = function(val, msg) {\n  new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;\n};",
    "ctx": {
      "type": "method",
      "receiver": "assert",
      "name": "isNotEmpty",
      "string": "assert.isNotEmpty()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Aliases.",
      "summary": "Aliases.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7170,
    "codeStart": 7174,
    "code": "(function alias(name, as){\n  assert[as] = assert[name];\n  return alias;\n})\n('isOk', 'ok')\n('isNotOk', 'notOk')\n('throws', 'throw')\n('throws', 'Throw')\n('isExtensible', 'extensible')\n('isNotExtensible', 'notExtensible')\n('isSealed', 'sealed')\n('isNotSealed', 'notSealed')\n('isFrozen', 'frozen')\n('isNotFrozen', 'notFrozen')\n('isEmpty', 'empty')\n('isNotEmpty', 'notEmpty');\n};\n\n},{}],7:[function(require,module,exports){",
    "ctx": false
  },
  {
    "tags": [],
    "description": {
      "full": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7193,
    "codeStart": 7199,
    "code": "module.exports = function (chai, util) {\n  chai.expect = function (val, message) {\n    return new chai.Assertion(val, message);\n  };",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "fail"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} operator",
        "name": "operator",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .fail(actual, expected, [message], [operator])\n\nThrow a failure.",
      "summary": "### .fail(actual, expected, [message], [operator])",
      "body": "Throw a failure."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7204,
    "codeStart": 7218,
    "code": "chai.expect.fail = function (actual, expected, message, operator) {\n  message = message || 'expect.fail()';\n  throw new chai.AssertionError(message, {\n      actual: actual\n    , expected: expected\n    , operator: operator\n  }, chai.expect.fail);\n};\n};\n\n},{}],8:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "chai.expect",
      "name": "fail",
      "string": "chai.expect.fail()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "chai\nCopyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7229,
    "codeStart": 7235,
    "code": "module.exports = function (chai, util) {\n  var Assertion = chai.Assertion;\n\n  function loadShould () {\n    // explicitly define this method as function as to have it's name to include as `ssfi`\n    function shouldGetter() {\n      if (this instanceof String\n          || this instanceof Number\n          || this instanceof Boolean\n          || typeof Symbol === 'function' && this instanceof Symbol) {\n        return new Assertion(this.valueOf(), null, shouldGetter);\n      }\n      return new Assertion(this, null, shouldGetter);\n    }\n    function shouldSetter(value) {\n      // See https://github.com/chaijs/chai/issues/86: this makes\n      // `whatever.should = someValue` actually set `someValue`, which is\n      // especially useful for `global.should = require('chai').should()`.\n      //\n      // Note that we have to use [[DefineProperty]] instead of [[Put]]\n      // since otherwise we would trigger this very setter!\n      Object.defineProperty(this, 'should', {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    }\n    // modify Object.prototype to have `should`\n    Object.defineProperty(Object.prototype, 'should', {\n      set: shouldSetter\n      , get: shouldGetter\n      , configurable: true\n    });\n\n    var should = {};",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "fail"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} operator",
        "name": "operator",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "BDD"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .fail(actual, expected, [message], [operator])\n\nThrow a failure.",
      "summary": "### .fail(actual, expected, [message], [operator])",
      "body": "Throw a failure."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7272,
    "codeStart": 7286,
    "code": "should.fail = function (actual, expected, message, operator) {\n  message = message || 'should.fail()';\n  throw new chai.AssertionError(message, {\n      actual: actual\n    , expected: expected\n    , operator: operator\n  }, should.fail);\n};",
    "ctx": {
      "type": "method",
      "receiver": "should",
      "name": "fail",
      "string": "should.fail()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "equal"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Should"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .equal(actual, expected, [message])\n\nAsserts non-strict equality (`==`) of `actual` and `expected`.\n\n    should.equal(3, '3', '== coerces values to strings');",
      "summary": "### .equal(actual, expected, [message])",
      "body": "Asserts non-strict equality (`==`) of `actual` and `expected`.\n\n    should.equal(3, '3', '== coerces values to strings');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7295,
    "codeStart": 7310,
    "code": "should.equal = function (val1, val2, msg) {\n  new Assertion(val1, msg).to.equal(val2);\n};",
    "ctx": {
      "type": "method",
      "receiver": "should",
      "name": "equal",
      "string": "should.equal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "throw"
      },
      {
        "type": "alias",
        "string": "Throw"
      },
      {
        "type": "param",
        "string": "{Function} function",
        "name": "function",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{ErrorConstructor} constructor",
        "name": "constructor",
        "description": "",
        "types": [
          "ErrorConstructor"
        ],
        "typesDescription": "<a href=\"ErrorConstructor.html\">ErrorConstructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp} regexp",
        "name": "regexp",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "see",
        "string": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types",
        "title": "",
        "url": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types"
      },
      {
        "type": "namespace",
        "string": "Should"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .throw(function, [constructor/string/regexp], [string/regexp], [message])\n\nAsserts that `function` will throw an error that is an instance of\n`constructor`, or alternately that it will throw an error with message\nmatching `regexp`.\n\n    should.throw(fn, 'function throws a reference error');\n    should.throw(fn, /function throws a reference error/);\n    should.throw(fn, ReferenceError);\n    should.throw(fn, ReferenceError, 'function throws a reference error');\n    should.throw(fn, ReferenceError, /function throws a reference error/);",
      "summary": "### .throw(function, [constructor/string/regexp], [string/regexp], [message])",
      "body": "Asserts that `function` will throw an error that is an instance of\n`constructor`, or alternately that it will throw an error with message\nmatching `regexp`.\n\n    should.throw(fn, 'function throws a reference error');\n    should.throw(fn, /function throws a reference error/);\n    should.throw(fn, ReferenceError);\n    should.throw(fn, ReferenceError, 'function throws a reference error');\n    should.throw(fn, ReferenceError, /function throws a reference error/);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7314,
    "codeStart": 7338,
    "code": "should.Throw = function (fn, errt, errs, msg) {\n  new Assertion(fn, msg).to.Throw(errt, errs);\n};",
    "ctx": {
      "type": "method",
      "receiver": "should",
      "name": "Throw",
      "string": "should.Throw()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "exist"
      },
      {
        "type": "namespace",
        "string": "Should"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .exist\n\nAsserts that the target is neither `null` nor `undefined`.\n\n    var foo = 'hi';\n\n    should.exist(foo, 'foo exists');",
      "summary": "### .exist",
      "body": "Asserts that the target is neither `null` nor `undefined`.\n\n    var foo = 'hi';\n\n    should.exist(foo, 'foo exists');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7342,
    "codeStart": 7356,
    "code": "should.exist = function (val, msg) {\n  new Assertion(val, msg).to.exist;\n}\n\n// negation\nshould.not = {}",
    "ctx": {
      "type": "method",
      "receiver": "should",
      "name": "exist",
      "string": "should.exist()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "not.equal"
      },
      {
        "type": "param",
        "string": "{Mixed} actual",
        "name": "actual",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} expected",
        "name": "expected",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Should"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .not.equal(actual, expected, [message])\n\nAsserts non-strict inequality (`!=`) of `actual` and `expected`.\n\n    should.not.equal(3, 4, 'these numbers are not equal');",
      "summary": "### .not.equal(actual, expected, [message])",
      "body": "Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n\n    should.not.equal(3, 4, 'these numbers are not equal');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7363,
    "codeStart": 7378,
    "code": "should.not.equal = function (val1, val2, msg) {\n  new Assertion(val1, msg).to.not.equal(val2);\n};",
    "ctx": {
      "type": "method",
      "receiver": "should.not",
      "name": "equal",
      "string": "should.not.equal()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "not.throw"
      },
      {
        "type": "alias",
        "string": "not.Throw"
      },
      {
        "type": "param",
        "string": "{Function} function",
        "name": "function",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{ErrorConstructor} constructor",
        "name": "constructor",
        "description": "",
        "types": [
          "ErrorConstructor"
        ],
        "typesDescription": "<a href=\"ErrorConstructor.html\">ErrorConstructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp} regexp",
        "name": "regexp",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "see",
        "string": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types",
        "title": "",
        "url": "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types"
      },
      {
        "type": "namespace",
        "string": "Should"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .throw(function, [constructor/regexp], [message])\n\nAsserts that `function` will _not_ throw an error that is an instance of\n`constructor`, or alternately that it will not throw an error with message\nmatching `regexp`.\n\n    should.not.throw(fn, Error, 'function does not throw');",
      "summary": "### .throw(function, [constructor/regexp], [message])",
      "body": "Asserts that `function` will _not_ throw an error that is an instance of\n`constructor`, or alternately that it will not throw an error with message\nmatching `regexp`.\n\n    should.not.throw(fn, Error, 'function does not throw');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7382,
    "codeStart": 7402,
    "code": "should.not.Throw = function (fn, errt, errs, msg) {\n  new Assertion(fn, msg).to.not.Throw(errt, errs);\n};",
    "ctx": {
      "type": "method",
      "receiver": "should.not",
      "name": "Throw",
      "string": "should.not.Throw()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "not.exist"
      },
      {
        "type": "namespace",
        "string": "Should"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .not.exist\n\nAsserts that the target is neither `null` nor `undefined`.\n\n    var bar = null;\n\n    should.not.exist(bar, 'bar does not exist');",
      "summary": "### .not.exist",
      "body": "Asserts that the target is neither `null` nor `undefined`.\n\n    var bar = null;\n\n    should.not.exist(bar, 'bar does not exist');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7406,
    "codeStart": 7420,
    "code": "should.not.exist = function (val, msg) {\n  new Assertion(val, msg).to.not.exist;\n}\n\nshould['throw'] = should['Throw'];\nshould.not['throw'] = should.not['Throw'];\n\nreturn should;\n  };\n\n  chai.should = loadShould;\n  chai.Should = loadShould;\n};\n\n},{}],9:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "should.not",
      "name": "exist",
      "string": "should.not.exist()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - addChainingMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - addChainingMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7435,
    "codeStart": 7440
  },
  {
    "tags": [],
    "description": {
      "full": "Module dependencies",
      "summary": "Module dependencies",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7441,
    "codeStart": 7445,
    "code": "var addLengthGuard = require('./addLengthGuard');\nvar chai = require('../../chai');\nvar flag = require('./flag');\nvar proxify = require('./proxify');\nvar transferFlags = require('./transferFlags');",
    "ctx": {
      "type": "declaration",
      "name": "addLengthGuard",
      "value": "require('./addLengthGuard')",
      "string": "addLengthGuard"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Module variables",
      "summary": "Module variables",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7451,
    "codeStart": 7455,
    "code": "// Check whether `Object.setPrototypeOf` is supported\nvar canSetPrototype = typeof Object.setPrototypeOf === 'function';\n\n// Without `Object.setPrototypeOf` support, this module will need to add properties to a function.\n// However, some of functions' own props are not configurable and should be skipped.\nvar testFn = function() {};\nvar excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {\n  var propDesc = Object.getOwnPropertyDescriptor(testFn, name);\n\n  // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,\n  // but then returns `undefined` as the property descriptor for `callee`. As a\n  // workaround, we perform an otherwise unnecessary type-check for `propDesc`,\n  // and then filter it out if it's not an object as it should be.\n  if (typeof propDesc !== 'object')\n    return true;\n\n  return !propDesc.configurable;\n});\n\n// Cache `Function` properties\nvar call  = Function.prototype.call,\n    apply = Function.prototype.apply;",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} ctx object to which the method is added",
        "name": "ctx",
        "description": "object to which the method is added",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} name of method to add",
        "name": "name",
        "description": "of method to add",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} method function to be used for `name`, when called",
        "name": "method",
        "description": "function to be used for `name`, when called",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} chainingBehavior function to be called every time the property is accessed",
        "name": "chainingBehavior",
        "description": "function to be called every time the property is accessed",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "addChainableMethod"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .addChainableMethod(ctx, name, method, chainingBehavior)\n\nAdds a method to an object, such that the method can also be chained.\n\n    utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n      var obj = utils.flag(this, 'object');\n      new chai.Assertion(obj).to.be.equal(str);\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n\nThe result can then be used as both a method assertion, executing both `method` and\n`chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n\n    expect(fooStr).to.be.foo('bar');\n    expect(fooStr).to.be.foo.equal('foo');",
      "summary": "### .addChainableMethod(ctx, name, method, chainingBehavior)",
      "body": "Adds a method to an object, such that the method can also be chained.\n\n    utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n      var obj = utils.flag(this, 'object');\n      new chai.Assertion(obj).to.be.equal(str);\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n\nThe result can then be used as both a method assertion, executing both `method` and\n`chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n\n    expect(fooStr).to.be.foo('bar');\n    expect(fooStr).to.be.foo.equal('foo');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7478,
    "codeStart": 7507,
    "code": "module.exports = function addChainableMethod(ctx, name, method, chainingBehavior) {\n  if (typeof chainingBehavior !== 'function') {\n    chainingBehavior = function () { };\n  }\n\n  var chainableBehavior = {\n      method: method\n    , chainingBehavior: chainingBehavior\n  };\n\n  // save the methods so we can overwrite them later, if we need to.\n  if (!ctx.__methods) {\n    ctx.__methods = {};\n  }\n  ctx.__methods[name] = chainableBehavior;\n\n  Object.defineProperty(ctx, name,\n    { get: function chainableMethodGetter() {\n        chainableBehavior.chainingBehavior.call(this);\n\n        var chainableMethodWrapper = function () {\n          // Setting the `ssfi` flag to `chainableMethodWrapper` causes this\n          // function to be the starting point for removing implementation\n          // frames from the stack trace of a failed assertion.\n          //\n          // However, we only want to use this function as the starting point if\n          // the `lockSsfi` flag isn't set.\n          //\n          // If the `lockSsfi` flag is set, then this assertion is being\n          // invoked from inside of another assertion. In this case, the `ssfi`\n          // flag has already been set by the outer assertion.\n          //\n          // Note that overwriting a chainable method merely replaces the saved\n          // methods in `ctx.__methods` instead of completely replacing the\n          // overwritten assertion. Therefore, an overwriting assertion won't\n          // set the `ssfi` or `lockSsfi` flags.\n          if (!flag(this, 'lockSsfi')) {\n            flag(this, 'ssfi', chainableMethodWrapper);\n          }\n\n          var result = chainableBehavior.method.apply(this, arguments);\n          if (result !== undefined) {\n            return result;\n          }\n\n          var newAssertion = new chai.Assertion();\n          transferFlags(this, newAssertion);\n          return newAssertion;\n        };\n\n        addLengthGuard(chainableMethodWrapper, name, true);\n\n        // Use `Object.setPrototypeOf` if available\n        if (canSetPrototype) {\n          // Inherit all properties from the object by replacing the `Function` prototype\n          var prototype = Object.create(this);\n          // Restore the `call` and `apply` methods from `Function`\n          prototype.call = call;\n          prototype.apply = apply;\n          Object.setPrototypeOf(chainableMethodWrapper, prototype);\n        }\n        // Otherwise, redefine all properties (slow!)\n        else {\n          var asserterNames = Object.getOwnPropertyNames(ctx);\n          asserterNames.forEach(function (asserterName) {\n            if (excludeNames.indexOf(asserterName) !== -1) {\n              return;\n            }\n\n            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\n            Object.defineProperty(chainableMethodWrapper, asserterName, pd);\n          });\n        }\n\n        transferFlags(this, chainableMethodWrapper);\n        return proxify(chainableMethodWrapper);\n      }\n    , configurable: true\n  });\n};\n\n},{\"../../chai\":2,\"./addLengthGuard\":10,\"./flag\":15,\"./proxify\":30,\"./transferFlags\":32}],10:[function(require,module,exports){\nvar config = require('../config');\n\nvar fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - addLengthGuard utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - addLengthGuard utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7593,
    "codeStart": 7598
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Function} fn",
        "name": "fn",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} assertionName",
        "name": "assertionName",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Boolean} isChainable",
        "name": "isChainable",
        "description": "",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "addLengthGuard"
      }
    ],
    "description": {
      "full": "### .addLengthGuard(fn, assertionName, isChainable)\n\nDefine `length` as a getter on the given uninvoked method assertion. The\ngetter acts as a guard against chaining `length` directly off of an uninvoked\nmethod assertion, which is a problem because it references `function`'s\nbuilt-in `length` property instead of Chai's `length` assertion. When the\ngetter catches the user making this mistake, it throws an error with a\nhelpful message.\n\nThere are two ways in which this mistake can be made. The first way is by\nchaining the `length` assertion directly off of an uninvoked chainable\nmethod. In this case, Chai suggests that the user use `lengthOf` instead. The\nsecond way is by chaining the `length` assertion directly off of an uninvoked\nnon-chainable method. Non-chainable methods must be invoked prior to\nchaining. In this case, Chai suggests that the user consult the docs for the\ngiven assertion.\n\nIf the `length` property of functions is unconfigurable, then return `fn`\nwithout modification.\n\nNote that in ES6, the function's `length` property is configurable, so once\nsupport for legacy environments is dropped, Chai's `length` property can\nreplace the built-in function's `length` property, and this length guard will\nno longer be necessary. In the mean time, maintaining consistency across all\nenvironments is the priority.",
      "summary": "### .addLengthGuard(fn, assertionName, isChainable)",
      "body": "Define `length` as a getter on the given uninvoked method assertion. The\ngetter acts as a guard against chaining `length` directly off of an uninvoked\nmethod assertion, which is a problem because it references `function`'s\nbuilt-in `length` property instead of Chai's `length` assertion. When the\ngetter catches the user making this mistake, it throws an error with a\nhelpful message.\n\nThere are two ways in which this mistake can be made. The first way is by\nchaining the `length` assertion directly off of an uninvoked chainable\nmethod. In this case, Chai suggests that the user use `lengthOf` instead. The\nsecond way is by chaining the `length` assertion directly off of an uninvoked\nnon-chainable method. Non-chainable methods must be invoked prior to\nchaining. In this case, Chai suggests that the user consult the docs for the\ngiven assertion.\n\nIf the `length` property of functions is unconfigurable, then return `fn`\nwithout modification.\n\nNote that in ES6, the function's `length` property is configurable, so once\nsupport for legacy environments is dropped, Chai's `length` property can\nreplace the built-in function's `length` property, and this length guard will\nno longer be necessary. In the mean time, maintaining consistency across all\nenvironments is the priority."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7599,
    "codeStart": 7633,
    "code": "module.exports = function addLengthGuard (fn, assertionName, isChainable) {\n  if (!fnLengthDesc.configurable) return fn;\n\n  Object.defineProperty(fn, 'length', {\n    get: function () {\n      if (isChainable) {\n        throw Error('Invalid Chai property: ' + assertionName + '.length. Due' +\n          ' to a compatibility issue, \"length\" cannot directly follow \"' +\n          assertionName + '\". Use \"' + assertionName + '.lengthOf\" instead.');\n      }\n\n      throw Error('Invalid Chai property: ' + assertionName + '.length. See' +\n        ' docs for proper usage of \"' + assertionName + '\".');\n    }\n  });\n\n  return fn;\n};\n\n},{\"../config\":4}],11:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - addMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - addMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7653,
    "codeStart": 7659,
    "code": "var addLengthGuard = require('./addLengthGuard');\nvar chai = require('../../chai');\nvar flag = require('./flag');\nvar proxify = require('./proxify');\nvar transferFlags = require('./transferFlags');",
    "ctx": {
      "type": "declaration",
      "name": "addLengthGuard",
      "value": "require('./addLengthGuard')",
      "string": "addLengthGuard"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} ctx object to which the method is added",
        "name": "ctx",
        "description": "object to which the method is added",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} name of method to add",
        "name": "name",
        "description": "of method to add",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} method function to be used for name",
        "name": "method",
        "description": "function to be used for name",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "addMethod"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .addMethod(ctx, name, method)\n\nAdds a method to the prototype of an object.\n\n    utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n      var obj = utils.flag(this, 'object');\n      new chai.Assertion(obj).to.be.equal(str);\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.addMethod('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(fooStr).to.be.foo('bar');",
      "summary": "### .addMethod(ctx, name, method)",
      "body": "Adds a method to the prototype of an object.\n\n    utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n      var obj = utils.flag(this, 'object');\n      new chai.Assertion(obj).to.be.equal(str);\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.addMethod('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(fooStr).to.be.foo('bar');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7665,
    "codeStart": 7691,
    "code": "module.exports = function addMethod(ctx, name, method) {\n  var methodWrapper = function () {\n    // Setting the `ssfi` flag to `methodWrapper` causes this function to be the\n    // starting point for removing implementation frames from the stack trace of\n    // a failed assertion.\n    //\n    // However, we only want to use this function as the starting point if the\n    // `lockSsfi` flag isn't set.\n    //\n    // If the `lockSsfi` flag is set, then either this assertion has been\n    // overwritten by another assertion, or this assertion is being invoked from\n    // inside of another assertion. In the first case, the `ssfi` flag has\n    // already been set by the overwriting assertion. In the second case, the\n    // `ssfi` flag has already been set by the outer assertion.\n    if (!flag(this, 'lockSsfi')) {\n      flag(this, 'ssfi', methodWrapper);\n    }\n\n    var result = method.apply(this, arguments);\n    if (result !== undefined)\n      return result;\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n\n  addLengthGuard(methodWrapper, name, false);\n  ctx[name] = proxify(methodWrapper, name);\n};\n\n},{\"../../chai\":2,\"./addLengthGuard\":10,\"./flag\":15,\"./proxify\":30,\"./transferFlags\":32}],12:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - addProperty utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - addProperty utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7723,
    "codeStart": 7729,
    "code": "var chai = require('../../chai');\nvar flag = require('./flag');\nvar isProxyEnabled = require('./isProxyEnabled');\nvar transferFlags = require('./transferFlags');",
    "ctx": {
      "type": "declaration",
      "name": "chai",
      "value": "require('../../chai')",
      "string": "chai"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} ctx object to which the property is added",
        "name": "ctx",
        "description": "object to which the property is added",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} name of property to add",
        "name": "name",
        "description": "of property to add",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} getter function to be used for name",
        "name": "getter",
        "description": "function to be used for name",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "addProperty"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .addProperty(ctx, name, getter)\n\nAdds a property to the prototype of an object.\n\n    utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n      var obj = utils.flag(this, 'object');\n      new chai.Assertion(obj).to.be.instanceof(Foo);\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.addProperty('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.be.foo;",
      "summary": "### .addProperty(ctx, name, getter)",
      "body": "Adds a property to the prototype of an object.\n\n    utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n      var obj = utils.flag(this, 'object');\n      new chai.Assertion(obj).to.be.instanceof(Foo);\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.addProperty('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.be.foo;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7734,
    "codeStart": 7760,
    "code": "module.exports = function addProperty(ctx, name, getter) {\n  getter = getter === undefined ? function () {} : getter;\n\n  Object.defineProperty(ctx, name,\n    { get: function propertyGetter() {\n        // Setting the `ssfi` flag to `propertyGetter` causes this function to\n        // be the starting point for removing implementation frames from the\n        // stack trace of a failed assertion.\n        //\n        // However, we only want to use this function as the starting point if\n        // the `lockSsfi` flag isn't set and proxy protection is disabled.\n        //\n        // If the `lockSsfi` flag is set, then either this assertion has been\n        // overwritten by another assertion, or this assertion is being invoked\n        // from inside of another assertion. In the first case, the `ssfi` flag\n        // has already been set by the overwriting assertion. In the second\n        // case, the `ssfi` flag has already been set by the outer assertion.\n        //\n        // If proxy protection is enabled, then the `ssfi` flag has already been\n        // set by the proxy getter.\n        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {\n          flag(this, 'ssfi', propertyGetter);\n        }\n\n        var result = getter.call(this);\n        if (result !== undefined)\n          return result;\n\n        var newAssertion = new chai.Assertion();\n        transferFlags(this, newAssertion);\n        return newAssertion;\n      }\n    , configurable: true\n  });\n};\n\n},{\"../../chai\":2,\"./flag\":15,\"./isProxyEnabled\":25,\"./transferFlags\":32}],13:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - compareByInspect utility\nCopyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - compareByInspect utility\nCopyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7797,
    "codeStart": 7802
  },
  {
    "tags": [],
    "description": {
      "full": "Module dependancies",
      "summary": "Module dependancies",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7803,
    "codeStart": 7807,
    "code": "var inspect = require('./inspect');",
    "ctx": {
      "type": "declaration",
      "name": "inspect",
      "value": "require('./inspect')",
      "string": "inspect"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} first element to compare",
        "name": "first",
        "description": "element to compare",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} second element to compare",
        "name": "second",
        "description": "element to compare",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Number} -1 if 'a' should come before 'b'; otherwise 1 ",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "-1 if 'a' should come before 'b'; otherwise 1"
      },
      {
        "type": "name",
        "string": "compareByInspect"
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .compareByInspect(mixed, mixed)\n\nTo be used as a compareFunction with Array.prototype.sort. Compares elements\nusing inspect instead of default behavior of using toString so that Symbols\nand objects with irregular/missing toString can still be sorted without a\nTypeError.",
      "summary": "### .compareByInspect(mixed, mixed)",
      "body": "To be used as a compareFunction with Array.prototype.sort. Compares elements\nusing inspect instead of default behavior of using toString so that Symbols\nand objects with irregular/missing toString can still be sorted without a\nTypeError."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7809,
    "codeStart": 7825,
    "code": "module.exports = function compareByInspect(a, b) {\n  return inspect(a) < inspect(b) ? -1 : 1;\n};\n\n},{\"./inspect\":23}],14:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - expectTypes utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - expectTypes utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7830,
    "codeStart": 7835
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} obj constructed Assertion",
        "name": "obj",
        "description": "constructed Assertion",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} type A list of allowed types for this assertion",
        "name": "type",
        "description": "A list of allowed types for this assertion",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "expectTypes"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .expectTypes(obj, types)\n\nEnsures that the object being tested against is of a valid type.\n\n    utils.expectTypes(this, ['array', 'object', 'string']);",
      "summary": "### .expectTypes(obj, types)",
      "body": "Ensures that the object being tested against is of a valid type.\n\n    utils.expectTypes(this, ['array', 'object', 'string']);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7836,
    "codeStart": 7850,
    "code": "var AssertionError = require('assertion-error');\nvar flag = require('./flag');\nvar type = require('type-detect');\n\nmodule.exports = function expectTypes(obj, types) {\n  var flagMsg = flag(obj, 'message');\n  var ssfi = flag(obj, 'ssfi');\n\n  flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n  obj = flag(obj, 'object');\n  types = types.map(function (t) { return t.toLowerCase(); });\n  types.sort();\n\n  // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'\n  var str = types.map(function (t, index) {\n    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';\n    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';\n    return or + art + ' ' + t;\n  }).join(', ');\n\n  var objType = type(obj).toLowerCase();\n\n  if (!types.some(function (expected) { return objType === expected; })) {\n    throw new AssertionError(\n      flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given',\n      undefined,\n      ssfi\n    );\n  }\n};\n\n},{\"./flag\":15,\"assertion-error\":33,\"type-detect\":38}],15:[function(require,module,exports){",
    "ctx": {
      "type": "declaration",
      "name": "AssertionError",
      "value": "require('assertion-error')",
      "string": "AssertionError"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - flag utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - flag utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7883,
    "codeStart": 7888
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object constructed Assertion",
        "name": "object",
        "description": "constructed Assertion",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} key",
        "name": "key",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value (optional)",
        "name": "value",
        "description": "(optional)",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "flag"
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "### .flag(object, key, [value])\n\nGet or set a flag value on an object. If a\nvalue is provided it will be set, else it will\nreturn the currently set value or `undefined` if\nthe value is not set.\n\n    utils.flag(this, 'foo', 'bar'); // setter\n    utils.flag(this, 'foo'); // getter, returns `bar`",
      "summary": "### .flag(object, key, [value])",
      "body": "Get or set a flag value on an object. If a\nvalue is provided it will be set, else it will\nreturn the currently set value or `undefined` if\nthe value is not set.\n\n    utils.flag(this, 'foo', 'bar'); // setter\n    utils.flag(this, 'foo'); // getter, returns `bar`"
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7889,
    "codeStart": 7908,
    "code": "module.exports = function flag(obj, key, value) {\n  var flags = obj.__flags || (obj.__flags = Object.create(null));\n  if (arguments.length === 3) {\n    flags[key] = value;\n  } else {\n    return flags[key];\n  }\n};\n\n},{}],16:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - getActual utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - getActual utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7918,
    "codeStart": 7923
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object (constructed Assertion)",
        "name": "object",
        "description": "(constructed Assertion)",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Arguments} chai.Assertion.prototype.assert arguments",
        "name": "chai.Assertion.prototype.assert",
        "description": "arguments",
        "types": [
          "Arguments"
        ],
        "typesDescription": "<a href=\"Arguments.html\">Arguments</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getActual"
      }
    ],
    "description": {
      "full": "### .getActual(object, [actual])\n\nReturns the `actual` value for an Assertion.",
      "summary": "### .getActual(object, [actual])",
      "body": "Returns the `actual` value for an Assertion."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7924,
    "codeStart": 7935,
    "code": "module.exports = function getActual(obj, args) {\n  return args.length > 4 ? args[4] : obj._obj;\n};\n\n},{}],17:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - getEnumerableProperties utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - getEnumerableProperties utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7940,
    "codeStart": 7945
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Array}",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": ""
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getEnumerableProperties"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getEnumerableProperties(object)\n\nThis allows the retrieval of enumerable property names of an object,\ninherited or not.",
      "summary": "### .getEnumerableProperties(object)",
      "body": "This allows the retrieval of enumerable property names of an object,\ninherited or not."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7946,
    "codeStart": 7959,
    "code": "module.exports = function getEnumerableProperties(object) {\n  var result = [];\n  for (var name in object) {\n    result.push(name);\n  }\n  return result;\n};\n\n},{}],18:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - message composition utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - message composition utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7968,
    "codeStart": 7973
  },
  {
    "tags": [],
    "description": {
      "full": "Module dependancies",
      "summary": "Module dependancies",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 7974,
    "codeStart": 7978,
    "code": "var flag = require('./flag')\n  , getActual = require('./getActual')\n  , inspect = require('./inspect')\n  , objDisplay = require('./objDisplay');",
    "ctx": {
      "type": "declaration",
      "name": "flag",
      "value": "require('./flag')",
      "string": "flag"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object (constructed Assertion)",
        "name": "object",
        "description": "(constructed Assertion)",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Arguments} chai.Assertion.prototype.assert arguments",
        "name": "chai.Assertion.prototype.assert",
        "description": "arguments",
        "types": [
          "Arguments"
        ],
        "typesDescription": "<a href=\"Arguments.html\">Arguments</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getMessage"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getMessage(object, message, negateMessage)\n\nConstruct the error message based on flags\nand template tags. Template tags will return\na stringified inspection of the object referenced.\n\nMessage template tags:\n- `#{this}` current asserted object\n- `#{act}` actual value\n- `#{exp}` expected value",
      "summary": "### .getMessage(object, message, negateMessage)",
      "body": "Construct the error message based on flags\nand template tags. Template tags will return\na stringified inspection of the object referenced.\n\nMessage template tags:\n- `#{this}` current asserted object\n- `#{act}` actual value\n- `#{exp}` expected value"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 7983,
    "codeStart": 8002,
    "code": "module.exports = function getMessage(obj, args) {\n  var negate = flag(obj, 'negate')\n    , val = flag(obj, 'object')\n    , expected = args[3]\n    , actual = getActual(obj, args)\n    , msg = negate ? args[2] : args[1]\n    , flagMsg = flag(obj, 'message');\n\n  if(typeof msg === \"function\") msg = msg();\n  msg = msg || '';\n  msg = msg\n    .replace(/#\\{this\\}/g, function () { return objDisplay(val); })\n    .replace(/#\\{act\\}/g, function () { return objDisplay(actual); })\n    .replace(/#\\{exp\\}/g, function () { return objDisplay(expected); });\n\n  return flagMsg ? flagMsg + ': ' + msg : msg;\n};\n\n},{\"./flag\":15,\"./getActual\":16,\"./inspect\":23,\"./objDisplay\":26}],19:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - getOwnEnumerableProperties utility\nCopyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - getOwnEnumerableProperties utility\nCopyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8021,
    "codeStart": 8026
  },
  {
    "tags": [],
    "description": {
      "full": "Module dependancies",
      "summary": "Module dependancies",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8027,
    "codeStart": 8031,
    "code": "var getOwnEnumerablePropertySymbols = require('./getOwnEnumerablePropertySymbols');",
    "ctx": {
      "type": "declaration",
      "name": "getOwnEnumerablePropertySymbols",
      "value": "require('./getOwnEnumerablePropertySymbols')",
      "string": "getOwnEnumerablePropertySymbols"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Array}",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": ""
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getOwnEnumerableProperties"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getOwnEnumerableProperties(object)\n\nThis allows the retrieval of directly-owned enumerable property names and\nsymbols of an object. This function is necessary because Object.keys only\nreturns enumerable property names, not enumerable property symbols.",
      "summary": "### .getOwnEnumerableProperties(object)",
      "body": "This allows the retrieval of directly-owned enumerable property names and\nsymbols of an object. This function is necessary because Object.keys only\nreturns enumerable property names, not enumerable property symbols."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 8033,
    "codeStart": 8047,
    "code": "module.exports = function getOwnEnumerableProperties(obj) {\n  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));\n};\n\n},{\"./getOwnEnumerablePropertySymbols\":20}],20:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - getOwnEnumerablePropertySymbols utility\nCopyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - getOwnEnumerablePropertySymbols utility\nCopyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8052,
    "codeStart": 8057
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Array}",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": ""
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getOwnEnumerablePropertySymbols"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getOwnEnumerablePropertySymbols(object)\n\nThis allows the retrieval of directly-owned enumerable property symbols of an\nobject. This function is necessary because Object.getOwnPropertySymbols\nreturns both enumerable and non-enumerable property symbols.",
      "summary": "### .getOwnEnumerablePropertySymbols(object)",
      "body": "This allows the retrieval of directly-owned enumerable property symbols of an\nobject. This function is necessary because Object.getOwnPropertySymbols\nreturns both enumerable and non-enumerable property symbols."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 8058,
    "codeStart": 8072,
    "code": "module.exports = function getOwnEnumerablePropertySymbols(obj) {\n  if (typeof Object.getOwnPropertySymbols !== 'function') return [];\n\n  return Object.getOwnPropertySymbols(obj).filter(function (sym) {\n    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;\n  });\n};\n\n},{}],21:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - getProperties utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - getProperties utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8081,
    "codeStart": 8086
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Array}",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": ""
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getProperties"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getProperties(object)\n\nThis allows the retrieval of property names of an object, enumerable or not,\ninherited or not.",
      "summary": "### .getProperties(object)",
      "body": "This allows the retrieval of property names of an object, enumerable or not,\ninherited or not."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 8087,
    "codeStart": 8100,
    "code": "module.exports = function getProperties(object) {\n  var result = Object.getOwnPropertyNames(object);\n\n  function addProperty(property) {\n    if (result.indexOf(property) === -1) {\n      result.push(property);\n    }\n  }\n\n  var proto = Object.getPrototypeOf(object);\n  while (proto !== null) {\n    Object.getOwnPropertyNames(proto).forEach(addProperty);\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return result;\n};\n\n},{}],22:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "chai\nCopyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "chai\nCopyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8119,
    "codeStart": 8124
  },
  {
    "tags": [],
    "description": {
      "full": "Dependencies that are used for multiple exports are required here only once",
      "summary": "Dependencies that are used for multiple exports are required here only once",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8125,
    "codeStart": 8129,
    "code": "var pathval = require('pathval');",
    "ctx": {
      "type": "declaration",
      "name": "pathval",
      "value": "require('pathval')",
      "string": "pathval"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "test utility",
      "summary": "test utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8131,
    "codeStart": 8135,
    "code": "exports.test = require('./test');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "test",
      "value": "require('./test')",
      "string": "exports.test"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "type utility",
      "summary": "type utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8137,
    "codeStart": 8141,
    "code": "exports.type = require('type-detect');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "type",
      "value": "require('type-detect')",
      "string": "exports.type"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "expectTypes utility",
      "summary": "expectTypes utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8143,
    "codeStart": 8146,
    "code": "exports.expectTypes = require('./expectTypes');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "expectTypes",
      "value": "require('./expectTypes')",
      "string": "exports.expectTypes"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "message utility",
      "summary": "message utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8148,
    "codeStart": 8152,
    "code": "exports.getMessage = require('./getMessage');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "getMessage",
      "value": "require('./getMessage')",
      "string": "exports.getMessage"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "actual utility",
      "summary": "actual utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8154,
    "codeStart": 8158,
    "code": "exports.getActual = require('./getActual');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "getActual",
      "value": "require('./getActual')",
      "string": "exports.getActual"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Inspect util",
      "summary": "Inspect util",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8160,
    "codeStart": 8164,
    "code": "exports.inspect = require('./inspect');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "inspect",
      "value": "require('./inspect')",
      "string": "exports.inspect"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Object Display util",
      "summary": "Object Display util",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8166,
    "codeStart": 8170,
    "code": "exports.objDisplay = require('./objDisplay');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "objDisplay",
      "value": "require('./objDisplay')",
      "string": "exports.objDisplay"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Flag utility",
      "summary": "Flag utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8172,
    "codeStart": 8176,
    "code": "exports.flag = require('./flag');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "flag",
      "value": "require('./flag')",
      "string": "exports.flag"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Flag transferring utility",
      "summary": "Flag transferring utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8178,
    "codeStart": 8182,
    "code": "exports.transferFlags = require('./transferFlags');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "transferFlags",
      "value": "require('./transferFlags')",
      "string": "exports.transferFlags"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Deep equal utility",
      "summary": "Deep equal utility",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8184,
    "codeStart": 8188,
    "code": "exports.eql = require('deep-eql');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "eql",
      "value": "require('deep-eql')",
      "string": "exports.eql"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Deep path info",
      "summary": "Deep path info",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8190,
    "codeStart": 8194,
    "code": "exports.getPathInfo = pathval.getPathInfo;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "getPathInfo",
      "value": "pathval.getPathInfo",
      "string": "exports.getPathInfo"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Check if a property exists",
      "summary": "Check if a property exists",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8196,
    "codeStart": 8200,
    "code": "exports.hasProperty = pathval.hasProperty;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "hasProperty",
      "value": "pathval.hasProperty",
      "string": "exports.hasProperty"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Function name",
      "summary": "Function name",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8202,
    "codeStart": 8206,
    "code": "exports.getName = require('get-func-name');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "getName",
      "value": "require('get-func-name')",
      "string": "exports.getName"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "add Property",
      "summary": "add Property",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8208,
    "codeStart": 8212,
    "code": "exports.addProperty = require('./addProperty');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "addProperty",
      "value": "require('./addProperty')",
      "string": "exports.addProperty"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "add Method",
      "summary": "add Method",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8214,
    "codeStart": 8218,
    "code": "exports.addMethod = require('./addMethod');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "addMethod",
      "value": "require('./addMethod')",
      "string": "exports.addMethod"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "overwrite Property",
      "summary": "overwrite Property",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8220,
    "codeStart": 8224,
    "code": "exports.overwriteProperty = require('./overwriteProperty');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "overwriteProperty",
      "value": "require('./overwriteProperty')",
      "string": "exports.overwriteProperty"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "overwrite Method",
      "summary": "overwrite Method",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8226,
    "codeStart": 8230,
    "code": "exports.overwriteMethod = require('./overwriteMethod');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "overwriteMethod",
      "value": "require('./overwriteMethod')",
      "string": "exports.overwriteMethod"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Add a chainable method",
      "summary": "Add a chainable method",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8232,
    "codeStart": 8236,
    "code": "exports.addChainableMethod = require('./addChainableMethod');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "addChainableMethod",
      "value": "require('./addChainableMethod')",
      "string": "exports.addChainableMethod"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Overwrite chainable method",
      "summary": "Overwrite chainable method",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8238,
    "codeStart": 8242,
    "code": "exports.overwriteChainableMethod = require('./overwriteChainableMethod');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "overwriteChainableMethod",
      "value": "require('./overwriteChainableMethod')",
      "string": "exports.overwriteChainableMethod"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Compare by inspect method",
      "summary": "Compare by inspect method",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8244,
    "codeStart": 8248,
    "code": "exports.compareByInspect = require('./compareByInspect');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "compareByInspect",
      "value": "require('./compareByInspect')",
      "string": "exports.compareByInspect"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Get own enumerable property symbols method",
      "summary": "Get own enumerable property symbols method",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8250,
    "codeStart": 8254,
    "code": "exports.getOwnEnumerablePropertySymbols = require('./getOwnEnumerablePropertySymbols');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "getOwnEnumerablePropertySymbols",
      "value": "require('./getOwnEnumerablePropertySymbols')",
      "string": "exports.getOwnEnumerablePropertySymbols"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Get own enumerable properties method",
      "summary": "Get own enumerable properties method",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8256,
    "codeStart": 8260,
    "code": "exports.getOwnEnumerableProperties = require('./getOwnEnumerableProperties');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "getOwnEnumerableProperties",
      "value": "require('./getOwnEnumerableProperties')",
      "string": "exports.getOwnEnumerableProperties"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Checks error against a given set of criteria",
      "summary": "Checks error against a given set of criteria",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8262,
    "codeStart": 8266,
    "code": "exports.checkError = require('check-error');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "checkError",
      "value": "require('check-error')",
      "string": "exports.checkError"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Proxify util",
      "summary": "Proxify util",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8268,
    "codeStart": 8272,
    "code": "exports.proxify = require('./proxify');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "proxify",
      "value": "require('./proxify')",
      "string": "exports.proxify"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "addLengthGuard util",
      "summary": "addLengthGuard util",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8274,
    "codeStart": 8278,
    "code": "exports.addLengthGuard = require('./addLengthGuard');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "addLengthGuard",
      "value": "require('./addLengthGuard')",
      "string": "exports.addLengthGuard"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "isProxyEnabled helper",
      "summary": "isProxyEnabled helper",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8280,
    "codeStart": 8284,
    "code": "exports.isProxyEnabled = require('./isProxyEnabled');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "isProxyEnabled",
      "value": "require('./isProxyEnabled')",
      "string": "exports.isProxyEnabled"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "isNaN method",
      "summary": "isNaN method",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8286,
    "codeStart": 8290,
    "code": "exports.isNaN = require('./isNaN');\n\n},{\"./addChainableMethod\":9,\"./addLengthGuard\":10,\"./addMethod\":11,\"./addProperty\":12,\"./compareByInspect\":13,\"./expectTypes\":14,\"./flag\":15,\"./getActual\":16,\"./getMessage\":18,\"./getOwnEnumerableProperties\":19,\"./getOwnEnumerablePropertySymbols\":20,\"./inspect\":23,\"./isNaN\":24,\"./isProxyEnabled\":25,\"./objDisplay\":26,\"./overwriteChainableMethod\":27,\"./overwriteMethod\":28,\"./overwriteProperty\":29,\"./proxify\":30,\"./test\":31,\"./transferFlags\":32,\"check-error\":34,\"deep-eql\":35,\"get-func-name\":36,\"pathval\":37,\"type-detect\":38}],23:[function(require,module,exports){\n// This is (almost) directly from Node.js utils\n// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\n\nvar getName = require('get-func-name');\nvar getProperties = require('./getProperties');\nvar getEnumerableProperties = require('./getEnumerableProperties');\nvar config = require('../config');\n\nmodule.exports = inspect;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "isNaN",
      "value": "require('./isNaN')",
      "string": "exports.isNaN"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} obj The object to print out.",
        "name": "obj",
        "description": "The object to print out.",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Boolean} showHidden Flag that shows hidden (not enumerable)\n   properties of objects. Default is false.",
        "name": "showHidden",
        "description": "Flag that shows hidden (not enumerable)    properties of objects. Default is false.",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} depth Depth in which to descend in object. Default is 2.",
        "name": "depth",
        "description": "Depth in which to descend in object. Default is 2.",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Boolean} colors Flag to turn on ANSI escape codes to color the\n   output. Default is false (no coloring).",
        "name": "colors",
        "description": "Flag to turn on ANSI escape codes to color the    output. Default is false (no coloring).",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "inspect"
      }
    ],
    "description": {
      "full": "### .inspect(obj, [showHidden], [depth], [colors])\n\nEchoes the value of a value. Tries to print the value out\nin the best way possible given the different types.",
      "summary": "### .inspect(obj, [showHidden], [depth], [colors])",
      "body": "Echoes the value of a value. Tries to print the value out\nin the best way possible given the different types."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 8303,
    "codeStart": 8318,
    "code": "function inspect(obj, showHidden, depth, colors) {\n  var ctx = {\n    showHidden: showHidden,\n    seen: [],\n    stylize: function (str) { return str; }\n  };\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n}\n\n// Returns true if object is a DOM element.\nvar isDOMElement = function (object) {\n  if (typeof HTMLElement === 'object') {\n    return object instanceof HTMLElement;\n  } else {\n    return object &&\n      typeof object === 'object' &&\n      'nodeType' in object &&\n      object.nodeType === 1 &&\n      typeof object.nodeName === 'string';\n  }\n};\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (typeof ret !== 'string') {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // If this is a DOM element, try to get the outer HTML.\n  if (isDOMElement(value)) {\n    if ('outerHTML' in value) {\n      return value.outerHTML;\n      // This value does not have an outerHTML attribute,\n      //   it could still be an XML element\n    } else {\n      // Attempt to serialize it\n      try {\n        if (document.xmlVersion) {\n          var xmlSerializer = new XMLSerializer();\n          return xmlSerializer.serializeToString(value);\n        } else {\n          // Firefox 11- do not support outerHTML\n          //   It does, however, support innerHTML\n          //   Use the following to render the element\n          var ns = \"http://www.w3.org/1999/xhtml\";\n          var container = document.createElementNS(ns, '_');\n\n          container.appendChild(value.cloneNode(false));\n          var html = container.innerHTML\n            .replace('><', '>' + value.innerHTML + '<');\n          container.innerHTML = '';\n          return html;\n        }\n      } catch (err) {\n        // This could be a non-native DOM implementation,\n        //   continue with the normal flow:\n        //   printing the element as if it is an object.\n      }\n    }\n  }\n\n  // Look up the keys of the object.\n  var visibleKeys = getEnumerableProperties(value);\n  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\n\n  var name, nameSuffix;\n\n  // Some type of object without properties can be shortcutted.\n  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\n  // a `stack` plus `description` property; ignore those for consistency.\n  if (keys.length === 0 || (isError(value) && (\n      (keys.length === 1 && keys[0] === 'stack') ||\n      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')\n     ))) {\n    if (typeof value === 'function') {\n      name = getName(value);\n      nameSuffix = name ? ': ' + name : '';\n      return ctx.stylize('[Function' + nameSuffix + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = ''\n    , array = false\n    , typedArray = false\n    , braces = ['{', '}'];\n\n  if (isTypedArray(value)) {\n    typedArray = true;\n    braces = ['[', ']'];\n  }\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    name = getName(value);\n    nameSuffix = name ? ': ' + name : '';\n    base = ' [Function' + nameSuffix + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    return formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else if (typedArray) {\n    return formatTypedArray(value);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      if (value === 0 && (1/value) === -Infinity) {\n        return ctx.stylize('-0', 'number');\n      }\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n\n    case 'symbol':\n      return ctx.stylize(value.toString(), 'symbol');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\nfunction formatTypedArray(value) {\n  var str = '[ ';\n\n  for (var i = 0; i < value.length; ++i) {\n    if (str.length >= config.truncateThreshold - 7) {\n      str += '...';\n      break;\n    }\n    str += value[i] + ', ';\n  }\n  str += ' ]';\n\n  // Removing trailing `, ` if the array was not truncated\n  if (str.indexOf(',  ]') !== -1) {\n    str = str.replace(',  ]', ' ]');\n  }\n\n  return str;\n}\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name;\n  var propDescriptor = Object.getOwnPropertyDescriptor(value, key);\n  var str;\n\n  if (propDescriptor) {\n    if (propDescriptor.get) {\n      if (propDescriptor.set) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (propDescriptor.set) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n  }\n  if (visibleKeys.indexOf(key) < 0) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(value[key]) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, value[key], null);\n      } else {\n        str = formatValue(ctx, value[key], recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\nfunction isTypedArray(ar) {\n  // Unfortunately there's no way to check if an object is a TypedArray\n  // We have to check if it's one of these types\n  return (typeof ar === 'object' && /\\w+Array]$/.test(objectToString(ar)));\n}\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n}\n\nfunction isRegExp(re) {\n  return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n}\n\nfunction isDate(d) {\n  return typeof d === 'object' && objectToString(d) === '[object Date]';\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n},{\"../config\":4,\"./getEnumerableProperties\":17,\"./getProperties\":21,\"get-func-name\":36}],24:[function(require,module,exports){",
    "ctx": {
      "type": "function",
      "name": "inspect",
      "string": "inspect()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - isNaN utility\nCopyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>\nMIT Licensed",
      "summary": "Chai - isNaN utility\nCopyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8678,
    "codeStart": 8683
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Value} The value which has to be checked if it is NaN",
        "name": "The",
        "description": "value which has to be checked if it is NaN",
        "types": [
          "Value"
        ],
        "typesDescription": "<a href=\"Value.html\">Value</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "name",
        "string": "isNaN"
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "### .isNaN(value)\n\nChecks if the given value is NaN or not.\n\n    utils.isNaN(NaN); // true",
      "summary": "### .isNaN(value)",
      "body": "Checks if the given value is NaN or not.\n\n    utils.isNaN(NaN); // true"
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 8684,
    "codeStart": 8696,
    "code": "function isNaN(value) {\n  // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number\n  // section's NOTE.\n  return value !== value;\n}\n\n// If ECMAScript 6's Number.isNaN is present, prefer that.\nmodule.exports = Number.isNaN || isNaN;\n\n},{}],25:[function(require,module,exports){\nvar config = require('../config');",
    "ctx": {
      "type": "function",
      "name": "isNaN",
      "string": "isNaN()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - isProxyEnabled helper\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - isProxyEnabled helper\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8708,
    "codeStart": 8713
  },
  {
    "tags": [
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "isProxyEnabled"
      }
    ],
    "description": {
      "full": "### .isProxyEnabled()\n\nHelper function to check if Chai's proxy protection feature is enabled. If\nproxies are unsupported or disabled via the user's Chai config, then return\nfalse. Otherwise, return true.",
      "summary": "### .isProxyEnabled()",
      "body": "Helper function to check if Chai's proxy protection feature is enabled. If\nproxies are unsupported or disabled via the user's Chai config, then return\nfalse. Otherwise, return true."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 8714,
    "codeStart": 8725,
    "code": "module.exports = function isProxyEnabled() {\n  return config.useProxy && \n    typeof Proxy !== 'undefined' &&\n    typeof Reflect !== 'undefined';\n};\n\n},{\"../config\":4}],26:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - flag utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - flag utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8732,
    "codeStart": 8737
  },
  {
    "tags": [],
    "description": {
      "full": "Module dependancies",
      "summary": "Module dependancies",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8738,
    "codeStart": 8742,
    "code": "var inspect = require('./inspect');\nvar config = require('../config');",
    "ctx": {
      "type": "declaration",
      "name": "inspect",
      "value": "require('./inspect')",
      "string": "inspect"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} javascript object to inspect",
        "name": "javascript",
        "description": "object to inspect",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "name",
        "string": "objDisplay"
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .objDisplay(object)\n\nDetermines if an object or an array matches\ncriteria to be inspected in-line for error\nmessages or should be truncated.",
      "summary": "### .objDisplay(object)",
      "body": "Determines if an object or an array matches\ncriteria to be inspected in-line for error\nmessages or should be truncated."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 8745,
    "codeStart": 8758,
    "code": "module.exports = function objDisplay(obj) {\n  var str = inspect(obj)\n    , type = Object.prototype.toString.call(obj);\n\n  if (config.truncateThreshold && str.length >= config.truncateThreshold) {\n    if (type === '[object Function]') {\n      return !obj.name || obj.name === ''\n        ? '[Function]'\n        : '[Function: ' + obj.name + ']';\n    } else if (type === '[object Array]') {\n      return '[ Array(' + obj.length + ') ]';\n    } else if (type === '[object Object]') {\n      var keys = Object.keys(obj)\n        , kstr = keys.length > 2\n          ? keys.splice(0, 2).join(', ') + ', ...'\n          : keys.join(', ');\n      return '{ Object (' + kstr + ') }';\n    } else {\n      return str;\n    }\n  } else {\n    return str;\n  }\n};\n\n},{\"../config\":4,\"./inspect\":23}],27:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - overwriteChainableMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - overwriteChainableMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8784,
    "codeStart": 8790,
    "code": "var chai = require('../../chai');\nvar transferFlags = require('./transferFlags');",
    "ctx": {
      "type": "declaration",
      "name": "chai",
      "value": "require('../../chai')",
      "string": "chai"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} ctx object whose method / property is to be overwritten",
        "name": "ctx",
        "description": "object whose method / property is to be overwritten",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} name of method / property to overwrite",
        "name": "name",
        "description": "of method / property to overwrite",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} method function that returns a function to be used for name",
        "name": "method",
        "description": "function that returns a function to be used for name",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} chainingBehavior function that returns a function to be used for property",
        "name": "chainingBehavior",
        "description": "function that returns a function to be used for property",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "overwriteChainableMethod"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .overwriteChainableMethod(ctx, name, method, chainingBehavior)\n\nOverwites an already existing chainable method\nand provides access to the previous function or\nproperty.  Must return functions to be used for\nname.\n\n    utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',\n      function (_super) {\n      }\n    , function (_super) {\n      }\n    );\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.have.lengthOf(3);\n    expect(myFoo).to.have.lengthOf.above(3);",
      "summary": "### .overwriteChainableMethod(ctx, name, method, chainingBehavior)",
      "body": "Overwites an already existing chainable method\nand provides access to the previous function or\nproperty.  Must return functions to be used for\nname.\n\n    utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',\n      function (_super) {\n      }\n    , function (_super) {\n      }\n    );\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.have.lengthOf(3);\n    expect(myFoo).to.have.lengthOf.above(3);"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 8793,
    "codeStart": 8826,
    "code": "module.exports = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {\n  var chainableBehavior = ctx.__methods[name];\n\n  var _chainingBehavior = chainableBehavior.chainingBehavior;\n  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {\n    var result = chainingBehavior(_chainingBehavior).call(this);\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n\n  var _method = chainableBehavior.method;\n  chainableBehavior.method = function overwritingChainableMethodWrapper() {\n    var result = method(_method).apply(this, arguments);\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n};\n\n},{\"../../chai\":2,\"./transferFlags\":32}],28:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - overwriteMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - overwriteMethod utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8855,
    "codeStart": 8861,
    "code": "var addLengthGuard = require('./addLengthGuard');\nvar chai = require('../../chai');\nvar flag = require('./flag');\nvar proxify = require('./proxify');\nvar transferFlags = require('./transferFlags');",
    "ctx": {
      "type": "declaration",
      "name": "addLengthGuard",
      "value": "require('./addLengthGuard')",
      "string": "addLengthGuard"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} ctx object whose method is to be overwritten",
        "name": "ctx",
        "description": "object whose method is to be overwritten",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} name of method to overwrite",
        "name": "name",
        "description": "of method to overwrite",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} method function that returns a function to be used for name",
        "name": "method",
        "description": "function that returns a function to be used for name",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "overwriteMethod"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .overwriteMethod(ctx, name, fn)\n\nOverwites an already existing method and provides\naccess to previous function. Must return function\nto be used for name.\n\n    utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n      return function (str) {\n        var obj = utils.flag(this, 'object');\n        if (obj instanceof Foo) {\n          new chai.Assertion(obj.value).to.equal(str);\n        } else {\n          _super.apply(this, arguments);\n        }\n      }\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.overwriteMethod('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.equal('bar');",
      "summary": "### .overwriteMethod(ctx, name, fn)",
      "body": "Overwites an already existing method and provides\naccess to previous function. Must return function\nto be used for name.\n\n    utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n      return function (str) {\n        var obj = utils.flag(this, 'object');\n        if (obj instanceof Foo) {\n          new chai.Assertion(obj.value).to.equal(str);\n        } else {\n          _super.apply(this, arguments);\n        }\n      }\n    });\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.overwriteMethod('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.equal('bar');"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 8867,
    "codeStart": 8901,
    "code": "module.exports = function overwriteMethod(ctx, name, method) {\n  var _method = ctx[name]\n    , _super = function () {\n      throw new Error(name + ' is not a function');\n    };\n\n  if (_method && 'function' === typeof _method)\n    _super = _method;\n\n  var overwritingMethodWrapper = function () {\n    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this\n    // function to be the starting point for removing implementation frames from\n    // the stack trace of a failed assertion.\n    //\n    // However, we only want to use this function as the starting point if the\n    // `lockSsfi` flag isn't set.\n    //\n    // If the `lockSsfi` flag is set, then either this assertion has been\n    // overwritten by another assertion, or this assertion is being invoked from\n    // inside of another assertion. In the first case, the `ssfi` flag has\n    // already been set by the overwriting assertion. In the second case, the\n    // `ssfi` flag has already been set by the outer assertion.\n    if (!flag(this, 'lockSsfi')) {\n      flag(this, 'ssfi', overwritingMethodWrapper);\n    }\n\n    // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion\n    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already\n    // set to the correct starting point for this assertion.\n    var origLockSsfi = flag(this, 'lockSsfi');\n    flag(this, 'lockSsfi', true);\n    var result = method(_super).apply(this, arguments);\n    flag(this, 'lockSsfi', origLockSsfi);\n\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  }\n\n  addLengthGuard(overwritingMethodWrapper, name, false);\n  ctx[name] = proxify(overwritingMethodWrapper, name);\n};\n\n},{\"../../chai\":2,\"./addLengthGuard\":10,\"./flag\":15,\"./proxify\":30,\"./transferFlags\":32}],29:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - overwriteProperty utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - overwriteProperty utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 8949,
    "codeStart": 8955,
    "code": "var chai = require('../../chai');\nvar flag = require('./flag');\nvar isProxyEnabled = require('./isProxyEnabled');\nvar transferFlags = require('./transferFlags');",
    "ctx": {
      "type": "declaration",
      "name": "chai",
      "value": "require('../../chai')",
      "string": "chai"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} ctx object whose property is to be overwritten",
        "name": "ctx",
        "description": "object whose property is to be overwritten",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} name of property to overwrite",
        "name": "name",
        "description": "of property to overwrite",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Function} getter function that returns a getter function to be used for name",
        "name": "getter",
        "description": "function that returns a getter function to be used for name",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "overwriteProperty"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .overwriteProperty(ctx, name, fn)\n\nOverwites an already existing property getter and provides\naccess to previous value. Must return function to use as getter.\n\n    utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n      return function () {\n        var obj = utils.flag(this, 'object');\n        if (obj instanceof Foo) {\n          new chai.Assertion(obj.name).to.equal('bar');\n        } else {\n          _super.call(this);\n        }\n      }\n    });\n\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.overwriteProperty('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.be.ok;",
      "summary": "### .overwriteProperty(ctx, name, fn)",
      "body": "Overwites an already existing property getter and provides\naccess to previous value. Must return function to use as getter.\n\n    utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n      return function () {\n        var obj = utils.flag(this, 'object');\n        if (obj instanceof Foo) {\n          new chai.Assertion(obj.name).to.equal('bar');\n        } else {\n          _super.call(this);\n        }\n      }\n    });\n\n\nCan also be accessed directly from `chai.Assertion`.\n\n    chai.Assertion.overwriteProperty('foo', fn);\n\nThen can be used as any other assertion.\n\n    expect(myFoo).to.be.ok;"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 8960,
    "codeStart": 8994,
    "code": "module.exports = function overwriteProperty(ctx, name, getter) {\n  var _get = Object.getOwnPropertyDescriptor(ctx, name)\n    , _super = function () {};\n\n  if (_get && 'function' === typeof _get.get)\n    _super = _get.get\n\n  Object.defineProperty(ctx, name,\n    { get: function overwritingPropertyGetter() {\n        // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this\n        // function to be the starting point for removing implementation frames\n        // from the stack trace of a failed assertion.\n        //\n        // However, we only want to use this function as the starting point if\n        // the `lockSsfi` flag isn't set and proxy protection is disabled.\n        //\n        // If the `lockSsfi` flag is set, then either this assertion has been\n        // overwritten by another assertion, or this assertion is being invoked\n        // from inside of another assertion. In the first case, the `ssfi` flag\n        // has already been set by the overwriting assertion. In the second\n        // case, the `ssfi` flag has already been set by the outer assertion.\n        //\n        // If proxy protection is enabled, then the `ssfi` flag has already been\n        // set by the proxy getter.\n        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {\n          flag(this, 'ssfi', overwritingPropertyGetter);\n        }\n\n        // Setting the `lockSsfi` flag to `true` prevents the overwritten\n        // assertion from changing the `ssfi` flag. By this point, the `ssfi`\n        // flag is already set to the correct starting point for this assertion.\n        var origLockSsfi = flag(this, 'lockSsfi');\n        flag(this, 'lockSsfi', true);\n        var result = getter(_super).call(this);\n        flag(this, 'lockSsfi', origLockSsfi);\n\n        if (result !== undefined) {\n          return result;\n        }\n\n        var newAssertion = new chai.Assertion();\n        transferFlags(this, newAssertion);\n        return newAssertion;\n      }\n    , configurable: true\n  });\n};\n\n},{\"../../chai\":2,\"./flag\":15,\"./isProxyEnabled\":25,\"./transferFlags\":32}],30:[function(require,module,exports){\nvar config = require('../config');\nvar flag = require('./flag');\nvar getProperties = require('./getProperties');\nvar isProxyEnabled = require('./isProxyEnabled');",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - proxify utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - proxify utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9048,
    "codeStart": 9053
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} obj",
        "name": "obj",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} nonChainableMethodName",
        "name": "nonChainableMethodName",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "proxify"
      }
    ],
    "description": {
      "full": "### .proxify(object)\n\nReturn a proxy of given object that throws an error when a non-existent\nproperty is read. By default, the root cause is assumed to be a misspelled\nproperty, and thus an attempt is made to offer a reasonable suggestion from\nthe list of existing properties. However, if a nonChainableMethodName is\nprovided, then the root cause is instead a failure to invoke a non-chainable\nmethod prior to reading the non-existent property.\n\nIf proxies are unsupported or disabled via the user's Chai config, then\nreturn object without modification.",
      "summary": "### .proxify(object)",
      "body": "Return a proxy of given object that throws an error when a non-existent\nproperty is read. By default, the root cause is assumed to be a misspelled\nproperty, and thus an attempt is made to offer a reasonable suggestion from\nthe list of existing properties. However, if a nonChainableMethodName is\nprovided, then the root cause is instead a failure to invoke a non-chainable\nmethod prior to reading the non-existent property.\n\nIf proxies are unsupported or disabled via the user's Chai config, then\nreturn object without modification."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9054,
    "codeStart": 9073,
    "code": "var builtins = ['__flags', '__methods', '_obj', 'assert'];\n\nmodule.exports = function proxify(obj, nonChainableMethodName) {\n  if (!isProxyEnabled()) return obj;\n\n  return new Proxy(obj, {\n    get: function proxyGetter(target, property) {\n      // This check is here because we should not throw errors on Symbol properties\n      // such as `Symbol.toStringTag`.\n      // The values for which an error should be thrown can be configured using\n      // the `config.proxyExcludedKeys` setting.\n      if (typeof property === 'string' &&\n          config.proxyExcludedKeys.indexOf(property) === -1 &&\n          !Reflect.has(target, property)) {\n        // Special message for invalid property access of non-chainable methods.\n        if (nonChainableMethodName) {\n          throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' +\n            property + '. See docs for proper usage of \"' +\n            nonChainableMethodName + '\".');\n        }\n\n        var orderedProperties = getProperties(target).filter(function(property) {\n          return !Object.prototype.hasOwnProperty(property) &&\n            builtins.indexOf(property) === -1;\n        }).sort(function(a, b) {\n          return stringDistance(property, a) - stringDistance(property, b);\n        });\n\n        if (orderedProperties.length &&\n            stringDistance(orderedProperties[0], property) < 4) {\n          // If the property is reasonably close to an existing Chai property,\n          // suggest that property to the user.\n          throw Error('Invalid Chai property: ' + property +\n            '. Did you mean \"' + orderedProperties[0] + '\"?');\n        } else {\n          throw Error('Invalid Chai property: ' + property);\n        }\n      }\n\n      // Use this proxy getter as the starting point for removing implementation\n      // frames from the stack trace of a failed assertion. For property\n      // assertions, this prevents the proxy getter from showing up in the stack\n      // trace since it's invoked before the property getter. For method and\n      // chainable method assertions, this flag will end up getting changed to\n      // the method wrapper, which is good since this frame will no longer be in\n      // the stack once the method is invoked. Note that Chai builtin assertion\n      // properties such as `__flags` are skipped since this is only meant to\n      // capture the starting point of an assertion. This step is also skipped\n      // if the `lockSsfi` flag is set, thus indicating that this assertion is\n      // being called from within another assertion. In that case, the `ssfi`\n      // flag is already set to the outer assertion's starting point.\n      if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {\n        flag(target, 'ssfi', proxyGetter);\n      }\n\n      return Reflect.get(target, property);\n    }\n  });\n};",
    "ctx": {
      "type": "declaration",
      "name": "builtins",
      "value": "['__flags', '__methods', '_obj', 'assert']",
      "string": "builtins"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string} strA",
        "name": "strA",
        "description": "",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} strB",
        "name": "strB",
        "description": "",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{number} the string distance between strA and strB",
        "types": [
          "number"
        ],
        "typesDescription": "<code>number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "the string distance between strA and strB"
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "# stringDistance(strA, strB)\nReturn the Levenshtein distance between two strings.",
      "summary": "# stringDistance(strA, strB)\nReturn the Levenshtein distance between two strings.",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9133,
    "codeStart": 9142,
    "code": "function stringDistance(strA, strB, memo) {\n  if (!memo) {\n    // `memo` is a two-dimensional array containing a cache of distances\n    // memo[i][j] is the distance between strA.slice(0, i) and\n    // strB.slice(0, j).\n    memo = [];\n    for (var i = 0; i <= strA.length; i++) {\n      memo[i] = [];\n    }\n  }\n\n  if (!memo[strA.length] || !memo[strA.length][strB.length]) {\n    if (strA.length === 0 || strB.length === 0) {\n      memo[strA.length][strB.length] = Math.max(strA.length, strB.length);\n    } else {\n      memo[strA.length][strB.length] = Math.min(\n        stringDistance(strA.slice(0, -1), strB, memo) + 1,\n        stringDistance(strA, strB.slice(0, -1), memo) + 1,\n        stringDistance(strA.slice(0, -1), strB.slice(0, -1), memo) +\n          (strA.slice(-1) === strB.slice(-1) ? 0 : 1)\n      );\n    }\n  }\n\n  return memo[strA.length][strB.length];\n}\n\n},{\"../config\":4,\"./flag\":15,\"./getProperties\":21,\"./isProxyEnabled\":25}],31:[function(require,module,exports){",
    "ctx": {
      "type": "function",
      "name": "stringDistance",
      "string": "stringDistance()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - test utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - test utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9170,
    "codeStart": 9175
  },
  {
    "tags": [],
    "description": {
      "full": "Module dependancies",
      "summary": "Module dependancies",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9176,
    "codeStart": 9180,
    "code": "var flag = require('./flag');",
    "ctx": {
      "type": "declaration",
      "name": "flag",
      "value": "require('./flag')",
      "string": "flag"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object (constructed Assertion)",
        "name": "object",
        "description": "(constructed Assertion)",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Arguments} chai.Assertion.prototype.assert arguments",
        "name": "chai.Assertion.prototype.assert",
        "description": "arguments",
        "types": [
          "Arguments"
        ],
        "typesDescription": "<a href=\"Arguments.html\">Arguments</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "test"
      }
    ],
    "description": {
      "full": "### .test(object, expression)\n\nTest and object for expression.",
      "summary": "### .test(object, expression)",
      "body": "Test and object for expression."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9182,
    "codeStart": 9193,
    "code": "module.exports = function test(obj, args) {\n  var negate = flag(obj, 'negate')\n    , expr = args[0];\n  return negate ? !expr : expr;\n};\n\n},{\"./flag\":15}],32:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Chai - transferFlags utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "Chai - transferFlags utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9200,
    "codeStart": 9205
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Assertion} assertion the assertion to transfer the flags from",
        "name": "assertion",
        "description": "the assertion to transfer the flags from",
        "types": [
          "Assertion"
        ],
        "typesDescription": "<a href=\"Assertion.html\">Assertion</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} object the object to transfer the flags to; usually a new assertion",
        "name": "object",
        "description": "the object to transfer the flags to; usually a new assertion",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Boolean} includeAll",
        "name": "includeAll",
        "description": "",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "transferFlags"
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "### .transferFlags(assertion, object, includeAll = true)\n\nTransfer all the flags for `assertion` to `object`. If\n`includeAll` is set to `false`, then the base Chai\nassertion flags (namely `object`, `ssfi`, `lockSsfi`,\nand `message`) will not be transferred.\n\n\n    var newAssertion = new Assertion();\n    utils.transferFlags(assertion, newAssertion);\n\n    var anotherAsseriton = new Assertion(myObj);\n    utils.transferFlags(assertion, anotherAssertion, false);",
      "summary": "### .transferFlags(assertion, object, includeAll = true)",
      "body": "Transfer all the flags for `assertion` to `object`. If\n`includeAll` is set to `false`, then the base Chai\nassertion flags (namely `object`, `ssfi`, `lockSsfi`,\nand `message`) will not be transferred.\n\n\n    var newAssertion = new Assertion();\n    utils.transferFlags(assertion, newAssertion);\n\n    var anotherAsseriton = new Assertion(myObj);\n    utils.transferFlags(assertion, anotherAssertion, false);"
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9206,
    "codeStart": 9229,
    "code": "module.exports = function transferFlags(assertion, object, includeAll) {\n  var flags = assertion.__flags || (assertion.__flags = Object.create(null));\n\n  if (!object.__flags) {\n    object.__flags = Object.create(null);\n  }\n\n  includeAll = arguments.length === 3 ? includeAll : true;\n\n  for (var flag in flags) {\n    if (includeAll ||\n        (flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message')) {\n      object.__flags[flag] = flags[flag];\n    }\n  }\n};\n\n},{}],33:[function(require,module,exports){",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "assertion-error\nCopyright(c) 2013 Jake Luer <jake@qualiancy.com>\nMIT Licensed",
      "summary": "assertion-error\nCopyright(c) 2013 Jake Luer <jake@qualiancy.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9247,
    "codeStart": 9252
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{String} excluded properties ...",
        "name": "excluded",
        "description": "properties ...",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Function}",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": ""
      }
    ],
    "description": {
      "full": "Return a function that will copy properties from\none object to another excluding any originally\nlisted. Returned function will create a new `{}`.",
      "summary": "Return a function that will copy properties from\none object to another excluding any originally\nlisted. Returned function will create a new `{}`.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9253,
    "codeStart": 9262,
    "code": "function exclude () {\n  var excludes = [].slice.call(arguments);\n\n  function excludeProps (res, obj) {\n    Object.keys(obj).forEach(function (key) {\n      if (!~excludes.indexOf(key)) res[key] = obj[key];\n    });\n  }\n\n  return function extendExclude () {\n    var args = [].slice.call(arguments)\n      , i = 0\n      , res = {};\n\n    for (; i < args.length; i++) {\n      excludeProps(res, args[i]);\n    }\n\n    return res;\n  };\n};",
    "ctx": {
      "type": "function",
      "name": "exclude",
      "string": "exclude()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Primary Exports",
      "summary": "Primary Exports",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9284,
    "codeStart": 9288,
    "code": "module.exports = AssertionError;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "AssertionError",
      "string": "module.exports"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{String} message",
        "name": "message",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} properties to include (optional)",
        "name": "properties",
        "description": "to include (optional)",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{callee} start stack function (optional)",
        "name": "start",
        "description": "stack function (optional)",
        "types": [
          "callee"
        ],
        "typesDescription": "<a href=\"callee.html\">callee</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "### AssertionError\n\nAn extension of the JavaScript `Error` constructor for\nassertion and validation scenarios.",
      "summary": "### AssertionError",
      "body": "An extension of the JavaScript `Error` constructor for\nassertion and validation scenarios."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9290,
    "codeStart": 9301,
    "code": "function AssertionError (message, _props, ssf) {\n  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')\n    , props = extend(_props || {});\n\n  // default values\n  this.message = message || 'Unspecified AssertionError';\n  this.showDiff = false;\n\n  // copy from properties\n  for (var key in props) {\n    this[key] = props[key];\n  }\n\n  // capture stack trace\n  ssf = ssf || arguments.callee;\n  if (ssf && Error.captureStackTrace) {\n    Error.captureStackTrace(this, ssf);\n  } else {\n    try {\n      throw new Error();\n    } catch(e) {\n      this.stack = e.stack;\n    }\n  }\n}",
    "ctx": {
      "type": "function",
      "name": "AssertionError",
      "string": "AssertionError()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Inherit from Error.prototype",
      "summary": "Inherit from Error.prototype",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9327,
    "codeStart": 9331,
    "code": "AssertionError.prototype = Object.create(Error.prototype);",
    "ctx": {
      "type": "property",
      "receiver": "AssertionError",
      "name": "prototype",
      "value": "Object.create(Error.prototype)",
      "string": "AssertionError.prototype"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Statically set name",
      "summary": "Statically set name",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9333,
    "codeStart": 9337,
    "code": "AssertionError.prototype.name = 'AssertionError';",
    "ctx": {
      "type": "property",
      "constructor": "AssertionError",
      "cons": "AssertionError",
      "name": "name",
      "value": "'AssertionError'",
      "string": "AssertionError.prototype.name"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Ensure correct constructor",
      "summary": "Ensure correct constructor",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9339,
    "codeStart": 9343,
    "code": "AssertionError.prototype.constructor = AssertionError;",
    "ctx": {
      "type": "property",
      "constructor": "AssertionError",
      "cons": "AssertionError",
      "name": "constructor",
      "value": "AssertionError",
      "string": "AssertionError.prototype.constructor"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Boolean} include stack (default: `true`)",
        "name": "include",
        "description": "stack (default: `true`)",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Object} object that can be `JSON.stringify`",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "object that can be `JSON.stringify`"
      }
    ],
    "description": {
      "full": "Allow errors to be converted to JSON for static transfer.",
      "summary": "Allow errors to be converted to JSON for static transfer.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9345,
    "codeStart": 9352,
    "code": "AssertionError.prototype.toJSON = function (stack) {\n  var extend = exclude('constructor', 'toJSON', 'stack')\n    , props = extend({ name: this.name }, this);\n\n  // include stack if exists and not turned off\n  if (false !== stack && this.stack) {\n    props.stack = this.stack;\n  }\n\n  return props;\n};\n\n},{}],34:[function(require,module,exports){\n'use strict';",
    "ctx": {
      "type": "method",
      "constructor": "AssertionError",
      "cons": "AssertionError",
      "name": "toJSON",
      "string": "AssertionError.prototype.toJSON()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "!\nChai - checkError utility\nCopyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "!\nChai - checkError utility\nCopyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9367,
    "codeStart": 9372
  },
  {
    "tags": [
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .checkError\n\nChecks that an error conforms to a given set of criteria and/or retrieves information about it.",
      "summary": "### .checkError",
      "body": "Checks that an error conforms to a given set of criteria and/or retrieves information about it."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9373,
    "codeStart": 9380
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "compatibleInstance"
      },
      {
        "type": "param",
        "string": "{Error} thrown error",
        "name": "thrown",
        "description": "error",
        "types": [
          "Error"
        ],
        "typesDescription": "<code>Error</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Error|ErrorConstructor} errorLike object to compare against",
        "name": "errorLike",
        "description": "object to compare against",
        "types": [
          "Error",
          "ErrorConstructor"
        ],
        "typesDescription": "<code>Error</code>|<a href=\"ErrorConstructor.html\">ErrorConstructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .compatibleInstance(thrown, errorLike)\n\nChecks if two instances are compatible (strict equal).\nReturns false if errorLike is not an instance of Error, because instances\ncan only be compatible if they're both error instances.",
      "summary": "### .compatibleInstance(thrown, errorLike)",
      "body": "Checks if two instances are compatible (strict equal).\nReturns false if errorLike is not an instance of Error, because instances\ncan only be compatible if they're both error instances."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9381,
    "codeStart": 9395,
    "code": "function compatibleInstance(thrown, errorLike) {\n  return errorLike instanceof Error && thrown === errorLike;\n}",
    "ctx": {
      "type": "function",
      "name": "compatibleInstance",
      "string": "compatibleInstance()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "compatibleConstructor"
      },
      {
        "type": "param",
        "string": "{Error} thrown error",
        "name": "thrown",
        "description": "error",
        "types": [
          "Error"
        ],
        "typesDescription": "<code>Error</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Error|ErrorConstructor} errorLike object to compare against",
        "name": "errorLike",
        "description": "object to compare against",
        "types": [
          "Error",
          "ErrorConstructor"
        ],
        "typesDescription": "<code>Error</code>|<a href=\"ErrorConstructor.html\">ErrorConstructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .compatibleConstructor(thrown, errorLike)\n\nChecks if two constructors are compatible.\nThis function can receive either an error constructor or\nan error instance as the `errorLike` argument.\nConstructors are compatible if they're the same or if one is\nan instance of another.",
      "summary": "### .compatibleConstructor(thrown, errorLike)",
      "body": "Checks if two constructors are compatible.\nThis function can receive either an error constructor or\nan error instance as the `errorLike` argument.\nConstructors are compatible if they're the same or if one is\nan instance of another."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9399,
    "codeStart": 9415,
    "code": "function compatibleConstructor(thrown, errorLike) {\n  if (errorLike instanceof Error) {\n    // If `errorLike` is an instance of any error we compare their constructors\n    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;\n  } else if (errorLike.prototype instanceof Error || errorLike === Error) {\n    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly\n    return thrown.constructor === errorLike || thrown instanceof errorLike;\n  }\n\n  return false;\n}",
    "ctx": {
      "type": "function",
      "name": "compatibleConstructor",
      "string": "compatibleConstructor()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "compatibleMessage"
      },
      {
        "type": "param",
        "string": "{Error} thrown error",
        "name": "thrown",
        "description": "error",
        "types": [
          "Error"
        ],
        "typesDescription": "<code>Error</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String|RegExp} errMatcher to look for into the message",
        "name": "errMatcher",
        "description": "to look for into the message",
        "types": [
          "String",
          "RegExp"
        ],
        "typesDescription": "<code>String</code>|<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .compatibleMessage(thrown, errMatcher)\n\nChecks if an error's message is compatible with a matcher (String or RegExp).\nIf the message contains the String or passes the RegExp test,\nit is considered compatible.",
      "summary": "### .compatibleMessage(thrown, errMatcher)",
      "body": "Checks if an error's message is compatible with a matcher (String or RegExp).\nIf the message contains the String or passes the RegExp test,\nit is considered compatible."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9427,
    "codeStart": 9441,
    "code": "function compatibleMessage(thrown, errMatcher) {\n  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;\n  if (errMatcher instanceof RegExp) {\n    return errMatcher.test(comparisonString);\n  } else if (typeof errMatcher === 'string') {\n    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers\n  }\n\n  return false;\n}",
    "ctx": {
      "type": "function",
      "name": "compatibleMessage",
      "string": "compatibleMessage()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "getFunctionName"
      },
      {
        "type": "param",
        "string": "{Function} constructorFn",
        "name": "constructorFn",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "### .getFunctionName(constructorFn)\n\nReturns the name of a function.\nThis also includes a polyfill function if `constructorFn.name` is not defined.",
      "summary": "### .getFunctionName(constructorFn)",
      "body": "Returns the name of a function.\nThis also includes a polyfill function if `constructorFn.name` is not defined."
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9452,
    "codeStart": 9464,
    "code": "var functionNameMatch = /\\s*function(?:\\s|\\s*\\/\\*[^(?:*\\/)]+\\*\\/\\s*)*([^\\(\\/]+)/;\nfunction getFunctionName(constructorFn) {\n  var name = '';\n  if (typeof constructorFn.name === 'undefined') {\n    // Here we run a polyfill if constructorFn.name is not defined\n    var match = String(constructorFn).match(functionNameMatch);\n    if (match) {\n      name = match[1];\n    }\n  } else {\n    name = constructorFn.name;\n  }\n\n  return name;\n}",
    "ctx": {
      "type": "declaration",
      "name": "functionNameMatch",
      "value": "/\\s*function(?:\\s|\\s*\\/\\*[^(?:*\\/)]+\\*\\/\\s*)*([^\\(\\/]+)/",
      "string": "functionNameMatch"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "getConstructorName"
      },
      {
        "type": "param",
        "string": "{Error|ErrorConstructor} errorLike",
        "name": "errorLike",
        "description": "",
        "types": [
          "Error",
          "ErrorConstructor"
        ],
        "typesDescription": "<code>Error</code>|<a href=\"ErrorConstructor.html\">ErrorConstructor</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getConstructorName(errorLike)\n\nGets the constructor name for an Error instance or constructor itself.",
      "summary": "### .getConstructorName(errorLike)",
      "body": "Gets the constructor name for an Error instance or constructor itself."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9480,
    "codeStart": 9491,
    "code": "function getConstructorName(errorLike) {\n  var constructorName = errorLike;\n  if (errorLike instanceof Error) {\n    constructorName = getFunctionName(errorLike.constructor);\n  } else if (typeof errorLike === 'function') {\n    // If `err` is not an instance of Error it is an error constructor itself or another function.\n    // If we've got a common function we get its name, otherwise we may need to create a new instance\n    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.\n    constructorName = getFunctionName(errorLike).trim() ||\n        getFunctionName(new errorLike()); // eslint-disable-line new-cap\n  }\n\n  return constructorName;\n}",
    "ctx": {
      "type": "function",
      "name": "getConstructorName",
      "string": "getConstructorName()"
    }
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "getMessage"
      },
      {
        "type": "param",
        "string": "{Error|String} errorLike",
        "name": "errorLike",
        "description": "",
        "types": [
          "Error",
          "String"
        ],
        "typesDescription": "<code>Error</code>|<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getMessage(errorLike)\n\nGets the error message from an error.\nIf `err` is a String itself, we return it.\nIf the error has no message, we return an empty string.",
      "summary": "### .getMessage(errorLike)",
      "body": "Gets the error message from an error.\nIf `err` is a String itself, we return it.\nIf the error has no message, we return an empty string."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9506,
    "codeStart": 9519,
    "code": "function getMessage(errorLike) {\n  var msg = '';\n  if (errorLike && errorLike.message) {\n    msg = errorLike.message;\n  } else if (typeof errorLike === 'string') {\n    msg = errorLike;\n  }\n\n  return msg;\n}\n\nmodule.exports = {\n  compatibleInstance: compatibleInstance,\n  compatibleConstructor: compatibleConstructor,\n  compatibleMessage: compatibleMessage,\n  getMessage: getMessage,\n  getConstructorName: getConstructorName,\n};\n\n},{}],35:[function(require,module,exports){\n'use strict';",
    "ctx": {
      "type": "function",
      "name": "getMessage",
      "string": "getMessage()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "globals Symbol: false, Uint8Array: false, WeakMap: false",
      "summary": "globals Symbol: false, Uint8Array: false, WeakMap: false",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9540,
    "codeStart": 9541
  },
  {
    "tags": [],
    "description": {
      "full": "deep-eql\nCopyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "deep-eql\nCopyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9541,
    "codeStart": 9547,
    "code": "var type = require('type-detect');\nfunction FakeMap() {\n  this._key = 'chai/deep-eql__' + Math.random() + Date.now();\n}\n\nFakeMap.prototype = {\n  get: function getMap(key) {\n    return key[this._key];\n  },\n  set: function setMap(key, value) {\n    if (!Object.isFrozen(key)) {\n      Object.defineProperty(key, this._key, {\n        value: value,\n        configurable: true,\n      });\n    }\n  },\n};\n\nvar MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;",
    "ctx": {
      "type": "declaration",
      "name": "type",
      "value": "require('type-detect')",
      "string": "type"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} leftHandOperand",
        "name": "leftHandOperand",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} rightHandOperand",
        "name": "rightHandOperand",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{MemoizeMap} memoizeMap",
        "name": "memoizeMap",
        "description": "",
        "types": [
          "MemoizeMap"
        ],
        "typesDescription": "<a href=\"MemoizeMap.html\">MemoizeMap</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Boolean|null} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>|<code>null</code>",
        "optional": false,
        "nullable": true,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Check to see if the MemoizeMap has recorded a result of the two operands",
      "summary": "Check to see if the MemoizeMap has recorded a result of the two operands",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9567,
    "codeStart": 9575,
    "code": "function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    return null;\n  }\n  var leftHandMap = memoizeMap.get(leftHandOperand);\n  if (leftHandMap) {\n    var result = leftHandMap.get(rightHandOperand);\n    if (typeof result === 'boolean') {\n      return result;\n    }\n  }\n  return null;\n}",
    "ctx": {
      "type": "function",
      "name": "memoizeCompare",
      "string": "memoizeCompare()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} leftHandOperand",
        "name": "leftHandOperand",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} rightHandOperand",
        "name": "rightHandOperand",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{MemoizeMap} memoizeMap",
        "name": "memoizeMap",
        "description": "",
        "types": [
          "MemoizeMap"
        ],
        "typesDescription": "<a href=\"MemoizeMap.html\">MemoizeMap</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Boolean} result",
        "name": "result",
        "description": "",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "Set the result of the equality into the MemoizeMap",
      "summary": "Set the result of the equality into the MemoizeMap",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9590,
    "codeStart": 9598,
    "code": "function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    return;\n  }\n  var leftHandMap = memoizeMap.get(leftHandOperand);\n  if (leftHandMap) {\n    leftHandMap.set(rightHandOperand, result);\n  } else {\n    leftHandMap = new MemoizeMap();\n    leftHandMap.set(rightHandOperand, result);\n    memoizeMap.set(leftHandOperand, leftHandMap);\n  }\n}",
    "ctx": {
      "type": "function",
      "name": "memoizeSet",
      "string": "memoizeSet()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "Primary Export",
      "summary": "Primary Export",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9613,
    "codeStart": 9617,
    "code": "module.exports = deepEqual;\nmodule.exports.MemoizeMap = MemoizeMap;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "deepEqual",
      "string": "module.exports"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} leftHandOperand",
        "name": "leftHandOperand",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} rightHandOperand",
        "name": "rightHandOperand",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} [options] (optional) Additional options",
        "name": "[options]",
        "description": "(optional) Additional options",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} [options.comparator] (optional) Override default algorithm, determining custom equality.",
        "name": "[options.comparator]",
        "description": "(optional) Override default algorithm, determining custom equality.",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.",
        "name": "[options.memoize]",
        "description": "(optional) Provide a custom memoization object which will cache the results of     complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} equal match",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "equal match"
      }
    ],
    "description": {
      "full": "Assert deeply nested sameValue equality between two objects of any type.",
      "summary": "Assert deeply nested sameValue equality between two objects of any type.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9620,
    "codeStart": 9632,
    "code": "function deepEqual(leftHandOperand, rightHandOperand, options) {\n  // If we have a comparator, we can't assume anything; so bail to its check first.\n  if (options && options.comparator) {\n    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);\n  }\n\n  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);\n  if (simpleResult !== null) {\n    return simpleResult;\n  }\n\n  // Deeper comparisons are pushed through to a larger function\n  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);\n}",
    "ctx": {
      "type": "function",
      "name": "deepEqual",
      "string": "deepEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} leftHandOperand",
        "name": "leftHandOperand",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} rightHandOperand",
        "name": "rightHandOperand",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean|null} equal match",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>|<code>null</code>",
        "optional": false,
        "nullable": true,
        "nonNullable": false,
        "variable": false,
        "description": "equal match"
      }
    ],
    "description": {
      "full": "Many comparisons can be canceled out early via simple equality or primitive checks.",
      "summary": "Many comparisons can be canceled out early via simple equality or primitive checks.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9647,
    "codeStart": 9653,
    "code": "function simpleEqual(leftHandOperand, rightHandOperand) {\n  // Equal references (except for Numbers) can be returned early\n  if (leftHandOperand === rightHandOperand) {\n    // Handle +-0 cases\n    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;\n  }\n\n  // handle NaN cases\n  if (\n    leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare\n    rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare\n  ) {\n    return true;\n  }\n\n  // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,\n  // strings, and undefined, can be compared by reference.\n  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    // Easy out b/c it would have passed the first equality check\n    return false;\n  }\n  return null;\n}",
    "ctx": {
      "type": "function",
      "name": "simpleEqual",
      "string": "simpleEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} leftHandOperand",
        "name": "leftHandOperand",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} rightHandOperand",
        "name": "rightHandOperand",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} [options] (optional) Additional options",
        "name": "[options]",
        "description": "(optional) Additional options",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} [options.comparator] (optional) Override default algorithm, determining custom equality.",
        "name": "[options.comparator]",
        "description": "(optional) Override default algorithm, determining custom equality.",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.",
        "name": "[options.memoize]",
        "description": "(optional) Provide a custom memoization object which will cache the results of     complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} equal match",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "equal match"
      }
    ],
    "description": {
      "full": "The main logic of the `deepEqual` function.",
      "summary": "The main logic of the `deepEqual` function.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9677,
    "codeStart": 9689,
    "code": "function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {\n  options = options || {};\n  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();\n  var comparator = options && options.comparator;\n\n  // Check if a memoized result exists.\n  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);\n  if (memoizeResultLeft !== null) {\n    return memoizeResultLeft;\n  }\n  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);\n  if (memoizeResultRight !== null) {\n    return memoizeResultRight;\n  }\n\n  // If a comparator is present, use it.\n  if (comparator) {\n    var comparatorResult = comparator(leftHandOperand, rightHandOperand);\n    // Comparators may return null, in which case we want to go back to default behavior.\n    if (comparatorResult === false || comparatorResult === true) {\n      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);\n      return comparatorResult;\n    }\n    // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide\n    // what to do, we need to make sure to return the basic tests first before we move on.\n    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);\n    if (simpleResult !== null) {\n      // Don't memoize this, it takes longer to set/retrieve than to just compare.\n      return simpleResult;\n    }\n  }\n\n  var leftHandType = type(leftHandOperand);\n  if (leftHandType !== type(rightHandOperand)) {\n    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);\n    return false;\n  }\n\n  // Temporarily set the operands in the memoize object to prevent blowing the stack\n  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);\n\n  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);\n  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);\n  return result;\n}\n\nfunction extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {\n  switch (leftHandType) {\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n    case 'Date':\n      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values\n      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());\n    case 'Promise':\n    case 'Symbol':\n    case 'function':\n    case 'WeakMap':\n    case 'WeakSet':\n    case 'Error':\n      return leftHandOperand === rightHandOperand;\n    case 'Arguments':\n    case 'Int8Array':\n    case 'Uint8Array':\n    case 'Uint8ClampedArray':\n    case 'Int16Array':\n    case 'Uint16Array':\n    case 'Int32Array':\n    case 'Uint32Array':\n    case 'Float32Array':\n    case 'Float64Array':\n    case 'Array':\n      return iterableEqual(leftHandOperand, rightHandOperand, options);\n    case 'RegExp':\n      return regexpEqual(leftHandOperand, rightHandOperand);\n    case 'Generator':\n      return generatorEqual(leftHandOperand, rightHandOperand, options);\n    case 'DataView':\n      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);\n    case 'ArrayBuffer':\n      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);\n    case 'Set':\n      return entriesEqual(leftHandOperand, rightHandOperand, options);\n    case 'Map':\n      return entriesEqual(leftHandOperand, rightHandOperand, options);\n    default:\n      return objectEqual(leftHandOperand, rightHandOperand, options);\n  }\n}",
    "ctx": {
      "type": "function",
      "name": "extensiveDeepEqual",
      "string": "extensiveDeepEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{RegExp} leftHandOperand",
        "name": "leftHandOperand",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{RegExp} rightHandOperand",
        "name": "rightHandOperand",
        "description": "",
        "types": [
          "RegExp"
        ],
        "typesDescription": "<code>RegExp</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Compare two Regular Expressions for equality.",
      "summary": "Compare two Regular Expressions for equality.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9779,
    "codeStart": 9787,
    "code": "function regexpEqual(leftHandOperand, rightHandOperand) {\n  return leftHandOperand.toString() === rightHandOperand.toString();\n}",
    "ctx": {
      "type": "function",
      "name": "regexpEqual",
      "string": "regexpEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Set} leftHandOperand",
        "name": "leftHandOperand",
        "description": "",
        "types": [
          "Set"
        ],
        "typesDescription": "<a href=\"Set.html\">Set</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Set} rightHandOperand",
        "name": "rightHandOperand",
        "description": "",
        "types": [
          "Set"
        ],
        "typesDescription": "<a href=\"Set.html\">Set</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} [options] (Optional)",
        "name": "[options]",
        "description": "(Optional)",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Compare two Sets/Maps for equality. Faster than other equality functions.",
      "summary": "Compare two Sets/Maps for equality. Faster than other equality functions.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9791,
    "codeStart": 9800,
    "code": "function entriesEqual(leftHandOperand, rightHandOperand, options) {\n  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach\n  if (leftHandOperand.size !== rightHandOperand.size) {\n    return false;\n  }\n  if (leftHandOperand.size === 0) {\n    return true;\n  }\n  var leftHandItems = [];\n  var rightHandItems = [];\n  leftHandOperand.forEach(function gatherEntries(key, value) {\n    leftHandItems.push([ key, value ]);\n  });\n  rightHandOperand.forEach(function gatherEntries(key, value) {\n    rightHandItems.push([ key, value ]);\n  });\n  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);\n}",
    "ctx": {
      "type": "function",
      "name": "entriesEqual",
      "string": "entriesEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Iterable} leftHandOperand",
        "name": "leftHandOperand",
        "description": "",
        "types": [
          "Iterable"
        ],
        "typesDescription": "<a href=\"Iterable.html\">Iterable</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Iterable} rightHandOperand",
        "name": "rightHandOperand",
        "description": "",
        "types": [
          "Iterable"
        ],
        "typesDescription": "<a href=\"Iterable.html\">Iterable</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} [options] (Optional)",
        "name": "[options]",
        "description": "(Optional)",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.",
      "summary": "Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9819,
    "codeStart": 9828,
    "code": "function iterableEqual(leftHandOperand, rightHandOperand, options) {\n  var length = leftHandOperand.length;\n  if (length !== rightHandOperand.length) {\n    return false;\n  }\n  if (length === 0) {\n    return true;\n  }\n  var index = -1;\n  while (++index < length) {\n    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {\n      return false;\n    }\n  }\n  return true;\n}",
    "ctx": {
      "type": "function",
      "name": "iterableEqual",
      "string": "iterableEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Iterable} leftHandOperand",
        "name": "leftHandOperand",
        "description": "",
        "types": [
          "Iterable"
        ],
        "typesDescription": "<a href=\"Iterable.html\">Iterable</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Iterable} rightHandOperand",
        "name": "rightHandOperand",
        "description": "",
        "types": [
          "Iterable"
        ],
        "typesDescription": "<a href=\"Iterable.html\">Iterable</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} [options] (Optional)",
        "name": "[options]",
        "description": "(Optional)",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Simple equality for generator objects such as those returned by generator functions.",
      "summary": "Simple equality for generator objects such as those returned by generator functions.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9845,
    "codeStart": 9854,
    "code": "function generatorEqual(leftHandOperand, rightHandOperand, options) {\n  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);\n}",
    "ctx": {
      "type": "function",
      "name": "generatorEqual",
      "string": "generatorEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} target",
        "name": "target",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} `true` if the object has an @@iterator function.",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "`true` if the object has an @@iterator function."
      }
    ],
    "description": {
      "full": "Determine if the given object has an @@iterator function.",
      "summary": "Determine if the given object has an @@iterator function.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9858,
    "codeStart": 9864,
    "code": "function hasIteratorFunction(target) {\n  return typeof Symbol !== 'undefined' &&\n    typeof target === 'object' &&\n    typeof Symbol.iterator !== 'undefined' &&\n    typeof target[Symbol.iterator] === 'function';\n}",
    "ctx": {
      "type": "function",
      "name": "hasIteratorFunction",
      "string": "hasIteratorFunction()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} target",
        "name": "target",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Array} an array of entries from the @@iterator function",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "an array of entries from the @@iterator function"
      }
    ],
    "description": {
      "full": "Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.\nThis will consume the iterator - which could have side effects depending on the @@iterator implementation.",
      "summary": "Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.\nThis will consume the iterator - which could have side effects depending on the @@iterator implementation.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9871,
    "codeStart": 9878,
    "code": "function getIteratorEntries(target) {\n  if (hasIteratorFunction(target)) {\n    try {\n      return getGeneratorEntries(target[Symbol.iterator]());\n    } catch (iteratorError) {\n      return [];\n    }\n  }\n  return [];\n}",
    "ctx": {
      "type": "function",
      "name": "getIteratorEntries",
      "string": "getIteratorEntries()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Generator} target",
        "name": "target",
        "description": "",
        "types": [
          "Generator"
        ],
        "typesDescription": "<a href=\"Generator.html\">Generator</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Array} an array of entries from the Generator.",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "an array of entries from the Generator."
      }
    ],
    "description": {
      "full": "Gets all entries from a Generator. This will consume the generator - which could have side effects.",
      "summary": "Gets all entries from a Generator. This will consume the generator - which could have side effects.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9889,
    "codeStart": 9895,
    "code": "function getGeneratorEntries(generator) {\n  var generatorResult = generator.next();\n  var accumulator = [ generatorResult.value ];\n  while (generatorResult.done === false) {\n    generatorResult = generator.next();\n    accumulator.push(generatorResult.value);\n  }\n  return accumulator;\n}",
    "ctx": {
      "type": "function",
      "name": "getGeneratorEntries",
      "string": "getGeneratorEntries()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} target",
        "name": "target",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Array} an array of own and inherited enumerable keys from the target.",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "an array of own and inherited enumerable keys from the target."
      }
    ],
    "description": {
      "full": "Gets all own and inherited enumerable keys from a target.",
      "summary": "Gets all own and inherited enumerable keys from a target.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9905,
    "codeStart": 9911,
    "code": "function getEnumerableKeys(target) {\n  var keys = [];\n  for (var key in target) {\n    keys.push(key);\n  }\n  return keys;\n}",
    "ctx": {
      "type": "function",
      "name": "getEnumerableKeys",
      "string": "getEnumerableKeys()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} leftHandOperand",
        "name": "leftHandOperand",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} rightHandOperand",
        "name": "rightHandOperand",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against",
        "name": "keys",
        "description": "An array of keys to compare the values of leftHandOperand and rightHandOperand against",
        "types": [
          "Array"
        ],
        "typesDescription": "<code>Array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} [options] (Optional)",
        "name": "[options]",
        "description": "(Optional)",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of\neach key. If any value of the given key is not equal, the function will return false (early).",
      "summary": "Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of\neach key. If any value of the given key is not equal, the function will return false (early).",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9919,
    "codeStart": 9929,
    "code": "function keysEqual(leftHandOperand, rightHandOperand, keys, options) {\n  var length = keys.length;\n  if (length === 0) {\n    return true;\n  }\n  for (var i = 0; i < length; i += 1) {\n    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {\n      return false;\n    }\n  }\n  return true;\n}",
    "ctx": {
      "type": "function",
      "name": "keysEqual",
      "string": "keysEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} leftHandOperand",
        "name": "leftHandOperand",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} rightHandOperand",
        "name": "rightHandOperand",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} [options] (Optional)",
        "name": "[options]",
        "description": "(Optional)",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`\nfor each enumerable key in the object.",
      "summary": "Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`\nfor each enumerable key in the object.",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9942,
    "codeStart": 9952,
    "code": "function objectEqual(leftHandOperand, rightHandOperand, options) {\n  var leftHandKeys = getEnumerableKeys(leftHandOperand);\n  var rightHandKeys = getEnumerableKeys(rightHandOperand);\n  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {\n    leftHandKeys.sort();\n    rightHandKeys.sort();\n    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {\n      return false;\n    }\n    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);\n  }\n\n  var leftHandEntries = getIteratorEntries(leftHandOperand);\n  var rightHandEntries = getIteratorEntries(rightHandOperand);\n  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {\n    leftHandEntries.sort();\n    rightHandEntries.sort();\n    return iterableEqual(leftHandEntries, rightHandEntries, options);\n  }\n\n  if (leftHandKeys.length === 0 &&\n      leftHandEntries.length === 0 &&\n      rightHandKeys.length === 0 &&\n      rightHandEntries.length === 0) {\n    return true;\n  }\n\n  return false;\n}",
    "ctx": {
      "type": "function",
      "name": "objectEqual",
      "string": "objectEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{Boolean} result",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "result"
      }
    ],
    "description": {
      "full": "Returns true if the argument is a primitive.\n\nThis intentionally returns true for all objects that can be compared by reference,\nincluding functions and symbols.",
      "summary": "Returns true if the argument is a primitive.",
      "body": "This intentionally returns true for all objects that can be compared by reference,\nincluding functions and symbols."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 9982,
    "codeStart": 9991,
    "code": "function isPrimitive(value) {\n  return value === null || typeof value !== 'object';\n}\n\n},{\"type-detect\":38}],36:[function(require,module,exports){\n'use strict';",
    "ctx": {
      "type": "function",
      "name": "isPrimitive",
      "string": "isPrimitive()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "!\nChai - getFuncName utility\nCopyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "!\nChai - getFuncName utility\nCopyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 9998,
    "codeStart": 10003
  },
  {
    "tags": [
      {
        "type": "name",
        "string": "getFuncName"
      },
      {
        "type": "param",
        "string": "{Function} funct",
        "name": "funct",
        "description": "",
        "types": [
          "Function"
        ],
        "typesDescription": "<code>Function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getFuncName(constructorFn)\n\nReturns the name of a function.\nWhen a non-function instance is passed, returns `null`.\nThis also includes a polyfill function if `aFunc.name` is not defined.",
      "summary": "### .getFuncName(constructorFn)",
      "body": "Returns the name of a function.\nWhen a non-function instance is passed, returns `null`.\nThis also includes a polyfill function if `aFunc.name` is not defined."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10004,
    "codeStart": 10017,
    "code": "var toString = Function.prototype.toString;\nvar functionNameMatch = /\\s*function(?:\\s|\\s*\\/\\*[^(?:*\\/)]+\\*\\/\\s*)*([^\\s\\(\\/]+)/;\nfunction getFuncName(aFunc) {\n  if (typeof aFunc !== 'function') {\n    return null;\n  }\n\n  var name = '';\n  if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {\n    // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined\n    var match = toString.call(aFunc).match(functionNameMatch);\n    if (match) {\n      name = match[1];\n    }\n  } else {\n    // If we've got a `name` property we just use it\n    name = aFunc.name;\n  }\n\n  return name;\n}\n\nmodule.exports = getFuncName;\n\n},{}],37:[function(require,module,exports){\n'use strict';",
    "ctx": {
      "type": "declaration",
      "name": "toString",
      "value": "Function.prototype.toString",
      "string": "toString"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "string": "https://github.com/logicalparadox/filtr\nMIT Licensed",
        "title": "https://github.com/logicalparadox/filtr",
        "url": "MIT Licensed"
      }
    ],
    "description": {
      "full": "!\nChai - pathval utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>",
      "summary": "!\nChai - pathval utility\nCopyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10044,
    "codeStart": 10050
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String|Symbol} name",
        "name": "name",
        "description": "",
        "types": [
          "String",
          "Symbol"
        ],
        "typesDescription": "<code>String</code>|<a href=\"Symbol.html\">Symbol</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Boolean} whether it exists",
        "types": [
          "Boolean"
        ],
        "typesDescription": "<code>Boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "whether it exists"
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "hasProperty"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .hasProperty(object, name)\n\nThis allows checking whether an object has own\nor inherited from prototype chain named property.\n\nBasically does the same thing as the `in`\noperator but works properly with null/undefined values\nand other primitives.\n\n    var obj = {\n        arr: ['a', 'b', 'c']\n      , str: 'Hello'\n    }\n\nThe following would be the results.\n\n    hasProperty(obj, 'str');  // true\n    hasProperty(obj, 'constructor');  // true\n    hasProperty(obj, 'bar');  // false\n\n    hasProperty(obj.str, 'length'); // true\n    hasProperty(obj.str, 1);  // true\n    hasProperty(obj.str, 5);  // false\n\n    hasProperty(obj.arr, 'length');  // true\n    hasProperty(obj.arr, 2);  // true\n    hasProperty(obj.arr, 3);  // false",
      "summary": "### .hasProperty(object, name)",
      "body": "This allows checking whether an object has own\nor inherited from prototype chain named property.\n\nBasically does the same thing as the `in`\noperator but works properly with null/undefined values\nand other primitives.\n\n    var obj = {\n        arr: ['a', 'b', 'c']\n      , str: 'Hello'\n    }\n\nThe following would be the results.\n\n    hasProperty(obj, 'str');  // true\n    hasProperty(obj, 'constructor');  // true\n    hasProperty(obj, 'bar');  // false\n\n    hasProperty(obj.str, 'length'); // true\n    hasProperty(obj.str, 1);  // true\n    hasProperty(obj.str, 5);  // false\n\n    hasProperty(obj.arr, 'length');  // true\n    hasProperty(obj.arr, 2);  // true\n    hasProperty(obj.arr, 3);  // false"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10051,
    "codeStart": 10088,
    "code": "function hasProperty(obj, name) {\n  if (typeof obj === 'undefined' || obj === null) {\n    return false;\n  }\n\n  // The `in` operator does not work with primitives.\n  return name in Object(obj);\n}",
    "ctx": {
      "type": "function",
      "name": "hasProperty",
      "string": "hasProperty()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{String} path",
        "name": "path",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Object} parsed",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "parsed"
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "!\n## parsePath(path)\n\nHelper function used to parse string object\npaths. Use in conjunction with `internalGetPathValue`.\n\n     var parsed = parsePath('myobject.property.subprop');\n\n### Paths:\n\n* Can be infinitely deep and nested.\n* Arrays are also valid using the formal `myobject.document[3].property`.\n* Literal dots and brackets (not delimiter) must be backslash-escaped.",
      "summary": "!\n## parsePath(path)",
      "body": "Helper function used to parse string object\npaths. Use in conjunction with `internalGetPathValue`.\n\n     var parsed = parsePath('myobject.property.subprop');\n\n### Paths:\n\n* Can be infinitely deep and nested.\n* Arrays are also valid using the formal `myobject.document[3].property`.\n* Literal dots and brackets (not delimiter) must be backslash-escaped."
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10097,
    "codeStart": 10116,
    "code": "function parsePath(path) {\n  var str = path.replace(/([^\\\\])\\[/g, '$1.[');\n  var parts = str.match(/(\\\\\\.|[^.]+?)+/g);\n  return parts.map(function mapMatches(value) {\n    var regexp = /^\\[(\\d+)\\]$/;\n    var mArr = regexp.exec(value);\n    var parsed = null;\n    if (mArr) {\n      parsed = { i: parseFloat(mArr[1]) };\n    } else {\n      parsed = { p: value.replace(/\\\\([.\\[\\]])/g, '$1') };\n    }\n\n    return parsed;\n  });\n}",
    "ctx": {
      "type": "function",
      "name": "parsePath",
      "string": "parsePath()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object to search against",
        "name": "object",
        "description": "to search against",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} parsed definition from `parsePath`.",
        "name": "parsed",
        "description": "definition from `parsePath`.",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Number} depth (nesting level) of the property we want to retrieve",
        "name": "depth",
        "description": "(nesting level) of the property we want to retrieve",
        "types": [
          "Number"
        ],
        "typesDescription": "<code>Number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Object|Undefined} value",
        "types": [
          "Object",
          "Undefined"
        ],
        "typesDescription": "<code>Object</code>|<code>Undefined</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "value"
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "!\n## internalGetPathValue(obj, parsed[, pathDepth])\n\nHelper companion function for `.parsePath` that returns\nthe value located at the parsed address.\n\n     var value = getPathValue(obj, parsed);",
      "summary": "!\n## internalGetPathValue(obj, parsed[, pathDepth])",
      "body": "Helper companion function for `.parsePath` that returns\nthe value located at the parsed address.\n\n     var value = getPathValue(obj, parsed);"
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10133,
    "codeStart": 10148,
    "code": "function internalGetPathValue(obj, parsed, pathDepth) {\n  var temporaryValue = obj;\n  var res = null;\n  pathDepth = (typeof pathDepth === 'undefined' ? parsed.length : pathDepth);\n\n  for (var i = 0; i < pathDepth; i++) {\n    var part = parsed[i];\n    if (temporaryValue) {\n      if (typeof part.p === 'undefined') {\n        temporaryValue = temporaryValue[part.i];\n      } else {\n        temporaryValue = temporaryValue[part.p];\n      }\n\n      if (i === (pathDepth - 1)) {\n        res = temporaryValue;\n      }\n    }\n  }\n\n  return res;\n}",
    "ctx": {
      "type": "function",
      "name": "internalGetPathValue",
      "string": "internalGetPathValue()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object to search and define on",
        "name": "object",
        "description": "to search and define on",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{*} value to use upon set",
        "name": "value",
        "description": "to use upon set",
        "types": [],
        "typesDescription": "<code>*</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Object} parsed definition from `parsePath`",
        "name": "parsed",
        "description": "definition from `parsePath`",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "!\n## internalSetPathValue(obj, value, parsed)\n\nCompanion function for `parsePath` that sets\nthe value located at a parsed address.\n\n internalSetPathValue(obj, 'value', parsed);",
      "summary": "!\n## internalSetPathValue(obj, value, parsed)",
      "body": "Companion function for `parsePath` that sets\nthe value located at a parsed address.\n\n internalSetPathValue(obj, 'value', parsed);"
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10171,
    "codeStart": 10185,
    "code": "function internalSetPathValue(obj, val, parsed) {\n  var tempObj = obj;\n  var pathDepth = parsed.length;\n  var part = null;\n  // Here we iterate through every part of the path\n  for (var i = 0; i < pathDepth; i++) {\n    var propName = null;\n    var propVal = null;\n    part = parsed[i];\n\n    // If it's the last part of the path, we set the 'propName' value with the property name\n    if (i === (pathDepth - 1)) {\n      propName = typeof part.p === 'undefined' ? part.i : part.p;\n      // Now we set the property with the name held by 'propName' on object with the desired val\n      tempObj[propName] = val;\n    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {\n      tempObj = tempObj[part.p];\n    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {\n      tempObj = tempObj[part.i];\n    } else {\n      // If the obj doesn't have the property we create one with that name to define it\n      var next = parsed[i + 1];\n      // Here we set the name of the property which will be defined\n      propName = typeof part.p === 'undefined' ? part.i : part.p;\n      // Here we decide if this property will be an array or a new object\n      propVal = typeof next.p === 'undefined' ? [] : {};\n      tempObj[propName] = propVal;\n      tempObj = tempObj[propName];\n    }\n  }\n}",
    "ctx": {
      "type": "function",
      "name": "internalSetPathValue",
      "string": "internalSetPathValue()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} path",
        "name": "path",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Object} info",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "info"
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getPathInfo"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getPathInfo(object, path)\n\nThis allows the retrieval of property info in an\nobject given a string path.\n\nThe path info consists of an object with the\nfollowing properties:\n\n* parent - The parent object of the property referenced by `path`\n* name - The name of the final property, a number if it was an array indexer\n* value - The value of the property, if it exists, otherwise `undefined`\n* exists - Whether the property exists or not",
      "summary": "### .getPathInfo(object, path)",
      "body": "This allows the retrieval of property info in an\nobject given a string path.\n\nThe path info consists of an object with the\nfollowing properties:\n\n* parent - The parent object of the property referenced by `path`\n* name - The name of the final property, a number if it was an array indexer\n* value - The value of the property, if it exists, otherwise `undefined`\n* exists - Whether the property exists or not"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10217,
    "codeStart": 10239,
    "code": "function getPathInfo(obj, path) {\n  var parsed = parsePath(path);\n  var last = parsed[parsed.length - 1];\n  var info = {\n    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,\n    name: last.p || last.i,\n    value: internalGetPathValue(obj, parsed),\n  };\n  info.exists = hasProperty(info.parent, info.name);\n\n  return info;\n}",
    "ctx": {
      "type": "function",
      "name": "getPathInfo",
      "string": "getPathInfo()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} path",
        "name": "path",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "returns",
        "string": "{Object} value or `undefined`",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "value or `undefined`"
      },
      {
        "type": "namespace",
        "string": "Utils"
      },
      {
        "type": "name",
        "string": "getPathValue"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### .getPathValue(object, path)\n\nThis allows the retrieval of values in an\nobject given a string path.\n\n    var obj = {\n        prop1: {\n            arr: ['a', 'b', 'c']\n          , str: 'Hello'\n        }\n      , prop2: {\n            arr: [ { nested: 'Universe' } ]\n          , str: 'Hello again!'\n        }\n    }\n\nThe following would be the results.\n\n    getPathValue(obj, 'prop1.str'); // Hello\n    getPathValue(obj, 'prop1.att[2]'); // b\n    getPathValue(obj, 'prop2.arr[0].nested'); // Universe",
      "summary": "### .getPathValue(object, path)",
      "body": "This allows the retrieval of values in an\nobject given a string path.\n\n    var obj = {\n        prop1: {\n            arr: ['a', 'b', 'c']\n          , str: 'Hello'\n        }\n      , prop2: {\n            arr: [ { nested: 'Universe' } ]\n          , str: 'Hello again!'\n        }\n    }\n\nThe following would be the results.\n\n    getPathValue(obj, 'prop1.str'); // Hello\n    getPathValue(obj, 'prop1.att[2]'); // b\n    getPathValue(obj, 'prop2.arr[0].nested'); // Universe"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10252,
    "codeStart": 10283,
    "code": "function getPathValue(obj, path) {\n  var info = getPathInfo(obj, path);\n  return info.value;\n}",
    "ctx": {
      "type": "function",
      "name": "getPathValue",
      "string": "getPathValue()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Object} object",
        "name": "object",
        "description": "",
        "types": [
          "Object"
        ],
        "typesDescription": "<code>Object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{String} path",
        "name": "path",
        "description": "",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Mixed} value",
        "name": "value",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "api",
        "string": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "### .setPathValue(object, path, value)\n\nDefine the value in an object at a given string path.\n\n```js\nvar obj = {\n    prop1: {\n        arr: ['a', 'b', 'c']\n      , str: 'Hello'\n    }\n  , prop2: {\n        arr: [ { nested: 'Universe' } ]\n      , str: 'Hello again!'\n    }\n};\n```\n\nThe following would be acceptable.\n\n```js\nvar properties = require('tea-properties');\nproperties.set(obj, 'prop1.str', 'Hello Universe!');\nproperties.set(obj, 'prop1.arr[2]', 'B');\nproperties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });\n```",
      "summary": "### .setPathValue(object, path, value)",
      "body": "Define the value in an object at a given string path.\n\n```js\nvar obj = {\n    prop1: {\n        arr: ['a', 'b', 'c']\n      , str: 'Hello'\n    }\n  , prop2: {\n        arr: [ { nested: 'Universe' } ]\n      , str: 'Hello again!'\n    }\n};\n```\n\nThe following would be acceptable.\n\n```js\nvar properties = require('tea-properties');\nproperties.set(obj, 'prop1.str', 'Hello Universe!');\nproperties.set(obj, 'prop1.arr[2]', 'B');\nproperties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });\n```"
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10288,
    "codeStart": 10321,
    "code": "function setPathValue(obj, path, val) {\n  var parsed = parsePath(path);\n  internalSetPathValue(obj, val, parsed);\n  return obj;\n}\n\nmodule.exports = {\n  hasProperty: hasProperty,\n  getPathInfo: getPathInfo,\n  getPathValue: getPathValue,\n  setPathValue: setPathValue,\n};\n\n},{}],38:[function(require,module,exports){\n'use strict';",
    "ctx": {
      "type": "function",
      "name": "setPathValue",
      "string": "setPathValue()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "!\ntype-detect\nCopyright(c) 2013 jake luer <jake@alogicalparadox.com>\nMIT Licensed",
      "summary": "!\ntype-detect\nCopyright(c) 2013 jake luer <jake@alogicalparadox.com>\nMIT Licensed",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10337,
    "codeStart": 10342,
    "code": "var promiseExists = typeof Promise === 'function';\nvar globalObject = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : self; // eslint-disable-line\nvar isDom = 'location' in globalObject && 'document' in globalObject;\nvar symbolExists = typeof Symbol !== 'undefined';\nvar mapExists = typeof Map !== 'undefined';\nvar setExists = typeof Set !== 'undefined';\nvar weakMapExists = typeof WeakMap !== 'undefined';\nvar weakSetExists = typeof WeakSet !== 'undefined';\nvar dataViewExists = typeof DataView !== 'undefined';\nvar symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';\nvar symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';\nvar setEntriesExists = setExists && typeof Set.prototype.entries === 'function';\nvar mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';\nvar setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());\nvar mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());\nvar arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';\nvar arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());\nvar stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';\nvar stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());\nvar toStringLeftSliceLength = 8;\nvar toStringRightSliceLength = -1;",
    "ctx": {
      "type": "declaration",
      "name": "promiseExists",
      "value": "typeof Promise === 'function'",
      "string": "promiseExists"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{Mixed} object",
        "name": "object",
        "description": "",
        "types": [
          "Mixed"
        ],
        "typesDescription": "<a href=\"Mixed.html\">Mixed</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{String} object type",
        "types": [
          "String"
        ],
        "typesDescription": "<code>String</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "object type"
      },
      {
        "type": "api",
        "string": "public",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "### typeOf (obj)\n\nUses `Object.prototype.toString` to determine the type of an object,\nnormalising behaviour across engine versions & well optimised.",
      "summary": "### typeOf (obj)",
      "body": "Uses `Object.prototype.toString` to determine the type of an object,\nnormalising behaviour across engine versions & well optimised."
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10363,
    "codeStart": 10373,
    "code": "module.exports = function typeDetect(obj) {",
    "ctx": {
      "type": "method",
      "receiver": "module",
      "name": "exports",
      "string": "module.exports()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Speed optimisation\nPre:\n  string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)\n  boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)\n  number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)\n  undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)\n  function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)\nPost:\n  string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)\n  boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)\n  number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)\n  undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)\n  function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)",
      "summary": "! Speed optimisation\nPre:\n  string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)\n  boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)\n  number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)\n  undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)\n  function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)\nPost:\n  string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)\n  boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)\n  number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)\n  undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)\n  function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10374,
    "codeStart": 10388,
    "code": "var typeofObj = typeof obj;\nif (typeofObj !== 'object') {\n  return typeofObj;\n}",
    "ctx": {
      "type": "declaration",
      "name": "typeofObj",
      "value": "typeof obj",
      "string": "typeofObj"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Speed optimisation\nPre:\n  null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)\nPost:\n  null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)",
      "summary": "! Speed optimisation\nPre:\n  null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)\nPost:\n  null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10393,
    "codeStart": 10399,
    "code": "if (obj === null) {\n  return 'null';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Spec Conformance\nTest: `Object.prototype.toString.call(window)``\n - Node === \"[object global]\"\n - Chrome === \"[object global]\"\n - Firefox === \"[object Window]\"\n - PhantomJS === \"[object Window]\"\n - Safari === \"[object Window]\"\n - IE 11 === \"[object Window]\"\n - IE Edge === \"[object Window]\"\nTest: `Object.prototype.toString.call(this)``\n - Chrome Worker === \"[object global]\"\n - Firefox Worker === \"[object DedicatedWorkerGlobalScope]\"\n - Safari Worker === \"[object DedicatedWorkerGlobalScope]\"\n - IE 11 Worker === \"[object WorkerGlobalScope]\"\n - IE Edge Worker === \"[object WorkerGlobalScope]\"",
      "summary": "! Spec Conformance\nTest: `Object.prototype.toString.call(window)``\n - Node === \"[object global]\"\n - Chrome === \"[object global]\"\n - Firefox === \"[object Window]\"\n - PhantomJS === \"[object Window]\"\n - Safari === \"[object Window]\"\n - IE 11 === \"[object Window]\"\n - IE Edge === \"[object Window]\"\nTest: `Object.prototype.toString.call(this)``\n - Chrome Worker === \"[object global]\"\n - Firefox Worker === \"[object DedicatedWorkerGlobalScope]\"\n - Safari Worker === \"[object DedicatedWorkerGlobalScope]\"\n - IE 11 Worker === \"[object WorkerGlobalScope]\"\n - IE Edge Worker === \"[object WorkerGlobalScope]\"",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10403,
    "codeStart": 10419,
    "code": "if (obj === globalObject) {\n  return 'global';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Speed optimisation\nPre:\n  array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)\nPost:\n  array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)",
      "summary": "! Speed optimisation\nPre:\n  array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)\nPost:\n  array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10423,
    "codeStart": 10429,
    "code": "if (\n  Array.isArray(obj) &&\n  (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))\n) {\n  return 'Array';\n}\n\nif (isDom) {",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Spec Conformance\n(https://html.spec.whatwg.org/multipage/browsers.html#location)\nWhatWG HTML$7.7.3 - The `Location` interface\nTest: `Object.prototype.toString.call(window.location)``\n - IE <=11 === \"[object Object]\"\n - IE Edge <=13 === \"[object Object]\"",
      "summary": "! Spec Conformance\n(https://html.spec.whatwg.org/multipage/browsers.html#location)\nWhatWG HTML$7.7.3 - The `Location` interface\nTest: `Object.prototype.toString.call(window.location)``\n - IE <=11 === \"[object Object]\"\n - IE Edge <=13 === \"[object Object]\"",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10437,
    "codeStart": 10444,
    "code": "if (obj === globalObject.location) {\n  return 'Location';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Spec Conformance\n(https://html.spec.whatwg.org/#document)\nWhatWG HTML$3.1.1 - The `Document` object\nNote: Most browsers currently adher to the W3C DOM Level 2 spec\n      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)\n      which suggests that browsers should use HTMLTableCellElement for\n      both TD and TH elements. WhatWG separates these.\n      WhatWG HTML states:\n        > For historical reasons, Window objects must also have a\n        > writable, configurable, non-enumerable property named\n        > HTMLDocument whose value is the Document interface object.\nTest: `Object.prototype.toString.call(document)``\n - Chrome === \"[object HTMLDocument]\"\n - Firefox === \"[object HTMLDocument]\"\n - Safari === \"[object HTMLDocument]\"\n - IE <=10 === \"[object Document]\"\n - IE 11 === \"[object HTMLDocument]\"\n - IE Edge <=13 === \"[object HTMLDocument]\"",
      "summary": "! Spec Conformance\n(https://html.spec.whatwg.org/#document)\nWhatWG HTML$3.1.1 - The `Document` object\nNote: Most browsers currently adher to the W3C DOM Level 2 spec\n      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)\n      which suggests that browsers should use HTMLTableCellElement for\n      both TD and TH elements. WhatWG separates these.\n      WhatWG HTML states:\n        > For historical reasons, Window objects must also have a\n        > writable, configurable, non-enumerable property named\n        > HTMLDocument whose value is the Document interface object.\nTest: `Object.prototype.toString.call(document)``\n - Chrome === \"[object HTMLDocument]\"\n - Firefox === \"[object HTMLDocument]\"\n - Safari === \"[object HTMLDocument]\"\n - IE <=10 === \"[object Document]\"\n - IE 11 === \"[object HTMLDocument]\"\n - IE Edge <=13 === \"[object HTMLDocument]\"",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10448,
    "codeStart": 10467,
    "code": "if (obj === globalObject.document) {\n  return 'Document';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Spec Conformance\n(https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)\nWhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray\nTest: `Object.prototype.toString.call(navigator.mimeTypes)``\n - IE <=10 === \"[object MSMimeTypesCollection]\"",
      "summary": "! Spec Conformance\n(https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)\nWhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray\nTest: `Object.prototype.toString.call(navigator.mimeTypes)``\n - IE <=10 === \"[object MSMimeTypesCollection]\"",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10471,
    "codeStart": 10477,
    "code": "if (obj === (globalObject.navigator || {}).mimeTypes) {\n  return 'MimeTypeArray';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Spec Conformance\n(https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\nWhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray\nTest: `Object.prototype.toString.call(navigator.plugins)``\n - IE <=10 === \"[object MSPluginsCollection]\"",
      "summary": "! Spec Conformance\n(https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\nWhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray\nTest: `Object.prototype.toString.call(navigator.plugins)``\n - IE <=10 === \"[object MSPluginsCollection]\"",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10481,
    "codeStart": 10487,
    "code": "if (obj === (globalObject.navigator || {}).plugins) {\n  return 'PluginArray';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Spec Conformance\n(https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\nWhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`\nTest: `Object.prototype.toString.call(document.createElement('blockquote'))``\n - IE <=10 === \"[object HTMLBlockElement]\"",
      "summary": "! Spec Conformance\n(https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\nWhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`\nTest: `Object.prototype.toString.call(document.createElement('blockquote'))``\n - IE <=10 === \"[object HTMLBlockElement]\"",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10491,
    "codeStart": 10497,
    "code": "if (obj instanceof HTMLElement && obj.tagName === 'BLOCKQUOTE') {\n  return 'HTMLQuoteElement';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Spec Conformance\n(https://html.spec.whatwg.org/#htmltabledatacellelement)\nWhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`\nNote: Most browsers currently adher to the W3C DOM Level 2 spec\n      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\n      which suggests that browsers should use HTMLTableCellElement for\n      both TD and TH elements. WhatWG separates these.\nTest: Object.prototype.toString.call(document.createElement('td'))\n - Chrome === \"[object HTMLTableCellElement]\"\n - Firefox === \"[object HTMLTableCellElement]\"\n - Safari === \"[object HTMLTableCellElement]\"",
      "summary": "! Spec Conformance\n(https://html.spec.whatwg.org/#htmltabledatacellelement)\nWhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`\nNote: Most browsers currently adher to the W3C DOM Level 2 spec\n      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\n      which suggests that browsers should use HTMLTableCellElement for\n      both TD and TH elements. WhatWG separates these.\nTest: Object.prototype.toString.call(document.createElement('td'))\n - Chrome === \"[object HTMLTableCellElement]\"\n - Firefox === \"[object HTMLTableCellElement]\"\n - Safari === \"[object HTMLTableCellElement]\"",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10501,
    "codeStart": 10513,
    "code": "if (obj instanceof HTMLElement && obj.tagName === 'TD') {\n  return 'HTMLTableDataCellElement';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Spec Conformance\n(https://html.spec.whatwg.org/#htmltableheadercellelement)\nWhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`\nNote: Most browsers currently adher to the W3C DOM Level 2 spec\n      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\n      which suggests that browsers should use HTMLTableCellElement for\n      both TD and TH elements. WhatWG separates these.\nTest: Object.prototype.toString.call(document.createElement('th'))\n - Chrome === \"[object HTMLTableCellElement]\"\n - Firefox === \"[object HTMLTableCellElement]\"\n - Safari === \"[object HTMLTableCellElement]\"",
      "summary": "! Spec Conformance\n(https://html.spec.whatwg.org/#htmltableheadercellelement)\nWhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`\nNote: Most browsers currently adher to the W3C DOM Level 2 spec\n      (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\n      which suggests that browsers should use HTMLTableCellElement for\n      both TD and TH elements. WhatWG separates these.\nTest: Object.prototype.toString.call(document.createElement('th'))\n - Chrome === \"[object HTMLTableCellElement]\"\n - Firefox === \"[object HTMLTableCellElement]\"\n - Safari === \"[object HTMLTableCellElement]\"",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10517,
    "codeStart": 10529,
    "code": "if (obj instanceof HTMLElement && obj.tagName === 'TH') {\n  return 'HTMLTableHeaderCellElement';\n}\n  }",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Speed optimisation\nPre:\n  Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)\n  Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)\n  Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)\n  Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)\n  Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)\n  Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)\n  Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)\n  Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)\n  Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)\nPost:\n  Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)\n  Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)\n  Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)\n  Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)\n  Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)\n  Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)\n  Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)\n  Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)\n  Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)",
      "summary": "! Speed optimisation\nPre:\n  Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)\n  Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)\n  Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)\n  Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)\n  Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)\n  Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)\n  Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)\n  Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)\n  Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)\nPost:\n  Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)\n  Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)\n  Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)\n  Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)\n  Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)\n  Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)\n  Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)\n  Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)\n  Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10534,
    "codeStart": 10556,
    "code": "var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);\nif (typeof stringTag === 'string') {\n  return stringTag;\n}\n\nvar objPrototype = Object.getPrototypeOf(obj);",
    "ctx": {
      "type": "declaration",
      "name": "stringTag",
      "value": "(symbolToStringTagExists && obj[Symbol.toStringTag])",
      "string": "stringTag"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Speed optimisation\nPre:\n  regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)\n  regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)\nPost:\n  regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)\n  regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)",
      "summary": "! Speed optimisation\nPre:\n  regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)\n  regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)\nPost:\n  regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)\n  regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10562,
    "codeStart": 10570,
    "code": "if (objPrototype === RegExp.prototype) {\n  return 'RegExp';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Speed optimisation\nPre:\n  date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)\nPost:\n  date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)",
      "summary": "! Speed optimisation\nPre:\n  date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)\nPost:\n  date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10574,
    "codeStart": 10580,
    "code": "if (objPrototype === Date.prototype) {\n  return 'Date';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Spec Conformance\n(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)\nES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be \"Promise\":\nTest: `Object.prototype.toString.call(Promise.resolve())``\n - Chrome <=47 === \"[object Object]\"\n - Edge <=20 === \"[object Object]\"\n - Firefox 29-Latest === \"[object Promise]\"\n - Safari 7.1-Latest === \"[object Promise]\"",
      "summary": "! Spec Conformance\n(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)\nES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be \"Promise\":\nTest: `Object.prototype.toString.call(Promise.resolve())``\n - Chrome <=47 === \"[object Object]\"\n - Edge <=20 === \"[object Object]\"\n - Firefox 29-Latest === \"[object Promise]\"\n - Safari 7.1-Latest === \"[object Promise]\"",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10584,
    "codeStart": 10593,
    "code": "if (promiseExists && objPrototype === Promise.prototype) {\n  return 'Promise';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Speed optimisation\nPre:\n  set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)\nPost:\n  set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)",
      "summary": "! Speed optimisation\nPre:\n  set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)\nPost:\n  set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10597,
    "codeStart": 10603,
    "code": "if (setExists && objPrototype === Set.prototype) {\n  return 'Set';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Speed optimisation\nPre:\n  map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)\nPost:\n  map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)",
      "summary": "! Speed optimisation\nPre:\n  map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)\nPost:\n  map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10607,
    "codeStart": 10613,
    "code": "if (mapExists && objPrototype === Map.prototype) {\n  return 'Map';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Speed optimisation\nPre:\n  weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)\nPost:\n  weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)",
      "summary": "! Speed optimisation\nPre:\n  weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)\nPost:\n  weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10617,
    "codeStart": 10623,
    "code": "if (weakSetExists && objPrototype === WeakSet.prototype) {\n  return 'WeakSet';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Speed optimisation\nPre:\n  weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)\nPost:\n  weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)",
      "summary": "! Speed optimisation\nPre:\n  weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)\nPost:\n  weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10627,
    "codeStart": 10633,
    "code": "if (weakMapExists && objPrototype === WeakMap.prototype) {\n  return 'WeakMap';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Spec Conformance\n(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)\nES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be \"DataView\":\nTest: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``\n - Edge <=13 === \"[object Object]\"",
      "summary": "! Spec Conformance\n(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)\nES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be \"DataView\":\nTest: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``\n - Edge <=13 === \"[object Object]\"",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10637,
    "codeStart": 10643,
    "code": "if (dataViewExists && objPrototype === DataView.prototype) {\n  return 'DataView';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Spec Conformance\n(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)\nES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be \"Map Iterator\":\nTest: `Object.prototype.toString.call(new Map().entries())``\n - Edge <=13 === \"[object Object]\"",
      "summary": "! Spec Conformance\n(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)\nES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be \"Map Iterator\":\nTest: `Object.prototype.toString.call(new Map().entries())``\n - Edge <=13 === \"[object Object]\"",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10647,
    "codeStart": 10653,
    "code": "if (mapExists && objPrototype === mapIteratorPrototype) {\n  return 'Map Iterator';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Spec Conformance\n(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)\nES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be \"Set Iterator\":\nTest: `Object.prototype.toString.call(new Set().entries())``\n - Edge <=13 === \"[object Object]\"",
      "summary": "! Spec Conformance\n(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)\nES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be \"Set Iterator\":\nTest: `Object.prototype.toString.call(new Set().entries())``\n - Edge <=13 === \"[object Object]\"",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10657,
    "codeStart": 10663,
    "code": "if (setExists && objPrototype === setIteratorPrototype) {\n  return 'Set Iterator';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Spec Conformance\n(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)\nES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be \"Array Iterator\":\nTest: `Object.prototype.toString.call([][Symbol.iterator]())``\n - Edge <=13 === \"[object Object]\"",
      "summary": "! Spec Conformance\n(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)\nES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be \"Array Iterator\":\nTest: `Object.prototype.toString.call([][Symbol.iterator]())``\n - Edge <=13 === \"[object Object]\"",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10667,
    "codeStart": 10673,
    "code": "if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {\n  return 'Array Iterator';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Spec Conformance\n(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)\nES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be \"String Iterator\":\nTest: `Object.prototype.toString.call(''[Symbol.iterator]())``\n - Edge <=13 === \"[object Object]\"",
      "summary": "! Spec Conformance\n(http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)\nES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be \"String Iterator\":\nTest: `Object.prototype.toString.call(''[Symbol.iterator]())``\n - Edge <=13 === \"[object Object]\"",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10677,
    "codeStart": 10683,
    "code": "if (stringIteratorExists && objPrototype === stringIteratorPrototype) {\n  return 'String Iterator';\n}",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "! Speed optimisation\nPre:\n  object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)\nPost:\n  object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)",
      "summary": "! Speed optimisation\nPre:\n  object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)\nPost:\n  object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 10687,
    "codeStart": 10693,
    "code": "if (objPrototype === null) {\n  return 'Object';\n}\n\nreturn Object\n  .prototype\n  .toString\n  .call(obj)\n  .slice(toStringLeftSliceLength, toStringRightSliceLength);\n};\n\nmodule.exports.typeDetect = module.exports;\n\n},{}]},{},[1])(1)\n});",
    "ctx": {
      "type": "method",
      "name": "if",
      "string": "if()"
    }
  }
]